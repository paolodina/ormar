{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ormar Overview The ormar package is an async mini ORM for Python, with support for Postgres, MySQL , and SQLite . The main benefit of using ormar are: getting an async ORM that can be used with async frameworks (fastapi, starlette etc.) getting just one model to maintain - you don't have to maintain pydantic and other orm model (sqlalchemy, peewee, gino etc.) The goal was to create a simple ORM that can be used directly (as request and response models) with fastapi that bases it's data validation on pydantic. Ormar - apart form obvious ORM in name - get it's name from ormar in swedish which means snakes, and ormar(e) in italian which means cabinet. And what's a better name for python ORM than snakes cabinet :) Documentation Check out the documentation for details. Dependencies Ormar is built with: SQLAlchemy core for query building. databases for cross-database async support. pydantic for data validation. typing_extensions for python 3.6 - 3.7 Migrations Because ormar is built on SQLAlchemy core, you can use alembic to provide database migrations. ormar is still under development: We recommend pinning any dependencies (with i.e. ormar~=0.5.2 ) Quick Start Note : Use ipython to try this from the console, since it supports await . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database # note that type hints are optional so # id = ormar.Integer(primary_key=True) # is also valid id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () # Create some records to work with. malibu = await Album . objects . create ( name = \"Malibu\" ) await Track . objects . create ( album = malibu , title = \"The Bird\" , position = 1 ) await Track . objects . create ( album = malibu , title = \"Heart don't stand a chance\" , position = 2 ) await Track . objects . create ( album = malibu , title = \"The Waters\" , position = 3 ) # alternative creation of object divided into 2 steps fantasies = Album ( name = \"Fantasies\" ) await fantasies . save () await Track . objects . create ( album = fantasies , title = \"Help I'm Alive\" , position = 1 ) await Track . objects . create ( album = fantasies , title = \"Sick Muse\" , position = 2 ) # Fetch an instance, without loading a foreign key relationship on it. track = await Track . objects . get ( title = \"The Bird\" ) # We have an album instance, but it only has the primary key populated print ( track . album ) # Album(id=1) [sparse] print ( track . album . pk ) # 1 print ( track . album . name ) # None # Load the relationship from the database await track . album . load () assert track . album . name == \"Malibu\" # This time, fetch an instance, loading the foreign key relationship. track = await Track . objects . select_related ( \"album\" ) . get ( title = \"The Bird\" ) assert track . album . name == \"Malibu\" # By default you also get a second side of the relation # constructed as lowercase source model name +'s' (tracks in this case) # you can also provide custom name with parameter related_name album = await Album . objects . select_related ( \"tracks\" ) . all () assert len ( album . tracks ) == 3 # Fetch instances, with a filter across an FK relationship. tracks = await Track . objects . filter ( album__name = \"Fantasies\" ) . all () assert len ( tracks ) == 2 # Fetch instances, with a filter and operator across an FK relationship. tracks = await Track . objects . filter ( album__name__iexact = \"fantasies\" ) . all () assert len ( tracks ) == 2 # Limit a query tracks = await Track . objects . limit ( 1 ) . all () assert len ( tracks ) == 1 Ormar Specification QuerySet methods create(**kwargs): -> Model get(**kwargs): -> Model get_or_create(**kwargs) -> Model first(): -> Model update(each: bool = False, **kwargs) -> int update_or_create(**kwargs) -> Model bulk_create(objects: List[Model]) -> None bulk_update(objects: List[Model], columns: List[str] = None) -> None delete(each: bool = False, **kwargs) -> int all(**kwargs) -> List[Optional[Model]] filter(**kwargs) -> QuerySet exclude(**kwargs) -> QuerySet select_related(related: Union[List, str]) -> QuerySet prefetch_related(related: Union[List, str]) -> QuerySet limit(limit_count: int) -> QuerySet offset(offset: int) -> QuerySet count() -> int exists() -> bool fields(columns: Union[List, str, set, dict]) -> QuerySet exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet order_by(columns:Union[List, str]) -> QuerySet Relation types One to many - with ForeignKey(to: Model) Many to many - with ManyToMany(to: Model, through: Model) Model fields types Available Model Fields (with required args - optional ones in docs): String(max_length) Text() Boolean() Integer() Float() Date() Time() DateTime() JSON() BigInteger() Decimal(scale, precision) UUID() ForeignKey(to) ManyToMany(to, through) Available fields options The following keyword arguments are supported on all field types. primary_key: bool nullable: bool default: Any server_default: Any index: bool unique: bool choices: typing.Sequence name: str pydantic_only: bool All fields are required unless one of the following is set: nullable - Creates a nullable column. Sets the default to None . default - Set a default value for the field. server_default - Set a default value for the field on server side (like sqlalchemy's func.now() ). primary key with autoincrement - When a column is set to primary key and autoincrement is set on this column. Autoincrement is set by default on int primary keys. pydantic_only - Field is available only as normal pydantic field, not stored in the database. Available signals Signals allow to trigger your function for a given event on a given Model. pre_save post_save pre_update post_update pre_delete post_delete","title":"Overview"},{"location":"#ormar","text":"","title":"ormar"},{"location":"#overview","text":"The ormar package is an async mini ORM for Python, with support for Postgres, MySQL , and SQLite . The main benefit of using ormar are: getting an async ORM that can be used with async frameworks (fastapi, starlette etc.) getting just one model to maintain - you don't have to maintain pydantic and other orm model (sqlalchemy, peewee, gino etc.) The goal was to create a simple ORM that can be used directly (as request and response models) with fastapi that bases it's data validation on pydantic. Ormar - apart form obvious ORM in name - get it's name from ormar in swedish which means snakes, and ormar(e) in italian which means cabinet. And what's a better name for python ORM than snakes cabinet :)","title":"Overview"},{"location":"#documentation","text":"Check out the documentation for details.","title":"Documentation"},{"location":"#dependencies","text":"Ormar is built with: SQLAlchemy core for query building. databases for cross-database async support. pydantic for data validation. typing_extensions for python 3.6 - 3.7","title":"Dependencies"},{"location":"#migrations","text":"Because ormar is built on SQLAlchemy core, you can use alembic to provide database migrations. ormar is still under development: We recommend pinning any dependencies (with i.e. ormar~=0.5.2 )","title":"Migrations"},{"location":"#quick-start","text":"Note : Use ipython to try this from the console, since it supports await . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database # note that type hints are optional so # id = ormar.Integer(primary_key=True) # is also valid id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () # Create some records to work with. malibu = await Album . objects . create ( name = \"Malibu\" ) await Track . objects . create ( album = malibu , title = \"The Bird\" , position = 1 ) await Track . objects . create ( album = malibu , title = \"Heart don't stand a chance\" , position = 2 ) await Track . objects . create ( album = malibu , title = \"The Waters\" , position = 3 ) # alternative creation of object divided into 2 steps fantasies = Album ( name = \"Fantasies\" ) await fantasies . save () await Track . objects . create ( album = fantasies , title = \"Help I'm Alive\" , position = 1 ) await Track . objects . create ( album = fantasies , title = \"Sick Muse\" , position = 2 ) # Fetch an instance, without loading a foreign key relationship on it. track = await Track . objects . get ( title = \"The Bird\" ) # We have an album instance, but it only has the primary key populated print ( track . album ) # Album(id=1) [sparse] print ( track . album . pk ) # 1 print ( track . album . name ) # None # Load the relationship from the database await track . album . load () assert track . album . name == \"Malibu\" # This time, fetch an instance, loading the foreign key relationship. track = await Track . objects . select_related ( \"album\" ) . get ( title = \"The Bird\" ) assert track . album . name == \"Malibu\" # By default you also get a second side of the relation # constructed as lowercase source model name +'s' (tracks in this case) # you can also provide custom name with parameter related_name album = await Album . objects . select_related ( \"tracks\" ) . all () assert len ( album . tracks ) == 3 # Fetch instances, with a filter across an FK relationship. tracks = await Track . objects . filter ( album__name = \"Fantasies\" ) . all () assert len ( tracks ) == 2 # Fetch instances, with a filter and operator across an FK relationship. tracks = await Track . objects . filter ( album__name__iexact = \"fantasies\" ) . all () assert len ( tracks ) == 2 # Limit a query tracks = await Track . objects . limit ( 1 ) . all () assert len ( tracks ) == 1","title":"Quick Start"},{"location":"#ormar-specification","text":"","title":"Ormar Specification"},{"location":"#queryset-methods","text":"create(**kwargs): -> Model get(**kwargs): -> Model get_or_create(**kwargs) -> Model first(): -> Model update(each: bool = False, **kwargs) -> int update_or_create(**kwargs) -> Model bulk_create(objects: List[Model]) -> None bulk_update(objects: List[Model], columns: List[str] = None) -> None delete(each: bool = False, **kwargs) -> int all(**kwargs) -> List[Optional[Model]] filter(**kwargs) -> QuerySet exclude(**kwargs) -> QuerySet select_related(related: Union[List, str]) -> QuerySet prefetch_related(related: Union[List, str]) -> QuerySet limit(limit_count: int) -> QuerySet offset(offset: int) -> QuerySet count() -> int exists() -> bool fields(columns: Union[List, str, set, dict]) -> QuerySet exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet order_by(columns:Union[List, str]) -> QuerySet","title":"QuerySet methods"},{"location":"#relation-types","text":"One to many - with ForeignKey(to: Model) Many to many - with ManyToMany(to: Model, through: Model)","title":"Relation types"},{"location":"#model-fields-types","text":"Available Model Fields (with required args - optional ones in docs): String(max_length) Text() Boolean() Integer() Float() Date() Time() DateTime() JSON() BigInteger() Decimal(scale, precision) UUID() ForeignKey(to) ManyToMany(to, through)","title":"Model fields types"},{"location":"#available-fields-options","text":"The following keyword arguments are supported on all field types. primary_key: bool nullable: bool default: Any server_default: Any index: bool unique: bool choices: typing.Sequence name: str pydantic_only: bool All fields are required unless one of the following is set: nullable - Creates a nullable column. Sets the default to None . default - Set a default value for the field. server_default - Set a default value for the field on server side (like sqlalchemy's func.now() ). primary key with autoincrement - When a column is set to primary key and autoincrement is set on this column. Autoincrement is set by default on int primary keys. pydantic_only - Field is available only as normal pydantic field, not stored in the database.","title":"Available fields options"},{"location":"#available-signals","text":"Signals allow to trigger your function for a given event on a given Model. pre_save post_save pre_update post_update pre_delete post_delete","title":"Available signals"},{"location":"contributing/","text":"All contributions to ormar are welcomed! Issues To make it as simple as possible for us to help you, please include the following: OS python version ormar version database backend (mysql, sqlite or postgresql) Please try to always include the above unless you're unable to install ormar or know it's not relevant to your question or feature request. Pull Requests It should be quite straight forward to get started and create a Pull Request. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. To make contributing as easy and fast as possible, you'll want to run tests and linting locally. You'll need to have python 3.6 , 3.7 , or 3.8 , virtualenv , and git installed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # 1. clone your fork and cd into the repo directory git clone git@github.com:<your username>/ormar.git cd ormar # 2. Set up a virtualenv for running tests virtualenv -p ` which python3.7 ` env source env/bin/activate # (or however you prefer to setup a python environment, 3.6 will work too) # 3. Install ormar, dependencies and test dependencies pip install -r requirements.txt # 4. Checkout a new branch and make your changes git checkout -b my-new-feature-branch # make your changes... # 5. Formatting and linting # ormar uses black for formatting, flake8 for linting and mypy for type hints check # run all of the following as all those calls will be run on travis after every push black ormar tests flake8 ormar mypy --config-file mypy.ini ormar tests # 6. Run tests # on localhost all tests are run against sglite backend # rest of the backends will be checked after push pytest -svv --cov = ormar --cov = tests --cov-fail-under = 100 --cov-report = term-missing # 7. Build documentation mkdocs build # if you have changed the documentation make sure it builds successfully # you can also use `mkdocs serve` to serve the documentation at localhost:8000 # ... commit, push, and create your pull request Tip For more information on how and why ormar works the way it works please see the API documentation","title":"Contributing"},{"location":"contributing/#issues","text":"To make it as simple as possible for us to help you, please include the following: OS python version ormar version database backend (mysql, sqlite or postgresql) Please try to always include the above unless you're unable to install ormar or know it's not relevant to your question or feature request.","title":"Issues"},{"location":"contributing/#pull-requests","text":"It should be quite straight forward to get started and create a Pull Request. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. To make contributing as easy and fast as possible, you'll want to run tests and linting locally. You'll need to have python 3.6 , 3.7 , or 3.8 , virtualenv , and git installed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # 1. clone your fork and cd into the repo directory git clone git@github.com:<your username>/ormar.git cd ormar # 2. Set up a virtualenv for running tests virtualenv -p ` which python3.7 ` env source env/bin/activate # (or however you prefer to setup a python environment, 3.6 will work too) # 3. Install ormar, dependencies and test dependencies pip install -r requirements.txt # 4. Checkout a new branch and make your changes git checkout -b my-new-feature-branch # make your changes... # 5. Formatting and linting # ormar uses black for formatting, flake8 for linting and mypy for type hints check # run all of the following as all those calls will be run on travis after every push black ormar tests flake8 ormar mypy --config-file mypy.ini ormar tests # 6. Run tests # on localhost all tests are run against sglite backend # rest of the backends will be checked after push pytest -svv --cov = ormar --cov = tests --cov-fail-under = 100 --cov-report = term-missing # 7. Build documentation mkdocs build # if you have changed the documentation make sure it builds successfully # you can also use `mkdocs serve` to serve the documentation at localhost:8000 # ... commit, push, and create your pull request Tip For more information on how and why ormar works the way it works please see the API documentation","title":"Pull Requests"},{"location":"fastapi/","text":"The use of ormar with fastapi is quite simple. Apart from connecting to databases at startup everything else you need to do is substitute pydantic models with ormar models. Here you can find a very simple sample application code. Warning This example assumes that you already have a database created. If that is not the case please visit database initialization section. Tip The following example (all sections) should be put in one file. It's divided into subsections for clarity. Imports and initialization First take care of the imports and initialization 1 2 3 4 5 6 7 8 9 10 11 12 from typing import List , Optional import databases import sqlalchemy from fastapi import FastAPI import ormar app = FastAPI () metadata = sqlalchemy . MetaData () database = databases . Database ( \"sqlite:///test.db\" ) app . state . database = database Database connection Next define startup and shutdown events (or use middleware) - note that this is databases specific setting not the ormar one 1 2 3 4 5 6 7 8 9 10 11 12 @app . on_event ( \"startup\" ) async def startup () -> None : database_ = app . state . database if not database_ . is_connected : await database_ . connect () @app . on_event ( \"shutdown\" ) async def shutdown () -> None : database_ = app . state . database if database_ . is_connected : await database_ . disconnect () Info You can read more on connecting to databases in fastapi documentation Models definition Define ormar models with appropriate fields. Those models will be used insted of pydantic ones. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) Tip You can read more on defining Models in models section. Fastapi endpoints definition Define your desired endpoints, note how ormar models are used both as response_model and as a requests parameters. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @app . get ( \"/items/\" , response_model = List [ Item ]) async def get_items (): items = await Item . objects . select_related ( \"category\" ) . all () return items @app . post ( \"/items/\" , response_model = Item ) async def create_item ( item : Item ): await item . save () return item @app . post ( \"/categories/\" , response_model = Category ) async def create_category ( category : Category ): await category . save () return category @app . put ( \"/items/ {item_id} \" ) async def get_item ( item_id : int , item : Item ): item_db = await Item . objects . get ( pk = item_id ) return await item_db . update ( ** item . dict ()) @app . delete ( \"/items/ {item_id} \" ) async def delete_item ( item_id : int , item : Item = None ): if item : return { \"deleted_rows\" : await item . delete ()} item_db = await Item . objects . get ( pk = item_id ) return { \"deleted_rows\" : await item_db . delete ()} Note Note how ormar Model methods like save() are available straight out of the box after fastapi initializes it for you. Note Note that you can return a Model (or list of Models ) directly - fastapi will jsonize it for you Test the application Run fastapi If you want to run this script and play with fastapi swagger install uvicorn first pip install uvicorn And launch the fastapi. uvicorn <filename_without_extension>:app --reload Now you can navigate to your browser (by default fastapi address is 127.0.0.1:8000/docs ) and play with the api. Info You can read more about running fastapi in fastapi docs. Test with pytest Here you have a sample test that will prove that everything works as intended. Be sure to create the tables first. If you are using pytest you can use a fixture. 1 2 3 4 5 6 @pytest . fixture ( autouse = True , scope = \"module\" ) def create_test_database (): engine = sqlalchemy . create_engine ( DATABASE_URL ) metadata . create_all ( engine ) yield metadata . drop_all ( engine ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # here is a sample test to check the working of the ormar with fastapi from starlette.testclient import TestClient def test_all_endpoints (): # note that TestClient is only sync, don't use asyns here client = TestClient ( app ) # note that you need to connect to database manually # or use client as contextmanager during tests with client as client : response = client . post ( \"/categories/\" , json = { \"name\" : \"test cat\" }) category = response . json () response = client . post ( \"/items/\" , json = { \"name\" : \"test\" , \"id\" : 1 , \"category\" : category } ) item = Item ( ** response . json ()) assert item . pk is not None response = client . get ( \"/items/\" ) items = [ Item ( ** item ) for item in response . json ()] assert items [ 0 ] == item item . name = \"New name\" response = client . put ( f \"/items/ { item . pk } \" , json = item . dict ()) assert response . json () == item . dict () response = client . get ( \"/items/\" ) items = [ Item ( ** item ) for item in response . json ()] assert items [ 0 ] . name == \"New name\" response = client . delete ( f \"/items/ { item . pk } \" , json = item . dict ()) assert response . json () . get ( \"deleted_rows\" , \"__UNDEFINED__\" ) != \"__UNDEFINED__\" response = client . get ( \"/items/\" ) items = response . json () assert len ( items ) == 0 Tip If you want to see more test cases and how to test ormar/fastapi see tests directory in the github repo Info You can read more on testing fastapi in fastapi docs.","title":"Use with Fastapi"},{"location":"fastapi/#imports-and-initialization","text":"First take care of the imports and initialization 1 2 3 4 5 6 7 8 9 10 11 12 from typing import List , Optional import databases import sqlalchemy from fastapi import FastAPI import ormar app = FastAPI () metadata = sqlalchemy . MetaData () database = databases . Database ( \"sqlite:///test.db\" ) app . state . database = database","title":"Imports and initialization"},{"location":"fastapi/#database-connection","text":"Next define startup and shutdown events (or use middleware) - note that this is databases specific setting not the ormar one 1 2 3 4 5 6 7 8 9 10 11 12 @app . on_event ( \"startup\" ) async def startup () -> None : database_ = app . state . database if not database_ . is_connected : await database_ . connect () @app . on_event ( \"shutdown\" ) async def shutdown () -> None : database_ = app . state . database if database_ . is_connected : await database_ . disconnect () Info You can read more on connecting to databases in fastapi documentation","title":"Database connection"},{"location":"fastapi/#models-definition","text":"Define ormar models with appropriate fields. Those models will be used insted of pydantic ones. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) Tip You can read more on defining Models in models section.","title":"Models definition"},{"location":"fastapi/#fastapi-endpoints-definition","text":"Define your desired endpoints, note how ormar models are used both as response_model and as a requests parameters. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @app . get ( \"/items/\" , response_model = List [ Item ]) async def get_items (): items = await Item . objects . select_related ( \"category\" ) . all () return items @app . post ( \"/items/\" , response_model = Item ) async def create_item ( item : Item ): await item . save () return item @app . post ( \"/categories/\" , response_model = Category ) async def create_category ( category : Category ): await category . save () return category @app . put ( \"/items/ {item_id} \" ) async def get_item ( item_id : int , item : Item ): item_db = await Item . objects . get ( pk = item_id ) return await item_db . update ( ** item . dict ()) @app . delete ( \"/items/ {item_id} \" ) async def delete_item ( item_id : int , item : Item = None ): if item : return { \"deleted_rows\" : await item . delete ()} item_db = await Item . objects . get ( pk = item_id ) return { \"deleted_rows\" : await item_db . delete ()} Note Note how ormar Model methods like save() are available straight out of the box after fastapi initializes it for you. Note Note that you can return a Model (or list of Models ) directly - fastapi will jsonize it for you","title":"Fastapi endpoints definition"},{"location":"fastapi/#test-the-application","text":"","title":"Test the application"},{"location":"fastapi/#run-fastapi","text":"If you want to run this script and play with fastapi swagger install uvicorn first pip install uvicorn And launch the fastapi. uvicorn <filename_without_extension>:app --reload Now you can navigate to your browser (by default fastapi address is 127.0.0.1:8000/docs ) and play with the api. Info You can read more about running fastapi in fastapi docs.","title":"Run fastapi"},{"location":"fastapi/#test-with-pytest","text":"Here you have a sample test that will prove that everything works as intended. Be sure to create the tables first. If you are using pytest you can use a fixture. 1 2 3 4 5 6 @pytest . fixture ( autouse = True , scope = \"module\" ) def create_test_database (): engine = sqlalchemy . create_engine ( DATABASE_URL ) metadata . create_all ( engine ) yield metadata . drop_all ( engine ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # here is a sample test to check the working of the ormar with fastapi from starlette.testclient import TestClient def test_all_endpoints (): # note that TestClient is only sync, don't use asyns here client = TestClient ( app ) # note that you need to connect to database manually # or use client as contextmanager during tests with client as client : response = client . post ( \"/categories/\" , json = { \"name\" : \"test cat\" }) category = response . json () response = client . post ( \"/items/\" , json = { \"name\" : \"test\" , \"id\" : 1 , \"category\" : category } ) item = Item ( ** response . json ()) assert item . pk is not None response = client . get ( \"/items/\" ) items = [ Item ( ** item ) for item in response . json ()] assert items [ 0 ] == item item . name = \"New name\" response = client . put ( f \"/items/ { item . pk } \" , json = item . dict ()) assert response . json () == item . dict () response = client . get ( \"/items/\" ) items = [ Item ( ** item ) for item in response . json ()] assert items [ 0 ] . name == \"New name\" response = client . delete ( f \"/items/ { item . pk } \" , json = item . dict ()) assert response . json () . get ( \"deleted_rows\" , \"__UNDEFINED__\" ) != \"__UNDEFINED__\" response = client . get ( \"/items/\" ) items = response . json () assert len ( items ) == 0 Tip If you want to see more test cases and how to test ormar/fastapi see tests directory in the github repo Info You can read more on testing fastapi in fastapi docs.","title":"Test with pytest"},{"location":"install/","text":"Installation Installation is as simple as: 1 pip install ormar Dependencies Ormar uses databases for connectivity issues, pydantic for validation and sqlalchemy-core for queries. All three should install along the installation of ormar if not present at your system before. databases pydantic>=1.5 sqlalchemy Optional dependencies ormar has three optional dependencies based on database backend you use: Postgresql 1 pip install ormar [ postgresql ] Will install also asyncpg and psycopg2 . Mysql 1 pip install ormar [ mysql ] Will install also aiomysql and pymysql . Sqlite 1 pip install ormar [ sqlite ] Will install also aiosqlite . Manual installation of dependencies Of course, you can also install these requirements manually with pip install asyncpg etc.","title":"Installation"},{"location":"install/#installation","text":"Installation is as simple as: 1 pip install ormar","title":"Installation"},{"location":"install/#dependencies","text":"Ormar uses databases for connectivity issues, pydantic for validation and sqlalchemy-core for queries. All three should install along the installation of ormar if not present at your system before. databases pydantic>=1.5 sqlalchemy","title":"Dependencies"},{"location":"install/#optional-dependencies","text":"ormar has three optional dependencies based on database backend you use:","title":"Optional dependencies"},{"location":"install/#postgresql","text":"1 pip install ormar [ postgresql ] Will install also asyncpg and psycopg2 .","title":"Postgresql"},{"location":"install/#mysql","text":"1 pip install ormar [ mysql ] Will install also aiomysql and pymysql .","title":"Mysql"},{"location":"install/#sqlite","text":"1 pip install ormar [ sqlite ] Will install also aiosqlite .","title":"Sqlite"},{"location":"install/#manual-installation-of-dependencies","text":"Of course, you can also install these requirements manually with pip install asyncpg etc.","title":"Manual installation of dependencies"},{"location":"mypy/","text":"To provide better errors check you should use mypy with pydantic plugin Note that legacy model declaration type will raise static type analyzers errors. So you cannot use the old notation like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : ormar . Integer ( primary_key = True ) name : ormar . String ( max_length = 100 ) completed : ormar . Boolean ( default = False ) c1 = Course () Instead switch to notation introduced in version 0.4.0. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 100 ) completed = ormar . Boolean ( default = False ) Note that above example is not using the type hints, so further operations with mypy might fail, depending on the context. Preferred notation should look liked this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False )","title":"Use with mypy"},{"location":"plugin/","text":"While ormar will work with any IDE there is a PyCharm pydantic plugin that enhances the user experience for this IDE. Plugin is available on the JetBrains Plugins Repository for PyCharm: plugin page . You can install the plugin for free from the plugin marketplace (PyCharm's Preferences -> Plugin -> Marketplace -> search \"pydantic\"). Note For plugin to work properly you need to provide valid type hints for model fields. Info Plugin supports type hints, argument inspection and more but mainly only for init methods More information can be found on the official plugin page and github repository .","title":"PyCharm plugin"},{"location":"releases/","text":"0.8.1 Features Introduce processing of ForwardRef in relations. Now you can create self-referencing models - both ForeignKey and ManyToMany relations. ForwardRef can be used both for to and through Models . Introduce the possibility to perform two same relation joins in one query, so to process complex relations like: 1 2 3 4 5 6 7 B = X = Y // A \\ C = X = Y <= before you could link from X to Y only once in one query unless two different relation were used (two relation fields with different names) Introduce the paginate method that allows to limit/offset by page and page_size . Available for QuerySet and QuerysetProxy . Other Refactoring and performance optimization in queries and joins. Add python 3.9 to tests and pypi setup. Update API docs and docs -> i.e. split of queries documentation. 0.8.0 Breaking Breaking: remove() parent from child side in reverse ForeignKey relation now requires passing a relation name , as the same model can be registered multiple times and ormar needs to know from which relation on the parent you want to remove the child. Breaking: applying limit and offset with select_related is by default applied only on the main table before the join -> meaning that not the total number of rows is limited but just number of main models (first one in the query, the one used to construct it). You can still limit all rows from db response with limit_raw_sql=True flag on either limit or offset (or both) Breaking: issuing first() now fetches the first row ordered by the primary key asc (so first one inserted (can be different for non number primary keys - i.e. alphabetical order of string)) Breaking: issuing get() without any filters now fetches the first row ordered by the primary key desc (so should be last one inserted (can be different for non number primary keys - i.e. alphabetical order of string)) Breaking (internal): sqlalchemy columns kept at Meta.columns are no longer bind to table, so you cannot get the column straight from there Features Introduce inheritance . For now two types of inheritance are possible: Mixins - don't subclass ormar.Model , just define fields that are later used on different models (like created_date and updated_date on each child model), only actual models create tables, but those fields from mixins are added Concrete table inheritance - means that parent is marked as abstract=True in Meta class and each child has its own table with columns from the parent and own child columns, kind of similar to Mixins but parent also is a (an abstract) Model To read more check the docs on models -> inheritance section. QuerySet first() can be used with prefetch_related Fixes Fix minor bug in order_by for primary model order bys Fix in prefetch_query for multiple related_names for the same model. Fix using same related_name on different models leading to the same related Model overwriting each other, now ModelDefinitionError is raised and you need to change the name. Fix order_by overwriting conditions when multiple joins to the same table applied. Docs Split and cleanup in docs: Divide models section into subsections Divide relations section into subsections Divide fields section into subsections Add model inheritance section Add API (BETA) documentation 0.7.5 Fix for wrong relation column name in many_to_many relation joins (fix #73 ) 0.7.4 Allow multiple relations to the same related model/table. Fix for wrong relation column used in many_to_many relation joins (fix #73 ) Fix for wrong relation population for m2m relations when also fk relation present for same model. Add check if user provide related_name if there are multiple relations to same table on one model. More eager cleaning of the dead weak proxy models. 0.7.3 Fix for setting fetching related model with UUDI pk, which is a string in raw (fix #71 ) 0.7.2 Fix for overwriting related models with pk only in Model.update() with fields passed as parameters (fix #70 ) 0.7.1 Fix for overwriting related models with pk only in Model.save() (fix #68 ) 0.7.0 Breaking: QuerySet bulk_update method now raises ModelPersistenceError for unsaved models passed instead of QueryDefinitionError Breaking: Model initialization with unknown field name now raises ModelError instead of KeyError Added Signals , with pre-defined list signals and decorators: post_delete , post_save , post_update , pre_delete , pre_save , pre_update Add py.typed and modify setup.py for mypy support Performance optimization Updated docs 0.6.2 Performance optimization Fix for bug with pydantic_only fields being required Add property_field decorator that registers a function as a property that will be included in Model.dict() and in fastapi response Update docs 0.6.1 Explicitly set None to excluded nullable fields to avoid pydantic setting a default value (fix #60 ). 0.6.0 Breaking: calling instance.load() when the instance row was deleted from db now raises NoMatch instead of ValueError Breaking: calling add and remove on ReverseForeignKey relation now updates the child model in db setting/removing fk column Breaking: ReverseForeignKey relation now exposes QuerySetProxy API like ManyToMany relation Breaking: querying related models from ManyToMany cleans list of related models loaded on parent model: Example: post.categories.first() will set post.categories to list of 1 related model -> the one returned by first() Example 2: if post has 4 categories so len(post.categories) == 4 calling post.categories.limit(2).all() -> will load only 2 children and now assert len(post.categories) == 2 Added get_or_create , update_or_create , fields , exclude_fields , exclude , prefetch_related and order_by to QuerySetProxy so now you can use those methods directly from relation Update docs 0.5.5 Fix for alembic autogenaration of migration UUID columns. It should just produce sqlalchemy CHAR(32) or CHAR(36) In order for this to work you have to set user_module_prefix='sa.' (must be equal to sqlalchemy_module_prefix option (default 'sa.')) 0.5.4 Allow to pass uuid_format (allowed 'hex'(default) or 'string') to UUID field to change the format in which it's saved. By default field is saved in hex format (trimmed to 32 chars (without dashes)), but you can pass format='string' to use 36 (with dashes) instead to adjust to existing db or other libraries. Sample: * hex value = c616ab438cce49dbbf4380d109251dce * string value = c616ab43-8cce-49db-bf43-80d109251dce 0.5.3 Fixed bug in Model.dict() method that was ignoring exclude parameter and not include dictionary argument. 0.5.2 Added prefetch_related method to load subsequent models in separate queries. Update docs 0.5.1 Switched to github actions instead of travis Update badges in the docs 0.5.0 Added save status -> you can check if model is saved with ModelInstance.saved property Model is saved after save/update/load/upsert method on model Model is saved after create/get/first/all/get_or_create/update_or_create method Model is saved when passed to bulk_update and bulk_create Model is saved after adding/removing ManyToMany related objects (through model instance auto saved/deleted) Model is not saved after change of any own field (including pk as Model.pk alias) Model is not saved after adding/removing ForeignKey related object (fk column not saved) Model is not saved after instantation with __init__ (w/o QuerySet.create or before calling save ) Added Model.upsert(**kwargs) that performs save() if pk not set otherwise update(**kwargs) Added Model.save_related(follow=False) that iterates all related objects in all relations and checks if they are saved. If not it calls upsert() on each of them. Breaking: added raising exceptions if add -ing/ remove -ing not saved (pk is None) models to ManyToMany relation Allow passing dictionaries and sets to fields and exclude_fields Auto translate str and lists to dicts for fields and exclude_fields Breaking: passing nested models to fields and exclude_fields is now by related ForeignKey name and not by target model name Performance optimizations - in modelproxy, newbasemodel - > less queries, some properties are cached on models Cleanup of unused relations code Optional performance dependency orjson added ( strongly recommended ) Updated docs 0.4.4 add exclude_fields() method to exclude fields from sql refactor column names setting (aliases) fix ordering by for column with aliases additional tests for fields and exclude_fields update docs 0.4.3 include properties in models.dict() and model.json() 0.4.2 modify creation of pydantic models to allow returning related models with only pk populated 0.4.1 add order_by method to queryset to allow sorting update docs 0.4.0 Changed notation in Model definition -> now use name = ormar.Field() not name: ormar.Field() Note that old notation is still supported but deprecated and will not play nice with static checkers like mypy and pydantic pycharm plugin Type hint docs and test Use mypy for tests also not, only ormar package Fix scale and precision translation with max_digits and decimal_places pydantic Decimal field Update docs - add best practices for dependencies Refactor metaclass and model_fields to play nice with type hints Add mypy and pydantic plugin to docs Expand the docs on ManyToMany relation 0.3.11 Fix setting server_default as default field value in python 0.3.10 Fix postgresql check to avoid exceptions with drivers not installed if using different backend 0.3.9 Fix json schema generation as of #19 Fix for not initialized ManyToMany relations in fastapi copies of ormar.Models Update docs in regard of fastapi use Add tests to verify fastapi/docs proper generation 0.3.8 Added possibility to provide alternative database column names with name parameter to all fields. Fix bug with selecting related ManyToMany fields with fields() if they are empty. Updated documentation 0.3.7 Publish documentation and update readme 0.3.6 Add fields() method to limit the selected columns from database - only nullable columns can be excluded. Added UniqueColumns and constraints list in model Meta to build unique constraints on list of columns. Added UUID field type based on Char(32) column type. 0.3.5 Added bulk_create and bulk_update for operations on multiple objects. 0.3.4 Add queryset level methods * delete * update * get_or_create * update_or_create 0.3.3 Add additional filters - startswith and endswith 0.3.2 Add choices parameter to all fields - limiting the accepted values to ones provided 0.3.1 Added exclude to filter where not conditions. Added tests for mysql and postgres with fixes for postgres. Rafactors and cleanup. 0.3.0 Added ManyToMany field and support for many to many relations","title":"Release Notes"},{"location":"releases/#081","text":"","title":"0.8.1"},{"location":"releases/#features","text":"Introduce processing of ForwardRef in relations. Now you can create self-referencing models - both ForeignKey and ManyToMany relations. ForwardRef can be used both for to and through Models . Introduce the possibility to perform two same relation joins in one query, so to process complex relations like: 1 2 3 4 5 6 7 B = X = Y // A \\ C = X = Y <= before you could link from X to Y only once in one query unless two different relation were used (two relation fields with different names) Introduce the paginate method that allows to limit/offset by page and page_size . Available for QuerySet and QuerysetProxy .","title":"Features"},{"location":"releases/#other","text":"Refactoring and performance optimization in queries and joins. Add python 3.9 to tests and pypi setup. Update API docs and docs -> i.e. split of queries documentation.","title":"Other"},{"location":"releases/#080","text":"","title":"0.8.0"},{"location":"releases/#breaking","text":"Breaking: remove() parent from child side in reverse ForeignKey relation now requires passing a relation name , as the same model can be registered multiple times and ormar needs to know from which relation on the parent you want to remove the child. Breaking: applying limit and offset with select_related is by default applied only on the main table before the join -> meaning that not the total number of rows is limited but just number of main models (first one in the query, the one used to construct it). You can still limit all rows from db response with limit_raw_sql=True flag on either limit or offset (or both) Breaking: issuing first() now fetches the first row ordered by the primary key asc (so first one inserted (can be different for non number primary keys - i.e. alphabetical order of string)) Breaking: issuing get() without any filters now fetches the first row ordered by the primary key desc (so should be last one inserted (can be different for non number primary keys - i.e. alphabetical order of string)) Breaking (internal): sqlalchemy columns kept at Meta.columns are no longer bind to table, so you cannot get the column straight from there","title":"Breaking"},{"location":"releases/#features_1","text":"Introduce inheritance . For now two types of inheritance are possible: Mixins - don't subclass ormar.Model , just define fields that are later used on different models (like created_date and updated_date on each child model), only actual models create tables, but those fields from mixins are added Concrete table inheritance - means that parent is marked as abstract=True in Meta class and each child has its own table with columns from the parent and own child columns, kind of similar to Mixins but parent also is a (an abstract) Model To read more check the docs on models -> inheritance section. QuerySet first() can be used with prefetch_related","title":"Features"},{"location":"releases/#fixes","text":"Fix minor bug in order_by for primary model order bys Fix in prefetch_query for multiple related_names for the same model. Fix using same related_name on different models leading to the same related Model overwriting each other, now ModelDefinitionError is raised and you need to change the name. Fix order_by overwriting conditions when multiple joins to the same table applied.","title":"Fixes"},{"location":"releases/#docs","text":"Split and cleanup in docs: Divide models section into subsections Divide relations section into subsections Divide fields section into subsections Add model inheritance section Add API (BETA) documentation","title":"Docs"},{"location":"releases/#075","text":"Fix for wrong relation column name in many_to_many relation joins (fix #73 )","title":"0.7.5"},{"location":"releases/#074","text":"Allow multiple relations to the same related model/table. Fix for wrong relation column used in many_to_many relation joins (fix #73 ) Fix for wrong relation population for m2m relations when also fk relation present for same model. Add check if user provide related_name if there are multiple relations to same table on one model. More eager cleaning of the dead weak proxy models.","title":"0.7.4"},{"location":"releases/#073","text":"Fix for setting fetching related model with UUDI pk, which is a string in raw (fix #71 )","title":"0.7.3"},{"location":"releases/#072","text":"Fix for overwriting related models with pk only in Model.update() with fields passed as parameters (fix #70 )","title":"0.7.2"},{"location":"releases/#071","text":"Fix for overwriting related models with pk only in Model.save() (fix #68 )","title":"0.7.1"},{"location":"releases/#070","text":"Breaking: QuerySet bulk_update method now raises ModelPersistenceError for unsaved models passed instead of QueryDefinitionError Breaking: Model initialization with unknown field name now raises ModelError instead of KeyError Added Signals , with pre-defined list signals and decorators: post_delete , post_save , post_update , pre_delete , pre_save , pre_update Add py.typed and modify setup.py for mypy support Performance optimization Updated docs","title":"0.7.0"},{"location":"releases/#062","text":"Performance optimization Fix for bug with pydantic_only fields being required Add property_field decorator that registers a function as a property that will be included in Model.dict() and in fastapi response Update docs","title":"0.6.2"},{"location":"releases/#061","text":"Explicitly set None to excluded nullable fields to avoid pydantic setting a default value (fix #60 ).","title":"0.6.1"},{"location":"releases/#060","text":"Breaking: calling instance.load() when the instance row was deleted from db now raises NoMatch instead of ValueError Breaking: calling add and remove on ReverseForeignKey relation now updates the child model in db setting/removing fk column Breaking: ReverseForeignKey relation now exposes QuerySetProxy API like ManyToMany relation Breaking: querying related models from ManyToMany cleans list of related models loaded on parent model: Example: post.categories.first() will set post.categories to list of 1 related model -> the one returned by first() Example 2: if post has 4 categories so len(post.categories) == 4 calling post.categories.limit(2).all() -> will load only 2 children and now assert len(post.categories) == 2 Added get_or_create , update_or_create , fields , exclude_fields , exclude , prefetch_related and order_by to QuerySetProxy so now you can use those methods directly from relation Update docs","title":"0.6.0"},{"location":"releases/#055","text":"Fix for alembic autogenaration of migration UUID columns. It should just produce sqlalchemy CHAR(32) or CHAR(36) In order for this to work you have to set user_module_prefix='sa.' (must be equal to sqlalchemy_module_prefix option (default 'sa.'))","title":"0.5.5"},{"location":"releases/#054","text":"Allow to pass uuid_format (allowed 'hex'(default) or 'string') to UUID field to change the format in which it's saved. By default field is saved in hex format (trimmed to 32 chars (without dashes)), but you can pass format='string' to use 36 (with dashes) instead to adjust to existing db or other libraries. Sample: * hex value = c616ab438cce49dbbf4380d109251dce * string value = c616ab43-8cce-49db-bf43-80d109251dce","title":"0.5.4"},{"location":"releases/#053","text":"Fixed bug in Model.dict() method that was ignoring exclude parameter and not include dictionary argument.","title":"0.5.3"},{"location":"releases/#052","text":"Added prefetch_related method to load subsequent models in separate queries. Update docs","title":"0.5.2"},{"location":"releases/#051","text":"Switched to github actions instead of travis Update badges in the docs","title":"0.5.1"},{"location":"releases/#050","text":"Added save status -> you can check if model is saved with ModelInstance.saved property Model is saved after save/update/load/upsert method on model Model is saved after create/get/first/all/get_or_create/update_or_create method Model is saved when passed to bulk_update and bulk_create Model is saved after adding/removing ManyToMany related objects (through model instance auto saved/deleted) Model is not saved after change of any own field (including pk as Model.pk alias) Model is not saved after adding/removing ForeignKey related object (fk column not saved) Model is not saved after instantation with __init__ (w/o QuerySet.create or before calling save ) Added Model.upsert(**kwargs) that performs save() if pk not set otherwise update(**kwargs) Added Model.save_related(follow=False) that iterates all related objects in all relations and checks if they are saved. If not it calls upsert() on each of them. Breaking: added raising exceptions if add -ing/ remove -ing not saved (pk is None) models to ManyToMany relation Allow passing dictionaries and sets to fields and exclude_fields Auto translate str and lists to dicts for fields and exclude_fields Breaking: passing nested models to fields and exclude_fields is now by related ForeignKey name and not by target model name Performance optimizations - in modelproxy, newbasemodel - > less queries, some properties are cached on models Cleanup of unused relations code Optional performance dependency orjson added ( strongly recommended ) Updated docs","title":"0.5.0"},{"location":"releases/#044","text":"add exclude_fields() method to exclude fields from sql refactor column names setting (aliases) fix ordering by for column with aliases additional tests for fields and exclude_fields update docs","title":"0.4.4"},{"location":"releases/#043","text":"include properties in models.dict() and model.json()","title":"0.4.3"},{"location":"releases/#042","text":"modify creation of pydantic models to allow returning related models with only pk populated","title":"0.4.2"},{"location":"releases/#041","text":"add order_by method to queryset to allow sorting update docs","title":"0.4.1"},{"location":"releases/#040","text":"Changed notation in Model definition -> now use name = ormar.Field() not name: ormar.Field() Note that old notation is still supported but deprecated and will not play nice with static checkers like mypy and pydantic pycharm plugin Type hint docs and test Use mypy for tests also not, only ormar package Fix scale and precision translation with max_digits and decimal_places pydantic Decimal field Update docs - add best practices for dependencies Refactor metaclass and model_fields to play nice with type hints Add mypy and pydantic plugin to docs Expand the docs on ManyToMany relation","title":"0.4.0"},{"location":"releases/#0311","text":"Fix setting server_default as default field value in python","title":"0.3.11"},{"location":"releases/#0310","text":"Fix postgresql check to avoid exceptions with drivers not installed if using different backend","title":"0.3.10"},{"location":"releases/#039","text":"Fix json schema generation as of #19 Fix for not initialized ManyToMany relations in fastapi copies of ormar.Models Update docs in regard of fastapi use Add tests to verify fastapi/docs proper generation","title":"0.3.9"},{"location":"releases/#038","text":"Added possibility to provide alternative database column names with name parameter to all fields. Fix bug with selecting related ManyToMany fields with fields() if they are empty. Updated documentation","title":"0.3.8"},{"location":"releases/#037","text":"Publish documentation and update readme","title":"0.3.7"},{"location":"releases/#036","text":"Add fields() method to limit the selected columns from database - only nullable columns can be excluded. Added UniqueColumns and constraints list in model Meta to build unique constraints on list of columns. Added UUID field type based on Char(32) column type.","title":"0.3.6"},{"location":"releases/#035","text":"Added bulk_create and bulk_update for operations on multiple objects.","title":"0.3.5"},{"location":"releases/#034","text":"Add queryset level methods * delete * update * get_or_create * update_or_create","title":"0.3.4"},{"location":"releases/#033","text":"Add additional filters - startswith and endswith","title":"0.3.3"},{"location":"releases/#032","text":"Add choices parameter to all fields - limiting the accepted values to ones provided","title":"0.3.2"},{"location":"releases/#031","text":"Added exclude to filter where not conditions. Added tests for mysql and postgres with fixes for postgres. Rafactors and cleanup.","title":"0.3.1"},{"location":"releases/#030","text":"Added ManyToMany field and support for many to many relations","title":"0.3.0"},{"location":"signals/","text":"Signals Signals are a mechanism to fire your piece of code (function / method) whenever given type of event happens in ormar . To achieve this you need to register your receiver for a given type of signal for selected model(s). Defining receivers Given a sample model like following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) play_count : int = ormar . Integer ( default = 0 ) You can for example define a trigger that will set album.is_best_seller status if it will be played more than 50 times. Import pre_update decorator, for list of currently available decorators/ signals check below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller Define your function. Note that each receiver function: has to be callable has to accept first sender argument that receives the class of sending object has to accept **kwargs argument as the parameters send in each ormar.Signal can change at any time so your function has to serve them. has to be async cause callbacks are gathered and awaited. pre_update currently sends only one argument apart from sender and it's instance one. Note how pre_update decorator accepts a senders argument that can be a single model or a list of models, for which you want to run the signal receiver. Currently there is no way to set signal for all models at once without explicitly passing them all into registration of receiver. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller Note Note that receivers are defined on a class level -> so even if you connect/disconnect function through instance it will run/ stop running for all operations on that ormar.Model class. Note that our newly created function has instance and class of the instance so you can easily run database queries inside your receivers if you want to. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller You can define same receiver for multiple models at once by passing a list of models to signal decorator. 1 2 3 4 # define a dummy debug function @pre_update ([ Album , Track ]) async def before_update ( sender , instance , ** kwargs ): print ( f \" { sender . get_name () } : { instance . json () } : { kwargs } \" ) Of course you can also create multiple functions for the same signal and model. Each of them will run at each signal. 1 2 3 4 5 6 7 @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): print ( f \" { sender . get_name () } : { instance . json () } : { kwargs } \" ) @pre_update ( Album ) async def before_update2 ( sender , instance , ** kwargs ): print ( f 'About to update { sender . get_name () } with pk: { instance . pk } ' ) Note that ormar decorators are the syntactic sugar, you can directly connect your function or method for given signal for given model. Connect accept only one parameter - your receiver function / method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class AlbumAuditor : def __init__ ( self ): self . event_type = \"ALBUM_INSTANCE\" async def before_save ( self , sender , instance , ** kwargs ): await AuditLog ( event_type = f \" { self . event_type } _SAVE\" , event_log = instance . json () ) . save () auditor = AlbumAuditor () pre_save ( Album )( auditor . before_save ) # call above has same result like the one below Album . Meta . signals . pre_save . connect ( auditor . before_save ) # signals are also exposed on instance album = Album ( name = 'Miami' ) album . signals . pre_save . connect ( auditor . before_save ) Warning Note that signals keep the reference to your receiver (not a weakref ) so keep that in mind to avoid circular references. Disconnecting the receivers To disconnect the receiver and stop it for running for given model you need to disconnect it. 1 2 3 4 5 6 7 8 9 10 @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # disconnect given function from signal for given Model Album . Meta . signals . pre_save . disconnect ( before_save ) # signals are also exposed on instance album = Album ( name = 'Miami' ) album . signals . pre_save . disconnect ( before_save ) Available signals Warning Note that signals are not send for: bulk operations ( QuerySet.bulk_create and QuerySet.bulk_update ) as they are designed for speed. queyset table level operations ( QuerySet.update and QuerySet.delete ) as they run on the underlying tables (more lak raw sql update/delete operations) and do not have specific instance. pre_save pre_save(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model to be saved. post_save post_save(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model that was saved. pre_update pre_update(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model to be updated. post_update post_update(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model that was updated. pre_delete pre_delete(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model to be deleted. post_delete post_delete(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model that was deleted. Defining your own signals Note that you can create your own signals although you will have to send them manually in your code or subclass ormar.Model and trigger your signals there. Creating new signal is super easy. Following example will set a new signal with name your_custom_signal. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) play_count : int = ormar . Integer ( default = 0 ) Album . Meta . signals . your_custom_signal = ormar . Signal () Album . Meta . signals . your_custom_signal . connect ( your_receiver_name ) Actually under the hood signal is a SignalEmitter instance that keeps a dictionary of know signals, and allows you to access them as attributes. When you try to access a signal that does not exist SignalEmitter will create one for you. So example above can be simplified to. The Signal will be created for you. 1 Album.Meta.signals.your_custom_signal.connect(your_receiver_name) Now to trigger this signal you need to call send method of the Signal. 1 await Album . Meta . signals . your_custom_signal . send ( sender = Album ) Note that sender is the only required parameter and it should be ormar Model class. Additional parameters have to be passed as keyword arguments. 1 await Album . Meta . signals . your_custom_signal . send ( sender = Album , my_param = True )","title":"Signals"},{"location":"signals/#signals","text":"Signals are a mechanism to fire your piece of code (function / method) whenever given type of event happens in ormar . To achieve this you need to register your receiver for a given type of signal for selected model(s).","title":"Signals"},{"location":"signals/#defining-receivers","text":"Given a sample model like following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) play_count : int = ormar . Integer ( default = 0 ) You can for example define a trigger that will set album.is_best_seller status if it will be played more than 50 times. Import pre_update decorator, for list of currently available decorators/ signals check below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller Define your function. Note that each receiver function: has to be callable has to accept first sender argument that receives the class of sending object has to accept **kwargs argument as the parameters send in each ormar.Signal can change at any time so your function has to serve them. has to be async cause callbacks are gathered and awaited. pre_update currently sends only one argument apart from sender and it's instance one. Note how pre_update decorator accepts a senders argument that can be a single model or a list of models, for which you want to run the signal receiver. Currently there is no way to set signal for all models at once without explicitly passing them all into registration of receiver. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller Note Note that receivers are defined on a class level -> so even if you connect/disconnect function through instance it will run/ stop running for all operations on that ormar.Model class. Note that our newly created function has instance and class of the instance so you can easily run database queries inside your receivers if you want to. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller You can define same receiver for multiple models at once by passing a list of models to signal decorator. 1 2 3 4 # define a dummy debug function @pre_update ([ Album , Track ]) async def before_update ( sender , instance , ** kwargs ): print ( f \" { sender . get_name () } : { instance . json () } : { kwargs } \" ) Of course you can also create multiple functions for the same signal and model. Each of them will run at each signal. 1 2 3 4 5 6 7 @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): print ( f \" { sender . get_name () } : { instance . json () } : { kwargs } \" ) @pre_update ( Album ) async def before_update2 ( sender , instance , ** kwargs ): print ( f 'About to update { sender . get_name () } with pk: { instance . pk } ' ) Note that ormar decorators are the syntactic sugar, you can directly connect your function or method for given signal for given model. Connect accept only one parameter - your receiver function / method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class AlbumAuditor : def __init__ ( self ): self . event_type = \"ALBUM_INSTANCE\" async def before_save ( self , sender , instance , ** kwargs ): await AuditLog ( event_type = f \" { self . event_type } _SAVE\" , event_log = instance . json () ) . save () auditor = AlbumAuditor () pre_save ( Album )( auditor . before_save ) # call above has same result like the one below Album . Meta . signals . pre_save . connect ( auditor . before_save ) # signals are also exposed on instance album = Album ( name = 'Miami' ) album . signals . pre_save . connect ( auditor . before_save ) Warning Note that signals keep the reference to your receiver (not a weakref ) so keep that in mind to avoid circular references.","title":"Defining receivers"},{"location":"signals/#disconnecting-the-receivers","text":"To disconnect the receiver and stop it for running for given model you need to disconnect it. 1 2 3 4 5 6 7 8 9 10 @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # disconnect given function from signal for given Model Album . Meta . signals . pre_save . disconnect ( before_save ) # signals are also exposed on instance album = Album ( name = 'Miami' ) album . signals . pre_save . disconnect ( before_save )","title":"Disconnecting the receivers"},{"location":"signals/#available-signals","text":"Warning Note that signals are not send for: bulk operations ( QuerySet.bulk_create and QuerySet.bulk_update ) as they are designed for speed. queyset table level operations ( QuerySet.update and QuerySet.delete ) as they run on the underlying tables (more lak raw sql update/delete operations) and do not have specific instance.","title":"Available signals"},{"location":"signals/#pre_save","text":"pre_save(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model to be saved.","title":"pre_save"},{"location":"signals/#post_save","text":"post_save(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model that was saved.","title":"post_save"},{"location":"signals/#pre_update","text":"pre_update(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model to be updated.","title":"pre_update"},{"location":"signals/#post_update","text":"post_update(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model that was updated.","title":"post_update"},{"location":"signals/#pre_delete","text":"pre_delete(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model to be deleted.","title":"pre_delete"},{"location":"signals/#post_delete","text":"post_delete(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model that was deleted.","title":"post_delete"},{"location":"signals/#defining-your-own-signals","text":"Note that you can create your own signals although you will have to send them manually in your code or subclass ormar.Model and trigger your signals there. Creating new signal is super easy. Following example will set a new signal with name your_custom_signal. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) play_count : int = ormar . Integer ( default = 0 ) Album . Meta . signals . your_custom_signal = ormar . Signal () Album . Meta . signals . your_custom_signal . connect ( your_receiver_name ) Actually under the hood signal is a SignalEmitter instance that keeps a dictionary of know signals, and allows you to access them as attributes. When you try to access a signal that does not exist SignalEmitter will create one for you. So example above can be simplified to. The Signal will be created for you. 1 Album.Meta.signals.your_custom_signal.connect(your_receiver_name) Now to trigger this signal you need to call send method of the Signal. 1 await Album . Meta . signals . your_custom_signal . send ( sender = Album ) Note that sender is the only required parameter and it should be ormar Model class. Additional parameters have to be passed as keyword arguments. 1 await Album . Meta . signals . your_custom_signal . send ( sender = Album , my_param = True )","title":"Defining your own signals"},{"location":"api/","text":"Contains documentation of the ormar internal API. Note that this is a technical part of the documentation intended for ormar contributors. Note For completeness as of now even the internal and special methods are documented and exposed in API docs. Warning The current API docs version is a beta and not all methods are documented, also some of redundant items are included since it was partially auto generated. Danger Ormar is still under development, and the internals can change at any moment . You shouldn't rely even on the \"public\" methods if they are not documented in the normal part of the docs. High level overview Ormar is divided into packages for maintainability and ease of development. Below you can find a short description of the structure of the whole project and individual packages. Models Contains the actual ormar.Model class, which is based on: ormar.NewBaseModel which in turns: inherits from pydantic.BaseModel , uses ormar.ModelMetaclass for all heavy lifting, relations declaration, parsing ormar fields, creating sqlalchemy columns and tables etc. There is a lot of tasks during class creation so ormar is using a lot of helpers methods separated by functionality: pydantic , sqlachemy , relations & models located in helpers submodule. inherits from ormar.ModelTableProxy that combines Mixins providing a special additional behavior for ormar.Models AliasMixin - handling of column aliases, which are names changed only in db ExcludableMixin - handling excluding and including fields in dict() and database calls MergeModelMixin - handling merging Models initialized from raw sql raws into Models that needs to be merged, in example parent models in join query that duplicates in raw response. PrefetchQueryMixin - handling resolving relations and ids of models to extract during issuing subsequent queries in prefetch_related RelationMixin - handling resolving relations names, related fields etc. SavePrepareMixin - handling converting related models to their pk values, translating ormar field names into aliases etc. Fields Contains ormar.BaseField that is a base for all fields. All basic types are declared in model_fields , while relation fields are located in: foreign_key : ForeignKey relation, expanding relations meaning initializing nested models, creating dummy models with pk only that skips validation etc. many_to_many : ManyToMany relation that do not have a lot of logic on its own. Related to fields is a @property_field decorator that is located in decorators.property_field . There is also a special UUID field declaration for sqlalchemy that is based on CHAR field type. Query Set Package that handles almost all interactions with db (some small parts are in ormar.Model and in ormar.QuerysetProxy ). Provides a QuerySet that is exposed on each Model as objects property. Have a vast number of methods to query, filter, create, update and delete database rows. Actual construction of the queries is delegated to Query class which in tern uses SqlJoin to construct joins Clause to convert filter and exclude conditions into sql FilterQuery to apply filter clauses on query OrderQuery to apply order by clauses on query LimitQuery to apply limit clause on query OffsetQuery to apply offset clause on query For prefetch_related the same is done by PrefetchQuery Common helpers functions are extracted into utils Relations Handles registering relations, adding/removing to relations as well as returning the actual related models instead of relation fields declared on Models. Each ormar.Model has its own RelationManager registered under _orm property. RelationManager handles Relations between two different models In case of reverse relations or m2m relations the RelationProxy is used which is basically a list with some special methods that keeps a reference to a list of related models Also, for reverse relations and m2m relations QuerySetProxy is exposed, that is used to query the already pre-filtered related models and handles Through models instances for m2m relations, while delegating actual queries to QuerySet AliasManager handles registration of aliases for relations that are used in queries. In order to be able to link multiple times to the same table in one query each link has to have unique alias to properly identify columns and extract proper values. Kind of global registry, aliases are randomly generated, so might differ on each run. Common helpers functions are extracted into utils Signals Handles sending signals on particular events. SignalEmitter is registered on each ormar.Model , that allows to register any number of receiver functions that will be notified on each event. For now only combination of (pre, post) (save, update, delete) events are pre populated for user although it's easy to register user Signal s. set of decorators is prepared, each corresponding to one of the builtin signals, that can be used to mark functions/methods that should become receivers, those decorators are located in decorators.signals . You can register same function to different ormar.Models but each Model has it's own Emitter that is independednt and issued on events for given Model. Currently, there is no way to register global Signal triggered for all models. Exceptions Gathers all exceptions specific to ormar . All ormar exceptions inherit from AsyncOrmException .","title":"Index"},{"location":"api/#high-level-overview","text":"Ormar is divided into packages for maintainability and ease of development. Below you can find a short description of the structure of the whole project and individual packages.","title":"High level overview"},{"location":"api/#models","text":"Contains the actual ormar.Model class, which is based on: ormar.NewBaseModel which in turns: inherits from pydantic.BaseModel , uses ormar.ModelMetaclass for all heavy lifting, relations declaration, parsing ormar fields, creating sqlalchemy columns and tables etc. There is a lot of tasks during class creation so ormar is using a lot of helpers methods separated by functionality: pydantic , sqlachemy , relations & models located in helpers submodule. inherits from ormar.ModelTableProxy that combines Mixins providing a special additional behavior for ormar.Models AliasMixin - handling of column aliases, which are names changed only in db ExcludableMixin - handling excluding and including fields in dict() and database calls MergeModelMixin - handling merging Models initialized from raw sql raws into Models that needs to be merged, in example parent models in join query that duplicates in raw response. PrefetchQueryMixin - handling resolving relations and ids of models to extract during issuing subsequent queries in prefetch_related RelationMixin - handling resolving relations names, related fields etc. SavePrepareMixin - handling converting related models to their pk values, translating ormar field names into aliases etc.","title":"Models"},{"location":"api/#fields","text":"Contains ormar.BaseField that is a base for all fields. All basic types are declared in model_fields , while relation fields are located in: foreign_key : ForeignKey relation, expanding relations meaning initializing nested models, creating dummy models with pk only that skips validation etc. many_to_many : ManyToMany relation that do not have a lot of logic on its own. Related to fields is a @property_field decorator that is located in decorators.property_field . There is also a special UUID field declaration for sqlalchemy that is based on CHAR field type.","title":"Fields"},{"location":"api/#query-set","text":"Package that handles almost all interactions with db (some small parts are in ormar.Model and in ormar.QuerysetProxy ). Provides a QuerySet that is exposed on each Model as objects property. Have a vast number of methods to query, filter, create, update and delete database rows. Actual construction of the queries is delegated to Query class which in tern uses SqlJoin to construct joins Clause to convert filter and exclude conditions into sql FilterQuery to apply filter clauses on query OrderQuery to apply order by clauses on query LimitQuery to apply limit clause on query OffsetQuery to apply offset clause on query For prefetch_related the same is done by PrefetchQuery Common helpers functions are extracted into utils","title":"Query Set"},{"location":"api/#relations","text":"Handles registering relations, adding/removing to relations as well as returning the actual related models instead of relation fields declared on Models. Each ormar.Model has its own RelationManager registered under _orm property. RelationManager handles Relations between two different models In case of reverse relations or m2m relations the RelationProxy is used which is basically a list with some special methods that keeps a reference to a list of related models Also, for reverse relations and m2m relations QuerySetProxy is exposed, that is used to query the already pre-filtered related models and handles Through models instances for m2m relations, while delegating actual queries to QuerySet AliasManager handles registration of aliases for relations that are used in queries. In order to be able to link multiple times to the same table in one query each link has to have unique alias to properly identify columns and extract proper values. Kind of global registry, aliases are randomly generated, so might differ on each run. Common helpers functions are extracted into utils","title":"Relations"},{"location":"api/#signals","text":"Handles sending signals on particular events. SignalEmitter is registered on each ormar.Model , that allows to register any number of receiver functions that will be notified on each event. For now only combination of (pre, post) (save, update, delete) events are pre populated for user although it's easy to register user Signal s. set of decorators is prepared, each corresponding to one of the builtin signals, that can be used to mark functions/methods that should become receivers, those decorators are located in decorators.signals . You can register same function to different ormar.Models but each Model has it's own Emitter that is independednt and issued on events for given Model. Currently, there is no way to register global Signal triggered for all models.","title":"Signals"},{"location":"api/#exceptions","text":"Gathers all exceptions specific to ormar . All ormar exceptions inherit from AsyncOrmException .","title":"Exceptions"},{"location":"api/exceptions/","text":"exceptions Gathers all exceptions thrown by ormar. AsyncOrmException Objects 1 class AsyncOrmException ( Exception ) Base ormar Exception ModelDefinitionError Objects 1 class ModelDefinitionError ( AsyncOrmException ) Raised for errors related to the model definition itself: setting @property_field on method with arguments other than func(self) defining a Field without required parameters defining a model with more than one primary_key defining a model without primary_key setting primary_key column as pydantic_only ModelError Objects 1 class ModelError ( AsyncOrmException ) Raised for initialization of model with non-existing field keyword. NoMatch Objects 1 class NoMatch ( AsyncOrmException ) Raised for database queries that has no matching result (empty result). MultipleMatches Objects 1 class MultipleMatches ( AsyncOrmException ) Raised for database queries that should return one row (i.e. get, first etc.) but has multiple matching results in response. QueryDefinitionError Objects 1 class QueryDefinitionError ( AsyncOrmException ) Raised for errors in query definition: using contains or icontains filter with instance of the Model using Queryset.update() without filter and setting each flag to True using Queryset.delete() without filter and setting each flag to True ModelPersistenceError Objects 1 class ModelPersistenceError ( AsyncOrmException ) Raised for update of models without primary_key set (cannot retrieve from db) or for saving a model with relation to unsaved model (cannot extract fk value). SignalDefinitionError Objects 1 class SignalDefinitionError ( AsyncOrmException ) Raised when non callable receiver is passed as signal callback.","title":"Exceptions"},{"location":"api/exceptions/#exceptions","text":"Gathers all exceptions thrown by ormar.","title":"exceptions"},{"location":"api/exceptions/#asyncormexception-objects","text":"1 class AsyncOrmException ( Exception ) Base ormar Exception","title":"AsyncOrmException Objects"},{"location":"api/exceptions/#modeldefinitionerror-objects","text":"1 class ModelDefinitionError ( AsyncOrmException ) Raised for errors related to the model definition itself: setting @property_field on method with arguments other than func(self) defining a Field without required parameters defining a model with more than one primary_key defining a model without primary_key setting primary_key column as pydantic_only","title":"ModelDefinitionError Objects"},{"location":"api/exceptions/#modelerror-objects","text":"1 class ModelError ( AsyncOrmException ) Raised for initialization of model with non-existing field keyword.","title":"ModelError Objects"},{"location":"api/exceptions/#nomatch-objects","text":"1 class NoMatch ( AsyncOrmException ) Raised for database queries that has no matching result (empty result).","title":"NoMatch Objects"},{"location":"api/exceptions/#multiplematches-objects","text":"1 class MultipleMatches ( AsyncOrmException ) Raised for database queries that should return one row (i.e. get, first etc.) but has multiple matching results in response.","title":"MultipleMatches Objects"},{"location":"api/exceptions/#querydefinitionerror-objects","text":"1 class QueryDefinitionError ( AsyncOrmException ) Raised for errors in query definition: using contains or icontains filter with instance of the Model using Queryset.update() without filter and setting each flag to True using Queryset.delete() without filter and setting each flag to True","title":"QueryDefinitionError Objects"},{"location":"api/exceptions/#modelpersistenceerror-objects","text":"1 class ModelPersistenceError ( AsyncOrmException ) Raised for update of models without primary_key set (cannot retrieve from db) or for saving a model with relation to unsaved model (cannot extract fk value).","title":"ModelPersistenceError Objects"},{"location":"api/exceptions/#signaldefinitionerror-objects","text":"1 class SignalDefinitionError ( AsyncOrmException ) Raised when non callable receiver is passed as signal callback.","title":"SignalDefinitionError Objects"},{"location":"api/fields/base-field/","text":"fields.base BaseField Objects 1 class BaseField ( FieldInfo ) BaseField serves as a parent class for all basic Fields in ormar. It keeps all common parameters available for all fields as well as set of useful functions. All values are kept as class variables, ormar Fields are never instantiated. Subclasses pydantic.FieldInfo to keep the fields related to pydantic field types like ConstrainedStr is_valid_uni_relation 1 2 | @classmethod | is_valid_uni_relation ( cls ) -> bool Checks if field is a relation definition but only for ForeignKey relation, so excludes ManyToMany fields, as well as virtual ForeignKey (second side of FK relation). Is used to define if a field is a db ForeignKey column that should be saved/populated when dealing with internal/own Model columns only. Returns : (bool) : result of the check get_alias 1 2 | @classmethod | get_alias ( cls ) -> str Used to translate Model column names to database column names during db queries. Returns : (str) : returns custom database column name if defined by user, otherwise field name in ormar/pydantic is_valid_field_info_field 1 2 | @classmethod | is_valid_field_info_field ( cls , field_name : str ) -> bool Checks if field belongs to pydantic FieldInfo - used during setting default pydantic values. Excludes defaults and alias as they are populated separately (defaults) or not at all (alias) Arguments : field_name (str) : field name of BaseFIeld Returns : (bool) : True if field is present on pydantic.FieldInfo convert_to_pydantic_field_info 1 2 | @classmethod | convert_to_pydantic_field_info ( cls , allow_null : bool = False ) -> FieldInfo Converts a BaseField into pydantic.FieldInfo that is later easily processed by pydantic. Used in an ormar Model Metaclass. Arguments : allow_null (bool) : flag if the default value can be None or if it should be populated by pydantic Undefined Returns : (pydantic.FieldInfo) : actual instance of pydantic.FieldInfo with all needed fields populated default_value 1 2 | @classmethod | default_value ( cls , use_server : bool = False ) -> Optional [ FieldInfo ] Returns a FieldInfo instance with populated default (static) or default_factory (function). If the field is a autoincrement primary key the default is None. Otherwise field have to has either default, or default_factory populated. If all default conditions fail None is returned. Used in converting to pydantic FieldInfo. Arguments : use_server (bool) : flag marking if server_default should be treated as default value, default False Returns : (Optional[pydantic.FieldInfo]) : returns a call to pydantic.Field which is returning a FieldInfo instance get_default 1 2 | @classmethod | get_default ( cls , use_server : bool = False ) -> Any Return default value for a field. If the field is Callable the function is called and actual result is returned. Used to populate default_values for pydantic Model in ormar Model Metaclass. Arguments : use_server (bool) : flag marking if server_default should be treated as default value, default False Returns : (Any) : default value for the field if set, otherwise implicit None has_default 1 2 | @classmethod | has_default ( cls , use_server : bool = True ) -> bool Checks if the field has default value set. Arguments : use_server (bool) : flag marking if server_default should be treated as default value, default False Returns : (bool) : result of the check if default value is set is_auto_primary_key 1 2 | @classmethod | is_auto_primary_key ( cls ) -> bool Checks if field is first a primary key and if it, it's than check if it's set to autoincrement. Autoincrement primary_key is nullable/optional. Returns : (bool) : result of the check for primary key and autoincrement construct_constraints 1 2 | @classmethod | construct_constraints ( cls ) -> List Converts list of ormar constraints into sqlalchemy ForeignKeys. Has to be done dynamically as sqlalchemy binds ForeignKey to the table. And we need a new ForeignKey for subclasses of current model Returns : (List[sqlalchemy.schema.ForeignKey]) : List of sqlalchemy foreign keys - by default one. get_column 1 2 | @classmethod | get_column ( cls , name : str ) -> sqlalchemy . Column Returns definition of sqlalchemy.Column used in creation of sqlalchemy.Table. Populates name, column type constraints, as well as a number of parameters like primary_key, index, unique, nullable, default and server_default. Arguments : name (str) : name of the db column - used if alias is not set Returns : (sqlalchemy.Column) : actual definition of the database column as sqlalchemy requires. expand_relationship 1 2 | @classmethod | expand_relationship ( cls , value : Any , child : Union [ \"Model\" , \"NewBaseModel\" ], to_register : bool = True ) -> Any Function overwritten for relations, in basic field the value is returned as is. For relations the child model is first constructed (if needed), registered in relation and returned. For relation fields the value can be a pk value (Any type of field), dict (from Model) or actual instance/list of a \"Model\". Arguments : value (Any) : a Model field value, returned untouched for non relation fields. child (Union[\"Model\", \"NewBaseModel\"]) : a child Model to register to_register (bool) : flag if the relation should be set in RelationshipManager Returns : (Any) : returns untouched value for normal fields, expands only for relations set_self_reference_flag 1 2 | @classmethod | set_self_reference_flag ( cls ) -> None Sets self_reference to True if field to and owner are same model. Returns : (None) : None has_unresolved_forward_refs 1 2 | @classmethod | has_unresolved_forward_refs ( cls ) -> bool Verifies if the filed has any ForwardRefs that require updating before the model can be used. Returns : (bool) : result of the check evaluate_forward_ref 1 2 | @classmethod | evaluate_forward_ref ( cls , globalns : Any , localns : Any ) -> None Evaluates the ForwardRef to actual Field based on global and local namespaces Arguments : globalns (Any) : global namespace localns (Any) : local namespace Returns : (None) : None get_related_name 1 2 | @classmethod | get_related_name ( cls ) -> str Returns name to use for reverse relation. It's either set as related_name or by default it's owner model. get_name + 's' Returns : (str) : name of the related_name or default related name.","title":"Base Field"},{"location":"api/fields/base-field/#fieldsbase","text":"","title":"fields.base"},{"location":"api/fields/base-field/#basefield-objects","text":"1 class BaseField ( FieldInfo ) BaseField serves as a parent class for all basic Fields in ormar. It keeps all common parameters available for all fields as well as set of useful functions. All values are kept as class variables, ormar Fields are never instantiated. Subclasses pydantic.FieldInfo to keep the fields related to pydantic field types like ConstrainedStr","title":"BaseField Objects"},{"location":"api/fields/base-field/#is_valid_uni_relation","text":"1 2 | @classmethod | is_valid_uni_relation ( cls ) -> bool Checks if field is a relation definition but only for ForeignKey relation, so excludes ManyToMany fields, as well as virtual ForeignKey (second side of FK relation). Is used to define if a field is a db ForeignKey column that should be saved/populated when dealing with internal/own Model columns only. Returns : (bool) : result of the check","title":"is_valid_uni_relation"},{"location":"api/fields/base-field/#get_alias","text":"1 2 | @classmethod | get_alias ( cls ) -> str Used to translate Model column names to database column names during db queries. Returns : (str) : returns custom database column name if defined by user, otherwise field name in ormar/pydantic","title":"get_alias"},{"location":"api/fields/base-field/#is_valid_field_info_field","text":"1 2 | @classmethod | is_valid_field_info_field ( cls , field_name : str ) -> bool Checks if field belongs to pydantic FieldInfo - used during setting default pydantic values. Excludes defaults and alias as they are populated separately (defaults) or not at all (alias) Arguments : field_name (str) : field name of BaseFIeld Returns : (bool) : True if field is present on pydantic.FieldInfo","title":"is_valid_field_info_field"},{"location":"api/fields/base-field/#convert_to_pydantic_field_info","text":"1 2 | @classmethod | convert_to_pydantic_field_info ( cls , allow_null : bool = False ) -> FieldInfo Converts a BaseField into pydantic.FieldInfo that is later easily processed by pydantic. Used in an ormar Model Metaclass. Arguments : allow_null (bool) : flag if the default value can be None or if it should be populated by pydantic Undefined Returns : (pydantic.FieldInfo) : actual instance of pydantic.FieldInfo with all needed fields populated","title":"convert_to_pydantic_field_info"},{"location":"api/fields/base-field/#default_value","text":"1 2 | @classmethod | default_value ( cls , use_server : bool = False ) -> Optional [ FieldInfo ] Returns a FieldInfo instance with populated default (static) or default_factory (function). If the field is a autoincrement primary key the default is None. Otherwise field have to has either default, or default_factory populated. If all default conditions fail None is returned. Used in converting to pydantic FieldInfo. Arguments : use_server (bool) : flag marking if server_default should be treated as default value, default False Returns : (Optional[pydantic.FieldInfo]) : returns a call to pydantic.Field which is returning a FieldInfo instance","title":"default_value"},{"location":"api/fields/base-field/#get_default","text":"1 2 | @classmethod | get_default ( cls , use_server : bool = False ) -> Any Return default value for a field. If the field is Callable the function is called and actual result is returned. Used to populate default_values for pydantic Model in ormar Model Metaclass. Arguments : use_server (bool) : flag marking if server_default should be treated as default value, default False Returns : (Any) : default value for the field if set, otherwise implicit None","title":"get_default"},{"location":"api/fields/base-field/#has_default","text":"1 2 | @classmethod | has_default ( cls , use_server : bool = True ) -> bool Checks if the field has default value set. Arguments : use_server (bool) : flag marking if server_default should be treated as default value, default False Returns : (bool) : result of the check if default value is set","title":"has_default"},{"location":"api/fields/base-field/#is_auto_primary_key","text":"1 2 | @classmethod | is_auto_primary_key ( cls ) -> bool Checks if field is first a primary key and if it, it's than check if it's set to autoincrement. Autoincrement primary_key is nullable/optional. Returns : (bool) : result of the check for primary key and autoincrement","title":"is_auto_primary_key"},{"location":"api/fields/base-field/#construct_constraints","text":"1 2 | @classmethod | construct_constraints ( cls ) -> List Converts list of ormar constraints into sqlalchemy ForeignKeys. Has to be done dynamically as sqlalchemy binds ForeignKey to the table. And we need a new ForeignKey for subclasses of current model Returns : (List[sqlalchemy.schema.ForeignKey]) : List of sqlalchemy foreign keys - by default one.","title":"construct_constraints"},{"location":"api/fields/base-field/#get_column","text":"1 2 | @classmethod | get_column ( cls , name : str ) -> sqlalchemy . Column Returns definition of sqlalchemy.Column used in creation of sqlalchemy.Table. Populates name, column type constraints, as well as a number of parameters like primary_key, index, unique, nullable, default and server_default. Arguments : name (str) : name of the db column - used if alias is not set Returns : (sqlalchemy.Column) : actual definition of the database column as sqlalchemy requires.","title":"get_column"},{"location":"api/fields/base-field/#expand_relationship","text":"1 2 | @classmethod | expand_relationship ( cls , value : Any , child : Union [ \"Model\" , \"NewBaseModel\" ], to_register : bool = True ) -> Any Function overwritten for relations, in basic field the value is returned as is. For relations the child model is first constructed (if needed), registered in relation and returned. For relation fields the value can be a pk value (Any type of field), dict (from Model) or actual instance/list of a \"Model\". Arguments : value (Any) : a Model field value, returned untouched for non relation fields. child (Union[\"Model\", \"NewBaseModel\"]) : a child Model to register to_register (bool) : flag if the relation should be set in RelationshipManager Returns : (Any) : returns untouched value for normal fields, expands only for relations","title":"expand_relationship"},{"location":"api/fields/base-field/#set_self_reference_flag","text":"1 2 | @classmethod | set_self_reference_flag ( cls ) -> None Sets self_reference to True if field to and owner are same model. Returns : (None) : None","title":"set_self_reference_flag"},{"location":"api/fields/base-field/#has_unresolved_forward_refs","text":"1 2 | @classmethod | has_unresolved_forward_refs ( cls ) -> bool Verifies if the filed has any ForwardRefs that require updating before the model can be used. Returns : (bool) : result of the check","title":"has_unresolved_forward_refs"},{"location":"api/fields/base-field/#evaluate_forward_ref","text":"1 2 | @classmethod | evaluate_forward_ref ( cls , globalns : Any , localns : Any ) -> None Evaluates the ForwardRef to actual Field based on global and local namespaces Arguments : globalns (Any) : global namespace localns (Any) : local namespace Returns : (None) : None","title":"evaluate_forward_ref"},{"location":"api/fields/base-field/#get_related_name","text":"1 2 | @classmethod | get_related_name ( cls ) -> str Returns name to use for reverse relation. It's either set as related_name or by default it's owner model. get_name + 's' Returns : (str) : name of the related_name or default related name.","title":"get_related_name"},{"location":"api/fields/decorators/","text":"decorators.property_field property_field 1 property_field ( func : Callable ) -> Union [ property , Callable ] Decorator to set a property like function on Model to be exposed as field in dict() and fastapi response. Although you can decorate a @property field like this and this will work, mypy validation will complain about this. Note that \"fields\" exposed like this do not go through validation. Raises : ModelDefinitionError : if method has any other argument than self. Arguments : func (Callable) : decorated function to be exposed Returns : (Union[property, Callable]) : decorated function passed in func param, with set property_field = True","title":"Decorators"},{"location":"api/fields/decorators/#decoratorsproperty_field","text":"","title":"decorators.property_field"},{"location":"api/fields/decorators/#property_field","text":"1 property_field ( func : Callable ) -> Union [ property , Callable ] Decorator to set a property like function on Model to be exposed as field in dict() and fastapi response. Although you can decorate a @property field like this and this will work, mypy validation will complain about this. Note that \"fields\" exposed like this do not go through validation. Raises : ModelDefinitionError : if method has any other argument than self. Arguments : func (Callable) : decorated function to be exposed Returns : (Union[property, Callable]) : decorated function passed in func param, with set property_field = True","title":"property_field"},{"location":"api/fields/foreign-key/","text":"fields.foreign_key create_dummy_instance 1 create_dummy_instance ( fk : Type [ \"Model\" ], pk : Any = None ) -> \"Model\" Ormar never returns you a raw data. So if you have a related field that has a value populated it will construct you a Model instance out of it. Creates a \"fake\" instance of passed Model from pk value. The instantiated Model has only pk value filled. To achieve this pk_only flag has to be passed as it skips the validation. If the nested related Models are required they are set with -1 as pk value. Arguments : fk (Model class) : class of the related Model to which instance should be constructed pk (Any) : value of the primary_key column Returns : (Model) : Model instance populated with only pk create_dummy_model 1 create_dummy_model ( base_model : Type [ \"Model\" ], pk_field : Type [ Union [ BaseField , \"ForeignKeyField\" , \"ManyToManyField\" ]]) -> Type [ \"BaseModel\" ] Used to construct a dummy pydantic model for type hints and pydantic validation. Populates only pk field and set it to desired type. Arguments : base_model (Model class) : class of target dummy model pk_field (Type[Union[BaseField, \"ForeignKeyField\", \"ManyToManyField\"]]) : ormar Field to be set on pydantic Model Returns : (pydantic.BaseModel) : constructed dummy model populate_fk_params_based_on_to_model 1 populate_fk_params_based_on_to_model ( to : Type [ \"Model\" ], nullable : bool , onupdate : str = None , ondelete : str = None ) -> Tuple [ Any , List , Any ] Based on target to model to which relation leads to populates the type of the pydantic field to use, ForeignKey constraint and type of the target column field. Arguments : to (Model class) : target related ormar Model nullable (bool) : marks field as optional/ required onupdate (str) : parameter passed to sqlalchemy.ForeignKey. How to treat child rows on update of parent (the one where FK is defined) model. ondelete (str) : parameter passed to sqlalchemy.ForeignKey. How to treat child rows on delete of parent (the one where FK is defined) model. Returns : (Tuple[Any, List, Any]) : tuple with target pydantic type, list of fk constraints and target col type UniqueColumns Objects 1 class UniqueColumns ( UniqueConstraint ) Subclass of sqlalchemy.UniqueConstraint. Used to avoid importing anything from sqlalchemy by user. ForeignKeyConstraint Objects 1 2 @dataclass class ForeignKeyConstraint () Internal container to store ForeignKey definitions used later to produce sqlalchemy.ForeignKeys ForeignKey 1 ForeignKey ( to : \"ToType\" , * , name : str = None , unique : bool = False , nullable : bool = True , related_name : str = None , virtual : bool = False , onupdate : str = None , ondelete : str = None , ** kwargs : Any , ,) -> Any Despite a name it's a function that returns constructed ForeignKeyField. This function is actually used in model declaration (as ormar.ForeignKey(ToModel)). Accepts number of relation setting parameters as well as all BaseField ones. Arguments : to (Model class) : target related ormar Model name (str) : name of the database field - later called alias unique (bool) : parameter passed to sqlalchemy.ForeignKey, unique flag nullable (bool) : marks field as optional/ required related_name (str) : name of reversed FK relation populated for you on to model virtual (bool) : marks if relation is virtual. It is for reversed FK and auto generated FK on through model in Many2Many relations. onupdate (str) : parameter passed to sqlalchemy.ForeignKey. How to treat child rows on update of parent (the one where FK is defined) model. ondelete (str) : parameter passed to sqlalchemy.ForeignKey. How to treat child rows on delete of parent (the one where FK is defined) model. kwargs (Any) : all other args to be populated by BaseField Returns : (ForeignKeyField) : ormar ForeignKeyField with relation to selected model ForeignKeyField Objects 1 class ForeignKeyField ( BaseField ) Actual class returned from ForeignKey function call and stored in model_fields. get_source_related_name 1 2 | @classmethod | get_source_related_name ( cls ) -> str Returns name to use for source relation name. For FK it's the same, differs for m2m fields. It's either set as related_name or by default it's owner model. get_name + 's' Returns : (str) : name of the related_name or default related name. get_related_name 1 2 | @classmethod | get_related_name ( cls ) -> str Returns name to use for reverse relation. It's either set as related_name or by default it's owner model. get_name + 's' Returns : (str) : name of the related_name or default related name. evaluate_forward_ref 1 2 | @classmethod | evaluate_forward_ref ( cls , globalns : Any , localns : Any ) -> None Evaluates the ForwardRef to actual Field based on global and local namespaces Arguments : globalns (Any) : global namespace localns (Any) : local namespace Returns : (None) : None _extract_model_from_sequence 1 2 | @classmethod | _extract_model_from_sequence ( cls , value : List , child : \"Model\" , to_register : bool ) -> List [ \"Model\" ] Takes a list of Models and registers them on parent. Registration is mutual, so children have also reference to parent. Used in reverse FK relations. Arguments : value (List) : list of Model child (Model) : child/ related Model to_register (bool) : flag if the relation should be set in RelationshipManager Returns : (List[\"Model\"]) : list (if needed) registered Models _register_existing_model 1 2 | @classmethod | _register_existing_model ( cls , value : \"Model\" , child : \"Model\" , to_register : bool ) -> \"Model\" Takes already created instance and registers it for parent. Registration is mutual, so children have also reference to parent. Used in reverse FK relations and normal FK for single models. Arguments : value (Model) : already instantiated Model child (Model) : child/ related Model to_register (bool) : flag if the relation should be set in RelationshipManager Returns : (Model) : (if needed) registered Model _construct_model_from_dict 1 2 | @classmethod | _construct_model_from_dict ( cls , value : dict , child : \"Model\" , to_register : bool ) -> \"Model\" Takes a dictionary, creates a instance and registers it for parent. If dictionary contains only one field and it's a pk it is a pk_only model. Registration is mutual, so children have also reference to parent. Used in normal FK for dictionaries. Arguments : value (dict) : dictionary of a Model child (Model) : child/ related Model to_register (bool) : flag if the relation should be set in RelationshipManager Returns : (Model) : (if needed) registered Model _construct_model_from_pk 1 2 | @classmethod | _construct_model_from_pk ( cls , value : Any , child : \"Model\" , to_register : bool ) -> \"Model\" Takes a pk value, creates a dummy instance and registers it for parent. Registration is mutual, so children have also reference to parent. Used in normal FK for dictionaries. Arguments : value (Any) : value of a related pk / fk column child (Model) : child/ related Model to_register (bool) : flag if the relation should be set in RelationshipManager Returns : (Model) : (if needed) registered Model register_relation 1 2 | @classmethod | register_relation ( cls , model : \"Model\" , child : \"Model\" ) -> None Registers relation between parent and child in relation manager. Relation manager is kep on each model (different instance). Used in Metaclass and sometimes some relations are missing (i.e. cloned Models in fastapi might miss one). Arguments : model (Model class) : parent model (with relation definition) child (Model class) : child model has_unresolved_forward_refs 1 2 | @classmethod | has_unresolved_forward_refs ( cls ) -> bool Verifies if the filed has any ForwardRefs that require updating before the model can be used. Returns : (bool) : result of the check expand_relationship 1 2 | @classmethod | expand_relationship ( cls , value : Any , child : Union [ \"Model\" , \"NewBaseModel\" ], to_register : bool = True ) -> Optional [ Union [ \"Model\" , List [ \"Model\" ]]] For relations the child model is first constructed (if needed), registered in relation and returned. For relation fields the value can be a pk value (Any type of field), dict (from Model) or actual instance/list of a \"Model\". Selects the appropriate constructor based on a passed value. Arguments : value (Any) : a Model field value, returned untouched for non relation fields. child (Union[\"Model\", \"NewBaseModel\"]) : a child Model to register to_register (bool) : flag if the relation should be set in RelationshipManager Returns : (Optional[Union[\"Model\", List[\"Model\"]]]) : returns a Model or a list of Models","title":"Foreign Key"},{"location":"api/fields/foreign-key/#fieldsforeign_key","text":"","title":"fields.foreign_key"},{"location":"api/fields/foreign-key/#create_dummy_instance","text":"1 create_dummy_instance ( fk : Type [ \"Model\" ], pk : Any = None ) -> \"Model\" Ormar never returns you a raw data. So if you have a related field that has a value populated it will construct you a Model instance out of it. Creates a \"fake\" instance of passed Model from pk value. The instantiated Model has only pk value filled. To achieve this pk_only flag has to be passed as it skips the validation. If the nested related Models are required they are set with -1 as pk value. Arguments : fk (Model class) : class of the related Model to which instance should be constructed pk (Any) : value of the primary_key column Returns : (Model) : Model instance populated with only pk","title":"create_dummy_instance"},{"location":"api/fields/foreign-key/#create_dummy_model","text":"1 create_dummy_model ( base_model : Type [ \"Model\" ], pk_field : Type [ Union [ BaseField , \"ForeignKeyField\" , \"ManyToManyField\" ]]) -> Type [ \"BaseModel\" ] Used to construct a dummy pydantic model for type hints and pydantic validation. Populates only pk field and set it to desired type. Arguments : base_model (Model class) : class of target dummy model pk_field (Type[Union[BaseField, \"ForeignKeyField\", \"ManyToManyField\"]]) : ormar Field to be set on pydantic Model Returns : (pydantic.BaseModel) : constructed dummy model","title":"create_dummy_model"},{"location":"api/fields/foreign-key/#populate_fk_params_based_on_to_model","text":"1 populate_fk_params_based_on_to_model ( to : Type [ \"Model\" ], nullable : bool , onupdate : str = None , ondelete : str = None ) -> Tuple [ Any , List , Any ] Based on target to model to which relation leads to populates the type of the pydantic field to use, ForeignKey constraint and type of the target column field. Arguments : to (Model class) : target related ormar Model nullable (bool) : marks field as optional/ required onupdate (str) : parameter passed to sqlalchemy.ForeignKey. How to treat child rows on update of parent (the one where FK is defined) model. ondelete (str) : parameter passed to sqlalchemy.ForeignKey. How to treat child rows on delete of parent (the one where FK is defined) model. Returns : (Tuple[Any, List, Any]) : tuple with target pydantic type, list of fk constraints and target col type","title":"populate_fk_params_based_on_to_model"},{"location":"api/fields/foreign-key/#uniquecolumns-objects","text":"1 class UniqueColumns ( UniqueConstraint ) Subclass of sqlalchemy.UniqueConstraint. Used to avoid importing anything from sqlalchemy by user.","title":"UniqueColumns Objects"},{"location":"api/fields/foreign-key/#foreignkeyconstraint-objects","text":"1 2 @dataclass class ForeignKeyConstraint () Internal container to store ForeignKey definitions used later to produce sqlalchemy.ForeignKeys","title":"ForeignKeyConstraint Objects"},{"location":"api/fields/foreign-key/#foreignkey","text":"1 ForeignKey ( to : \"ToType\" , * , name : str = None , unique : bool = False , nullable : bool = True , related_name : str = None , virtual : bool = False , onupdate : str = None , ondelete : str = None , ** kwargs : Any , ,) -> Any Despite a name it's a function that returns constructed ForeignKeyField. This function is actually used in model declaration (as ormar.ForeignKey(ToModel)). Accepts number of relation setting parameters as well as all BaseField ones. Arguments : to (Model class) : target related ormar Model name (str) : name of the database field - later called alias unique (bool) : parameter passed to sqlalchemy.ForeignKey, unique flag nullable (bool) : marks field as optional/ required related_name (str) : name of reversed FK relation populated for you on to model virtual (bool) : marks if relation is virtual. It is for reversed FK and auto generated FK on through model in Many2Many relations. onupdate (str) : parameter passed to sqlalchemy.ForeignKey. How to treat child rows on update of parent (the one where FK is defined) model. ondelete (str) : parameter passed to sqlalchemy.ForeignKey. How to treat child rows on delete of parent (the one where FK is defined) model. kwargs (Any) : all other args to be populated by BaseField Returns : (ForeignKeyField) : ormar ForeignKeyField with relation to selected model","title":"ForeignKey"},{"location":"api/fields/foreign-key/#foreignkeyfield-objects","text":"1 class ForeignKeyField ( BaseField ) Actual class returned from ForeignKey function call and stored in model_fields.","title":"ForeignKeyField Objects"},{"location":"api/fields/foreign-key/#get_source_related_name","text":"1 2 | @classmethod | get_source_related_name ( cls ) -> str Returns name to use for source relation name. For FK it's the same, differs for m2m fields. It's either set as related_name or by default it's owner model. get_name + 's' Returns : (str) : name of the related_name or default related name.","title":"get_source_related_name"},{"location":"api/fields/foreign-key/#get_related_name","text":"1 2 | @classmethod | get_related_name ( cls ) -> str Returns name to use for reverse relation. It's either set as related_name or by default it's owner model. get_name + 's' Returns : (str) : name of the related_name or default related name.","title":"get_related_name"},{"location":"api/fields/foreign-key/#evaluate_forward_ref","text":"1 2 | @classmethod | evaluate_forward_ref ( cls , globalns : Any , localns : Any ) -> None Evaluates the ForwardRef to actual Field based on global and local namespaces Arguments : globalns (Any) : global namespace localns (Any) : local namespace Returns : (None) : None","title":"evaluate_forward_ref"},{"location":"api/fields/foreign-key/#_extract_model_from_sequence","text":"1 2 | @classmethod | _extract_model_from_sequence ( cls , value : List , child : \"Model\" , to_register : bool ) -> List [ \"Model\" ] Takes a list of Models and registers them on parent. Registration is mutual, so children have also reference to parent. Used in reverse FK relations. Arguments : value (List) : list of Model child (Model) : child/ related Model to_register (bool) : flag if the relation should be set in RelationshipManager Returns : (List[\"Model\"]) : list (if needed) registered Models","title":"_extract_model_from_sequence"},{"location":"api/fields/foreign-key/#_register_existing_model","text":"1 2 | @classmethod | _register_existing_model ( cls , value : \"Model\" , child : \"Model\" , to_register : bool ) -> \"Model\" Takes already created instance and registers it for parent. Registration is mutual, so children have also reference to parent. Used in reverse FK relations and normal FK for single models. Arguments : value (Model) : already instantiated Model child (Model) : child/ related Model to_register (bool) : flag if the relation should be set in RelationshipManager Returns : (Model) : (if needed) registered Model","title":"_register_existing_model"},{"location":"api/fields/foreign-key/#_construct_model_from_dict","text":"1 2 | @classmethod | _construct_model_from_dict ( cls , value : dict , child : \"Model\" , to_register : bool ) -> \"Model\" Takes a dictionary, creates a instance and registers it for parent. If dictionary contains only one field and it's a pk it is a pk_only model. Registration is mutual, so children have also reference to parent. Used in normal FK for dictionaries. Arguments : value (dict) : dictionary of a Model child (Model) : child/ related Model to_register (bool) : flag if the relation should be set in RelationshipManager Returns : (Model) : (if needed) registered Model","title":"_construct_model_from_dict"},{"location":"api/fields/foreign-key/#_construct_model_from_pk","text":"1 2 | @classmethod | _construct_model_from_pk ( cls , value : Any , child : \"Model\" , to_register : bool ) -> \"Model\" Takes a pk value, creates a dummy instance and registers it for parent. Registration is mutual, so children have also reference to parent. Used in normal FK for dictionaries. Arguments : value (Any) : value of a related pk / fk column child (Model) : child/ related Model to_register (bool) : flag if the relation should be set in RelationshipManager Returns : (Model) : (if needed) registered Model","title":"_construct_model_from_pk"},{"location":"api/fields/foreign-key/#register_relation","text":"1 2 | @classmethod | register_relation ( cls , model : \"Model\" , child : \"Model\" ) -> None Registers relation between parent and child in relation manager. Relation manager is kep on each model (different instance). Used in Metaclass and sometimes some relations are missing (i.e. cloned Models in fastapi might miss one). Arguments : model (Model class) : parent model (with relation definition) child (Model class) : child model","title":"register_relation"},{"location":"api/fields/foreign-key/#has_unresolved_forward_refs","text":"1 2 | @classmethod | has_unresolved_forward_refs ( cls ) -> bool Verifies if the filed has any ForwardRefs that require updating before the model can be used. Returns : (bool) : result of the check","title":"has_unresolved_forward_refs"},{"location":"api/fields/foreign-key/#expand_relationship","text":"1 2 | @classmethod | expand_relationship ( cls , value : Any , child : Union [ \"Model\" , \"NewBaseModel\" ], to_register : bool = True ) -> Optional [ Union [ \"Model\" , List [ \"Model\" ]]] For relations the child model is first constructed (if needed), registered in relation and returned. For relation fields the value can be a pk value (Any type of field), dict (from Model) or actual instance/list of a \"Model\". Selects the appropriate constructor based on a passed value. Arguments : value (Any) : a Model field value, returned untouched for non relation fields. child (Union[\"Model\", \"NewBaseModel\"]) : a child Model to register to_register (bool) : flag if the relation should be set in RelationshipManager Returns : (Optional[Union[\"Model\", List[\"Model\"]]]) : returns a Model or a list of Models","title":"expand_relationship"},{"location":"api/fields/many-to-many/","text":"fields.many_to_many populate_m2m_params_based_on_to_model 1 populate_m2m_params_based_on_to_model ( to : Type [ \"Model\" ], nullable : bool ) -> Tuple [ Any , Any ] Based on target to model to which relation leads to populates the type of the pydantic field to use and type of the target column field. Arguments : to (Model class) : target related ormar Model nullable (bool) : marks field as optional/ required Returns : (tuple with target pydantic type and target col type) : Tuple[List, Any] ManyToMany 1 ManyToMany ( to : \"ToType\" , through : \"ToType\" , * , name : str = None , unique : bool = False , virtual : bool = False , ** kwargs : Any , ,) -> Any Despite a name it's a function that returns constructed ManyToManyField. This function is actually used in model declaration (as ormar.ManyToMany(ToModel, through=ThroughModel)). Accepts number of relation setting parameters as well as all BaseField ones. Arguments : to (Model class) : target related ormar Model through (Model class) : through model for m2m relation name (str) : name of the database field - later called alias unique (bool) : parameter passed to sqlalchemy.ForeignKey, unique flag virtual (bool) : marks if relation is virtual. It is for reversed FK and auto generated FK on through model in Many2Many relations. kwargs (Any) : all other args to be populated by BaseField Returns : (ManyToManyField) : ormar ManyToManyField with m2m relation to selected model ManyToManyField Objects 1 class ManyToManyField ( ForeignKeyField , ormar . QuerySetProtocol , ormar . RelationProtocol ) Actual class returned from ManyToMany function call and stored in model_fields. get_source_related_name 1 2 | @classmethod | get_source_related_name ( cls ) -> str Returns name to use for source relation name. For FK it's the same, differs for m2m fields. It's either set as related_name or by default it's field name. Returns : (str) : name of the related_name or default related name. default_target_field_name 1 2 | @classmethod | default_target_field_name ( cls ) -> str Returns default target model name on through model. Returns : (str) : name of the field default_source_field_name 1 2 | @classmethod | default_source_field_name ( cls ) -> str Returns default target model name on through model. Returns : (str) : name of the field has_unresolved_forward_refs 1 2 | @classmethod | has_unresolved_forward_refs ( cls ) -> bool Verifies if the filed has any ForwardRefs that require updating before the model can be used. Returns : (bool) : result of the check evaluate_forward_ref 1 2 | @classmethod | evaluate_forward_ref ( cls , globalns : Any , localns : Any ) -> None Evaluates the ForwardRef to actual Field based on global and local namespaces Arguments : globalns (Any) : global namespace localns (Any) : local namespace Returns : (None) : None","title":"Many To Many"},{"location":"api/fields/many-to-many/#fieldsmany_to_many","text":"","title":"fields.many_to_many"},{"location":"api/fields/many-to-many/#populate_m2m_params_based_on_to_model","text":"1 populate_m2m_params_based_on_to_model ( to : Type [ \"Model\" ], nullable : bool ) -> Tuple [ Any , Any ] Based on target to model to which relation leads to populates the type of the pydantic field to use and type of the target column field. Arguments : to (Model class) : target related ormar Model nullable (bool) : marks field as optional/ required Returns : (tuple with target pydantic type and target col type) : Tuple[List, Any]","title":"populate_m2m_params_based_on_to_model"},{"location":"api/fields/many-to-many/#manytomany","text":"1 ManyToMany ( to : \"ToType\" , through : \"ToType\" , * , name : str = None , unique : bool = False , virtual : bool = False , ** kwargs : Any , ,) -> Any Despite a name it's a function that returns constructed ManyToManyField. This function is actually used in model declaration (as ormar.ManyToMany(ToModel, through=ThroughModel)). Accepts number of relation setting parameters as well as all BaseField ones. Arguments : to (Model class) : target related ormar Model through (Model class) : through model for m2m relation name (str) : name of the database field - later called alias unique (bool) : parameter passed to sqlalchemy.ForeignKey, unique flag virtual (bool) : marks if relation is virtual. It is for reversed FK and auto generated FK on through model in Many2Many relations. kwargs (Any) : all other args to be populated by BaseField Returns : (ManyToManyField) : ormar ManyToManyField with m2m relation to selected model","title":"ManyToMany"},{"location":"api/fields/many-to-many/#manytomanyfield-objects","text":"1 class ManyToManyField ( ForeignKeyField , ormar . QuerySetProtocol , ormar . RelationProtocol ) Actual class returned from ManyToMany function call and stored in model_fields.","title":"ManyToManyField Objects"},{"location":"api/fields/many-to-many/#get_source_related_name","text":"1 2 | @classmethod | get_source_related_name ( cls ) -> str Returns name to use for source relation name. For FK it's the same, differs for m2m fields. It's either set as related_name or by default it's field name. Returns : (str) : name of the related_name or default related name.","title":"get_source_related_name"},{"location":"api/fields/many-to-many/#default_target_field_name","text":"1 2 | @classmethod | default_target_field_name ( cls ) -> str Returns default target model name on through model. Returns : (str) : name of the field","title":"default_target_field_name"},{"location":"api/fields/many-to-many/#default_source_field_name","text":"1 2 | @classmethod | default_source_field_name ( cls ) -> str Returns default target model name on through model. Returns : (str) : name of the field","title":"default_source_field_name"},{"location":"api/fields/many-to-many/#has_unresolved_forward_refs","text":"1 2 | @classmethod | has_unresolved_forward_refs ( cls ) -> bool Verifies if the filed has any ForwardRefs that require updating before the model can be used. Returns : (bool) : result of the check","title":"has_unresolved_forward_refs"},{"location":"api/fields/many-to-many/#evaluate_forward_ref","text":"1 2 | @classmethod | evaluate_forward_ref ( cls , globalns : Any , localns : Any ) -> None Evaluates the ForwardRef to actual Field based on global and local namespaces Arguments : globalns (Any) : global namespace localns (Any) : local namespace Returns : (None) : None","title":"evaluate_forward_ref"},{"location":"api/fields/model-fields/","text":"fields.model_fields is_field_nullable 1 is_field_nullable ( nullable : Optional [ bool ], default : Any , server_default : Any , pydantic_only : Optional [ bool ]) -> bool Checks if the given field should be nullable/ optional based on parameters given. Arguments : nullable (Optional[bool]) : flag explicit setting a column as nullable default (Any) : value or function to be called as default in python server_default (Any) : function to be called as default by sql server pydantic_only (Optional[bool]) : flag if fields should not be included in the sql table Returns : (bool) : result of the check is_auto_primary_key 1 is_auto_primary_key ( primary_key : bool , autoincrement : bool ) -> bool Checks if field is an autoincrement pk -> if yes it's optional. Arguments : primary_key (bool) : flag if field is a pk field autoincrement (bool) : flag if field should be autoincrement Returns : (bool) : result of the check ModelFieldFactory Objects 1 class ModelFieldFactory () Default field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options validate 1 2 | @classmethod | validate ( cls , ** kwargs : Any ) -> None Used to validate if all required parameters on a given field type are set. Arguments : kwargs (Any) : all params passed during construction String Objects 1 class String ( ModelFieldFactory , str ) String field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options validate 1 2 | @classmethod | validate ( cls , ** kwargs : Any ) -> None Used to validate if all required parameters on a given field type are set. Arguments : kwargs (Any) : all params passed during construction Integer Objects 1 class Integer ( ModelFieldFactory , int ) Integer field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options Text Objects 1 class Text ( ModelFieldFactory , str ) Text field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options Float Objects 1 class Float ( ModelFieldFactory , float ) Float field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options DateTime Objects 1 class DateTime ( ModelFieldFactory , datetime . datetime ) DateTime field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options Date Objects 1 class Date ( ModelFieldFactory , datetime . date ) Date field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options Time Objects 1 class Time ( ModelFieldFactory , datetime . time ) Time field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options JSON Objects 1 class JSON ( ModelFieldFactory , pydantic . Json ) JSON field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options BigInteger Objects 1 class BigInteger ( Integer , int ) BigInteger field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options Decimal Objects 1 class Decimal ( ModelFieldFactory , decimal . Decimal ) Decimal field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options validate 1 2 | @classmethod | validate ( cls , ** kwargs : Any ) -> None Used to validate if all required parameters on a given field type are set. Arguments : kwargs (Any) : all params passed during construction UUID Objects 1 class UUID ( ModelFieldFactory , uuid . UUID ) UUID field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options","title":"Model Fields"},{"location":"api/fields/model-fields/#fieldsmodel_fields","text":"","title":"fields.model_fields"},{"location":"api/fields/model-fields/#is_field_nullable","text":"1 is_field_nullable ( nullable : Optional [ bool ], default : Any , server_default : Any , pydantic_only : Optional [ bool ]) -> bool Checks if the given field should be nullable/ optional based on parameters given. Arguments : nullable (Optional[bool]) : flag explicit setting a column as nullable default (Any) : value or function to be called as default in python server_default (Any) : function to be called as default by sql server pydantic_only (Optional[bool]) : flag if fields should not be included in the sql table Returns : (bool) : result of the check","title":"is_field_nullable"},{"location":"api/fields/model-fields/#is_auto_primary_key","text":"1 is_auto_primary_key ( primary_key : bool , autoincrement : bool ) -> bool Checks if field is an autoincrement pk -> if yes it's optional. Arguments : primary_key (bool) : flag if field is a pk field autoincrement (bool) : flag if field should be autoincrement Returns : (bool) : result of the check","title":"is_auto_primary_key"},{"location":"api/fields/model-fields/#modelfieldfactory-objects","text":"1 class ModelFieldFactory () Default field factory that construct Field classes and populated their values.","title":"ModelFieldFactory Objects"},{"location":"api/fields/model-fields/#get_column_type","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options","title":"get_column_type"},{"location":"api/fields/model-fields/#validate","text":"1 2 | @classmethod | validate ( cls , ** kwargs : Any ) -> None Used to validate if all required parameters on a given field type are set. Arguments : kwargs (Any) : all params passed during construction","title":"validate"},{"location":"api/fields/model-fields/#string-objects","text":"1 class String ( ModelFieldFactory , str ) String field factory that construct Field classes and populated their values.","title":"String Objects"},{"location":"api/fields/model-fields/#get_column_type_1","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options","title":"get_column_type"},{"location":"api/fields/model-fields/#validate_1","text":"1 2 | @classmethod | validate ( cls , ** kwargs : Any ) -> None Used to validate if all required parameters on a given field type are set. Arguments : kwargs (Any) : all params passed during construction","title":"validate"},{"location":"api/fields/model-fields/#integer-objects","text":"1 class Integer ( ModelFieldFactory , int ) Integer field factory that construct Field classes and populated their values.","title":"Integer Objects"},{"location":"api/fields/model-fields/#get_column_type_2","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options","title":"get_column_type"},{"location":"api/fields/model-fields/#text-objects","text":"1 class Text ( ModelFieldFactory , str ) Text field factory that construct Field classes and populated their values.","title":"Text Objects"},{"location":"api/fields/model-fields/#get_column_type_3","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options","title":"get_column_type"},{"location":"api/fields/model-fields/#float-objects","text":"1 class Float ( ModelFieldFactory , float ) Float field factory that construct Field classes and populated their values.","title":"Float Objects"},{"location":"api/fields/model-fields/#get_column_type_4","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options","title":"get_column_type"},{"location":"api/fields/model-fields/#datetime-objects","text":"1 class DateTime ( ModelFieldFactory , datetime . datetime ) DateTime field factory that construct Field classes and populated their values.","title":"DateTime Objects"},{"location":"api/fields/model-fields/#get_column_type_5","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options","title":"get_column_type"},{"location":"api/fields/model-fields/#date-objects","text":"1 class Date ( ModelFieldFactory , datetime . date ) Date field factory that construct Field classes and populated their values.","title":"Date Objects"},{"location":"api/fields/model-fields/#get_column_type_6","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options","title":"get_column_type"},{"location":"api/fields/model-fields/#time-objects","text":"1 class Time ( ModelFieldFactory , datetime . time ) Time field factory that construct Field classes and populated their values.","title":"Time Objects"},{"location":"api/fields/model-fields/#get_column_type_7","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options","title":"get_column_type"},{"location":"api/fields/model-fields/#json-objects","text":"1 class JSON ( ModelFieldFactory , pydantic . Json ) JSON field factory that construct Field classes and populated their values.","title":"JSON Objects"},{"location":"api/fields/model-fields/#get_column_type_8","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options","title":"get_column_type"},{"location":"api/fields/model-fields/#biginteger-objects","text":"1 class BigInteger ( Integer , int ) BigInteger field factory that construct Field classes and populated their values.","title":"BigInteger Objects"},{"location":"api/fields/model-fields/#get_column_type_9","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options","title":"get_column_type"},{"location":"api/fields/model-fields/#decimal-objects","text":"1 class Decimal ( ModelFieldFactory , decimal . Decimal ) Decimal field factory that construct Field classes and populated their values.","title":"Decimal Objects"},{"location":"api/fields/model-fields/#get_column_type_10","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options","title":"get_column_type"},{"location":"api/fields/model-fields/#validate_2","text":"1 2 | @classmethod | validate ( cls , ** kwargs : Any ) -> None Used to validate if all required parameters on a given field type are set. Arguments : kwargs (Any) : all params passed during construction","title":"validate"},{"location":"api/fields/model-fields/#uuid-objects","text":"1 class UUID ( ModelFieldFactory , uuid . UUID ) UUID field factory that construct Field classes and populated their values.","title":"UUID Objects"},{"location":"api/fields/model-fields/#get_column_type_11","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs (Any) : key, value pairs of sqlalchemy options Returns : (sqlalchemy Column) : initialized column with proper options","title":"get_column_type"},{"location":"api/models/model-metaclass/","text":"models.metaclass ModelMeta Objects 1 class ModelMeta () Class used for type hinting. Users can subclass this one for convenience but it's not required. The only requirement is that ormar.Model has to have inner class with name Meta. check_if_field_has_choices 1 check_if_field_has_choices ( field : Type [ BaseField ]) -> bool Checks if given field has choices populated. A if it has one, a validator for this field needs to be attached. Arguments : field (BaseField) : ormar field to check Returns : (bool) : result of the check choices_validator 1 choices_validator ( cls : Type [ \"Model\" ], values : Dict [ str , Any ]) -> Dict [ str , Any ] Validator that is attached to pydantic model pre root validators. Validator checks if field value is in field.choices list. Raises : ValueError : if field value is outside of allowed choices. Arguments : cls (Model class) : constructed class values (Dict[str, Any]) : dictionary of field values (pydantic side) Returns : (Dict[str, Any]) : values if pass validation, otherwise exception is raised populate_choices_validators 1 populate_choices_validators ( model : Type [ \"Model\" ]) -> None Checks if Model has any fields with choices set. If yes it adds choices validation into pre root validators. Arguments : model (Model class) : newly constructed Model add_cached_properties 1 add_cached_properties ( new_model : Type [ \"Model\" ]) -> None Sets cached properties for both pydantic and ormar models. Quick access fields are fields grabbed in getattribute to skip all checks. Related fields and names are populated to None as they can change later. When children models are constructed they can modify parent to register itself. All properties here are used as \"cache\" to not recalculate them constantly. Arguments : new_model (Model class) : newly constructed Model meta_field_not_set 1 meta_field_not_set ( model : Type [ \"Model\" ], field_name : str ) -> bool Checks if field with given name is already present in model.Meta. Then check if it's set to something truthful (in practice meaning not None, as it's non or ormar Field only). Arguments : model (Model class) : newly constructed model field_name (str) : name of the ormar field Returns : (bool) : result of the check add_property_fields 1 add_property_fields ( new_model : Type [ \"Model\" ], attrs : Dict ) -> None Checks class namespace for properties or functions with property_field . If attribute have property_field it was decorated with @property_field. Functions like this are exposed in dict() (therefore also fastapi result). Names of property fields are cached for quicker access / extraction. Arguments : new_model (Model class) : newly constructed model attrs (Dict[str, str]) : register_signals 1 register_signals ( new_model : Type [ \"Model\" ]) -> None Registers on model's SignalEmmiter and sets pre defined signals. Predefined signals are (pre/post) + (save/update/delete). Signals are emitted in both model own methods and in selected queryset ones. Arguments : new_model (Model class) : newly constructed model update_attrs_and_fields 1 update_attrs_and_fields ( attrs : Dict , new_attrs : Dict , model_fields : Dict , new_model_fields : Dict , new_fields : Set ) -> Dict Updates annotations , values of model fields (so pydantic FieldInfos) as well as model.Meta.model_fields definitions from parents. Arguments : attrs (Dict) : new namespace for class being constructed new_attrs (Dict) : related of the namespace extracted from parent class model_fields (Dict[str, BaseField]) : ormar fields in defined in current class new_model_fields (Dict[str, BaseField]) : ormar fields defined in parent classes new_fields (Set[str]) : set of new fields names verify_constraint_names 1 verify_constraint_names ( base_class : \"Model\" , model_fields : Dict , parent_value : List ) -> None Verifies if redefined fields that are overwritten in subclasses did not remove any name of the column that is used in constraint as it will fail in sqlalchemy Table creation. Arguments : base_class (Model or model parent class) : one of the parent classes model_fields (Dict[str, BaseField]) : ormar fields in defined in current class parent_value (List) : list of base class constraints update_attrs_from_base_meta 1 update_attrs_from_base_meta ( base_class : \"Model\" , attrs : Dict , model_fields : Dict ) -> None Updates Meta parameters in child from parent if needed. Arguments : base_class (Model or model parent class) : one of the parent classes attrs (Dict) : new namespace for class being constructed model_fields (Dict[str, BaseField]) : ormar fields in defined in current class copy_and_replace_m2m_through_model 1 copy_and_replace_m2m_through_model ( field : Type [ ManyToManyField ], field_name : str , table_name : str , parent_fields : Dict , attrs : Dict , meta : ModelMeta ) -> None Clones class with Through model for m2m relations, appends child name to the name of the cloned class. Clones non foreign keys fields from parent model, the same with database columns. Modifies related_name with appending child table name after '_' For table name, the table name of child is appended after '_'. Removes the original sqlalchemy table from metadata if it was not removed. Arguments : field (Type[ManyToManyField]) : field with relations definition field_name (str) : name of the relation field table_name (str) : name of the table parent_fields (Dict) : dictionary of fields to copy to new models from parent attrs (Dict) : new namespace for class being constructed meta (ModelMeta) : metaclass of currently created model copy_data_from_parent_model 1 2 3 copy_data_from_parent_model ( base_class : Type [ \"Model\" ], curr_class : type , attrs : Dict , model_fields : Dict [ str , Union [ Type [ BaseField ], Type [ ForeignKeyField ], Type [ ManyToManyField ]] ]) -> Tuple [ Dict , Dict ] Copy the key parameters [databse, metadata, property_fields and constraints] and fields from parent models. Overwrites them if needed. Only abstract classes can be subclassed. Since relation fields requires different related_name for different children Raises : ModelDefinitionError : if non abstract model is subclassed Arguments : base_class (Model or model parent class) : one of the parent classes curr_class (Model or model parent class) : current constructed class attrs (Dict) : new namespace for class being constructed model_fields (Dict[str, BaseField]) : ormar fields in defined in current class Returns : (Tuple[Dict, Dict]) : updated attrs and model_fields extract_from_parents_definition 1 2 3 extract_from_parents_definition ( base_class : type , curr_class : type , attrs : Dict , model_fields : Dict [ str , Union [ Type [ BaseField ], Type [ ForeignKeyField ], Type [ ManyToManyField ]] ]) -> Tuple [ Dict , Dict ] Extracts fields from base classes if they have valid oramr fields. If model was already parsed -> fields definitions need to be removed from class cause pydantic complains about field re-definition so after first child we need to extract from parsed_fields not the class itself. If the class is parsed first time annotations and field definition is parsed from the class. dict . If the class is a ormar.Model it is skipped. Arguments : base_class (Model or model parent class) : one of the parent classes curr_class (Model or model parent class) : current constructed class attrs (Dict) : new namespace for class being constructed model_fields (Dict[str, BaseField]) : ormar fields in defined in current class Returns : (Tuple[Dict, Dict]) : updated attrs and model_fields ModelMetaclass Objects 1 class ModelMetaclass ( pydantic . main . ModelMetaclass ) __new__ 1 | __new__ ( mcs : \"ModelMetaclass\" , name : str , bases : Any , attrs : dict ) -> \"ModelMetaclass\" Metaclass used by ormar Models that performs configuration and build of ormar Models. Sets pydantic configuration. Extract model_fields and convert them to pydantic FieldInfo, updates class namespace. Extracts settings and fields from parent classes. Fetches methods decorated with @property_field decorator to expose them later in dict(). Construct parent pydantic Metaclass/ Model. If class has Meta class declared (so actual ormar Models) it also: populate sqlalchemy columns, pkname and tables from model_fields register reverse relationships on related models registers all relations in alias manager that populates table_prefixes exposes alias manager on each Model creates QuerySet for each model and exposes it on a class Arguments : name (str) : name of current class bases (Tuple) : base classes attrs (Dict) : class namespace","title":"Model Metaclass"},{"location":"api/models/model-metaclass/#modelsmetaclass","text":"","title":"models.metaclass"},{"location":"api/models/model-metaclass/#modelmeta-objects","text":"1 class ModelMeta () Class used for type hinting. Users can subclass this one for convenience but it's not required. The only requirement is that ormar.Model has to have inner class with name Meta.","title":"ModelMeta Objects"},{"location":"api/models/model-metaclass/#check_if_field_has_choices","text":"1 check_if_field_has_choices ( field : Type [ BaseField ]) -> bool Checks if given field has choices populated. A if it has one, a validator for this field needs to be attached. Arguments : field (BaseField) : ormar field to check Returns : (bool) : result of the check","title":"check_if_field_has_choices"},{"location":"api/models/model-metaclass/#choices_validator","text":"1 choices_validator ( cls : Type [ \"Model\" ], values : Dict [ str , Any ]) -> Dict [ str , Any ] Validator that is attached to pydantic model pre root validators. Validator checks if field value is in field.choices list. Raises : ValueError : if field value is outside of allowed choices. Arguments : cls (Model class) : constructed class values (Dict[str, Any]) : dictionary of field values (pydantic side) Returns : (Dict[str, Any]) : values if pass validation, otherwise exception is raised","title":"choices_validator"},{"location":"api/models/model-metaclass/#populate_choices_validators","text":"1 populate_choices_validators ( model : Type [ \"Model\" ]) -> None Checks if Model has any fields with choices set. If yes it adds choices validation into pre root validators. Arguments : model (Model class) : newly constructed Model","title":"populate_choices_validators"},{"location":"api/models/model-metaclass/#add_cached_properties","text":"1 add_cached_properties ( new_model : Type [ \"Model\" ]) -> None Sets cached properties for both pydantic and ormar models. Quick access fields are fields grabbed in getattribute to skip all checks. Related fields and names are populated to None as they can change later. When children models are constructed they can modify parent to register itself. All properties here are used as \"cache\" to not recalculate them constantly. Arguments : new_model (Model class) : newly constructed Model","title":"add_cached_properties"},{"location":"api/models/model-metaclass/#meta_field_not_set","text":"1 meta_field_not_set ( model : Type [ \"Model\" ], field_name : str ) -> bool Checks if field with given name is already present in model.Meta. Then check if it's set to something truthful (in practice meaning not None, as it's non or ormar Field only). Arguments : model (Model class) : newly constructed model field_name (str) : name of the ormar field Returns : (bool) : result of the check","title":"meta_field_not_set"},{"location":"api/models/model-metaclass/#add_property_fields","text":"1 add_property_fields ( new_model : Type [ \"Model\" ], attrs : Dict ) -> None Checks class namespace for properties or functions with property_field . If attribute have property_field it was decorated with @property_field. Functions like this are exposed in dict() (therefore also fastapi result). Names of property fields are cached for quicker access / extraction. Arguments : new_model (Model class) : newly constructed model attrs (Dict[str, str]) :","title":"add_property_fields"},{"location":"api/models/model-metaclass/#register_signals","text":"1 register_signals ( new_model : Type [ \"Model\" ]) -> None Registers on model's SignalEmmiter and sets pre defined signals. Predefined signals are (pre/post) + (save/update/delete). Signals are emitted in both model own methods and in selected queryset ones. Arguments : new_model (Model class) : newly constructed model","title":"register_signals"},{"location":"api/models/model-metaclass/#update_attrs_and_fields","text":"1 update_attrs_and_fields ( attrs : Dict , new_attrs : Dict , model_fields : Dict , new_model_fields : Dict , new_fields : Set ) -> Dict Updates annotations , values of model fields (so pydantic FieldInfos) as well as model.Meta.model_fields definitions from parents. Arguments : attrs (Dict) : new namespace for class being constructed new_attrs (Dict) : related of the namespace extracted from parent class model_fields (Dict[str, BaseField]) : ormar fields in defined in current class new_model_fields (Dict[str, BaseField]) : ormar fields defined in parent classes new_fields (Set[str]) : set of new fields names","title":"update_attrs_and_fields"},{"location":"api/models/model-metaclass/#verify_constraint_names","text":"1 verify_constraint_names ( base_class : \"Model\" , model_fields : Dict , parent_value : List ) -> None Verifies if redefined fields that are overwritten in subclasses did not remove any name of the column that is used in constraint as it will fail in sqlalchemy Table creation. Arguments : base_class (Model or model parent class) : one of the parent classes model_fields (Dict[str, BaseField]) : ormar fields in defined in current class parent_value (List) : list of base class constraints","title":"verify_constraint_names"},{"location":"api/models/model-metaclass/#update_attrs_from_base_meta","text":"1 update_attrs_from_base_meta ( base_class : \"Model\" , attrs : Dict , model_fields : Dict ) -> None Updates Meta parameters in child from parent if needed. Arguments : base_class (Model or model parent class) : one of the parent classes attrs (Dict) : new namespace for class being constructed model_fields (Dict[str, BaseField]) : ormar fields in defined in current class","title":"update_attrs_from_base_meta"},{"location":"api/models/model-metaclass/#copy_and_replace_m2m_through_model","text":"1 copy_and_replace_m2m_through_model ( field : Type [ ManyToManyField ], field_name : str , table_name : str , parent_fields : Dict , attrs : Dict , meta : ModelMeta ) -> None Clones class with Through model for m2m relations, appends child name to the name of the cloned class. Clones non foreign keys fields from parent model, the same with database columns. Modifies related_name with appending child table name after '_' For table name, the table name of child is appended after '_'. Removes the original sqlalchemy table from metadata if it was not removed. Arguments : field (Type[ManyToManyField]) : field with relations definition field_name (str) : name of the relation field table_name (str) : name of the table parent_fields (Dict) : dictionary of fields to copy to new models from parent attrs (Dict) : new namespace for class being constructed meta (ModelMeta) : metaclass of currently created model","title":"copy_and_replace_m2m_through_model"},{"location":"api/models/model-metaclass/#copy_data_from_parent_model","text":"1 2 3 copy_data_from_parent_model ( base_class : Type [ \"Model\" ], curr_class : type , attrs : Dict , model_fields : Dict [ str , Union [ Type [ BaseField ], Type [ ForeignKeyField ], Type [ ManyToManyField ]] ]) -> Tuple [ Dict , Dict ] Copy the key parameters [databse, metadata, property_fields and constraints] and fields from parent models. Overwrites them if needed. Only abstract classes can be subclassed. Since relation fields requires different related_name for different children Raises : ModelDefinitionError : if non abstract model is subclassed Arguments : base_class (Model or model parent class) : one of the parent classes curr_class (Model or model parent class) : current constructed class attrs (Dict) : new namespace for class being constructed model_fields (Dict[str, BaseField]) : ormar fields in defined in current class Returns : (Tuple[Dict, Dict]) : updated attrs and model_fields","title":"copy_data_from_parent_model"},{"location":"api/models/model-metaclass/#extract_from_parents_definition","text":"1 2 3 extract_from_parents_definition ( base_class : type , curr_class : type , attrs : Dict , model_fields : Dict [ str , Union [ Type [ BaseField ], Type [ ForeignKeyField ], Type [ ManyToManyField ]] ]) -> Tuple [ Dict , Dict ] Extracts fields from base classes if they have valid oramr fields. If model was already parsed -> fields definitions need to be removed from class cause pydantic complains about field re-definition so after first child we need to extract from parsed_fields not the class itself. If the class is parsed first time annotations and field definition is parsed from the class. dict . If the class is a ormar.Model it is skipped. Arguments : base_class (Model or model parent class) : one of the parent classes curr_class (Model or model parent class) : current constructed class attrs (Dict) : new namespace for class being constructed model_fields (Dict[str, BaseField]) : ormar fields in defined in current class Returns : (Tuple[Dict, Dict]) : updated attrs and model_fields","title":"extract_from_parents_definition"},{"location":"api/models/model-metaclass/#modelmetaclass-objects","text":"1 class ModelMetaclass ( pydantic . main . ModelMetaclass )","title":"ModelMetaclass Objects"},{"location":"api/models/model-metaclass/#__new__","text":"1 | __new__ ( mcs : \"ModelMetaclass\" , name : str , bases : Any , attrs : dict ) -> \"ModelMetaclass\" Metaclass used by ormar Models that performs configuration and build of ormar Models. Sets pydantic configuration. Extract model_fields and convert them to pydantic FieldInfo, updates class namespace. Extracts settings and fields from parent classes. Fetches methods decorated with @property_field decorator to expose them later in dict(). Construct parent pydantic Metaclass/ Model. If class has Meta class declared (so actual ormar Models) it also: populate sqlalchemy columns, pkname and tables from model_fields register reverse relationships on related models registers all relations in alias manager that populates table_prefixes exposes alias manager on each Model creates QuerySet for each model and exposes it on a class Arguments : name (str) : name of current class bases (Tuple) : base classes attrs (Dict) : class namespace","title":"__new__"},{"location":"api/models/model-table-proxy/","text":"models.modelproxy ModelTableProxy Objects 1 2 class ModelTableProxy ( PrefetchQueryMixin , MergeModelMixin , SavePrepareMixin , ExcludableMixin ) Used to combine all mixins with different set of functionalities. One of the bases of the ormar Model class.","title":"Model Table Proxy"},{"location":"api/models/model-table-proxy/#modelsmodelproxy","text":"","title":"models.modelproxy"},{"location":"api/models/model-table-proxy/#modeltableproxy-objects","text":"1 2 class ModelTableProxy ( PrefetchQueryMixin , MergeModelMixin , SavePrepareMixin , ExcludableMixin ) Used to combine all mixins with different set of functionalities. One of the bases of the ormar Model class.","title":"ModelTableProxy Objects"},{"location":"api/models/model/","text":"models.model Model Objects 1 class Model ( NewBaseModel ) from_row 1 2 | @classmethod | from_row ( cls : Type [ T ], row : sqlalchemy . engine . ResultProxy , select_related : List = None , related_models : Any = None , previous_model : Type [ T ] = None , source_model : Type [ T ] = None , related_name : str = None , fields : Optional [ Union [ Dict , Set ]] = None , exclude_fields : Optional [ Union [ Dict , Set ]] = None , current_relation_str : str = None ) -> Optional [ T ] Model method to convert raw sql row from database into ormar.Model instance. Traverses nested models if they were specified in select_related for query. Called recurrently and returns model instance if it's present in the row. Note that it's processing one row at a time, so if there are duplicates of parent row that needs to be joined/combined (like parent row in sql join with 2+ child rows) instances populated in this method are later combined in the QuerySet. Other method working directly on raw database results is in prefetch_query, where rows are populated in a different way as they do not have nested models in result. Arguments : row (sqlalchemy.engine.result.ResultProxy) : raw result row from the database select_related (List) : list of names of related models fetched from database related_models (Union[List, Dict]) : list or dict of related models previous_model (Model class) : internal param for nested models to specify table_prefix related_name (str) : internal parameter - name of current nested model fields (Optional[Union[Dict, Set]]) : fields and related model fields to include if provided only those are included exclude_fields (Optional[Union[Dict, Set]]) : fields and related model fields to exclude excludes the fields even if they are provided in fields Returns : (Optional[Model]) : returns model if model is populated from database populate_nested_models_from_row 1 2 | @classmethod | populate_nested_models_from_row ( cls , item : dict , row : sqlalchemy . engine . ResultProxy , related_models : Any , fields : Optional [ Union [ Dict , Set ]] = None , exclude_fields : Optional [ Union [ Dict , Set ]] = None , current_relation_str : str = None , source_model : Type [ T ] = None ) -> dict Traverses structure of related models and populates the nested models from the database row. Related models can be a list if only directly related models are to be populated, converted to dict if related models also have their own related models to be populated. Recurrently calls from_row method on nested instances and create nested instances. In the end those instances are added to the final model dictionary. Arguments : source_model (Type[Model]) : source model from which relation started current_relation_str (str) : joined related parts into one string item (Dict) : dictionary of already populated nested models, otherwise empty dict row (sqlalchemy.engine.result.ResultProxy) : raw result row from the database related_models (Union[Dict, List]) : list or dict of related models fields (Optional[Union[Dict, Set]]) : fields and related model fields to include - if provided only those are included exclude_fields (Optional[Union[Dict, Set]]) : fields and related model fields to exclude excludes the fields even if they are provided in fields Returns : (Dict) : dictionary with keys corresponding to model fields names and values are database values extract_prefixed_table_columns 1 2 | @classmethod | extract_prefixed_table_columns ( cls , item : dict , row : sqlalchemy . engine . result . ResultProxy , table_prefix : str , fields : Optional [ Union [ Dict , Set ]] = None , exclude_fields : Optional [ Union [ Dict , Set ]] = None ) -> dict Extracts own fields from raw sql result, using a given prefix. Prefix changes depending on the table's position in a join. If the table is a main table, there is no prefix. All joined tables have prefixes to allow duplicate column names, as well as duplicated joins to the same table from multiple different tables. Extracted fields populates the related dict later used to construct a Model. Used in Model.from_row and PrefetchQuery._populate_rows methods. Arguments : item (Dict) : dictionary of already populated nested models, otherwise empty dict row (sqlalchemy.engine.result.ResultProxy) : raw result row from the database table_prefix (str) : prefix of the table from AliasManager each pair of tables have own prefix (two of them depending on direction) - used in joins to allow multiple joins to the same table. fields (Optional[Union[Dict, Set]]) : fields and related model fields to include - if provided only those are included exclude_fields (Optional[Union[Dict, Set]]) : fields and related model fields to exclude excludes the fields even if they are provided in fields Returns : (Dict) : dictionary with keys corresponding to model fields names and values are database values upsert 1 | async upsert ( ** kwargs : Any ) -> T Performs either a save or an update depending on the presence of the pk. If the pk field is filled it's an update, otherwise the save is performed. For save kwargs are ignored, used only in update if provided. Arguments : kwargs (Any) : list of fields to update Returns : (Model) : saved Model save 1 | async save () -> T Performs a save of given Model instance. If primary key is already saved, db backend will throw integrity error. Related models are saved by pk number, reverse relation and many to many fields are not saved - use corresponding relations methods. If there are fields with server_default set and those fields are not already filled save will trigger also a second query to refreshed the fields populated server side. Does not recognize if model was previously saved. If you want to perform update or insert depending on the pk fields presence use upsert. Sends pre_save and post_save signals. Sets model save status to True. Returns : (Model) : saved Model save_related 1 | async save_related ( follow : bool = False , visited : Set = None , update_count : int = 0 ) -> int Triggers a upsert method on all related models if the instances are not already saved. By default saves only the directly related ones. If follow=True is set it saves also related models of related models. To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept. That way already visited models that are nested are saved, but the save do not follow them inside. So Model A -> Model B -> Model A -> Model C will save second Model A but will never follow into Model C. Nested relations of those kind need to be persisted manually. Arguments : follow (bool) : flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved visited (Set) : internal parameter for recursive calls - already visited models update_count (int) : internal parameter for recursive calls - number of updated instances Returns : (int) : number of updated/saved models _update_and_follow 1 2 | @staticmethod | async _update_and_follow ( rel : T , follow : bool , visited : Set , update_count : int ) -> Tuple [ int , Set ] Internal method used in save_related to follow related models and update numbers of updated related instances. Arguments : rel (Model) : Model to follow follow (bool) : flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved visited (Set) : internal parameter for recursive calls - already visited models update_count (int) : internal parameter for recursive calls - number of updated instances Returns : (Tuple[int, Set]) : tuple of update count and visited update 1 | async update ( ** kwargs : Any ) -> T Performs update of Model instance in the database. Fields can be updated before or you can pass them as kwargs. Sends pre_update and post_update signals. Sets model save status to True. Raises : ModelPersistenceError : If the pk column is not set Arguments : kwargs (Any) : list of fields to update as field=value pairs Returns : (Model) : updated Model delete 1 | async delete () -> int Removes the Model instance from the database. Sends pre_delete and post_delete signals. Sets model save status to False. Note it does not delete the Model itself (python object). So you can delete and later save (since pk is deleted no conflict will arise) or update and the Model will be saved in database again. Returns : (int) : number of deleted rows (for some backends) load 1 | async load () -> T Allow to refresh existing Models fields from database. Be careful as the related models can be overwritten by pk_only models in load. Does NOT refresh the related models fields if they were loaded before. Raises : NoMatch : If given pk is not found in database. Returns : (Model) : reloaded Model","title":"Model"},{"location":"api/models/model/#modelsmodel","text":"","title":"models.model"},{"location":"api/models/model/#model-objects","text":"1 class Model ( NewBaseModel )","title":"Model Objects"},{"location":"api/models/model/#from_row","text":"1 2 | @classmethod | from_row ( cls : Type [ T ], row : sqlalchemy . engine . ResultProxy , select_related : List = None , related_models : Any = None , previous_model : Type [ T ] = None , source_model : Type [ T ] = None , related_name : str = None , fields : Optional [ Union [ Dict , Set ]] = None , exclude_fields : Optional [ Union [ Dict , Set ]] = None , current_relation_str : str = None ) -> Optional [ T ] Model method to convert raw sql row from database into ormar.Model instance. Traverses nested models if they were specified in select_related for query. Called recurrently and returns model instance if it's present in the row. Note that it's processing one row at a time, so if there are duplicates of parent row that needs to be joined/combined (like parent row in sql join with 2+ child rows) instances populated in this method are later combined in the QuerySet. Other method working directly on raw database results is in prefetch_query, where rows are populated in a different way as they do not have nested models in result. Arguments : row (sqlalchemy.engine.result.ResultProxy) : raw result row from the database select_related (List) : list of names of related models fetched from database related_models (Union[List, Dict]) : list or dict of related models previous_model (Model class) : internal param for nested models to specify table_prefix related_name (str) : internal parameter - name of current nested model fields (Optional[Union[Dict, Set]]) : fields and related model fields to include if provided only those are included exclude_fields (Optional[Union[Dict, Set]]) : fields and related model fields to exclude excludes the fields even if they are provided in fields Returns : (Optional[Model]) : returns model if model is populated from database","title":"from_row"},{"location":"api/models/model/#populate_nested_models_from_row","text":"1 2 | @classmethod | populate_nested_models_from_row ( cls , item : dict , row : sqlalchemy . engine . ResultProxy , related_models : Any , fields : Optional [ Union [ Dict , Set ]] = None , exclude_fields : Optional [ Union [ Dict , Set ]] = None , current_relation_str : str = None , source_model : Type [ T ] = None ) -> dict Traverses structure of related models and populates the nested models from the database row. Related models can be a list if only directly related models are to be populated, converted to dict if related models also have their own related models to be populated. Recurrently calls from_row method on nested instances and create nested instances. In the end those instances are added to the final model dictionary. Arguments : source_model (Type[Model]) : source model from which relation started current_relation_str (str) : joined related parts into one string item (Dict) : dictionary of already populated nested models, otherwise empty dict row (sqlalchemy.engine.result.ResultProxy) : raw result row from the database related_models (Union[Dict, List]) : list or dict of related models fields (Optional[Union[Dict, Set]]) : fields and related model fields to include - if provided only those are included exclude_fields (Optional[Union[Dict, Set]]) : fields and related model fields to exclude excludes the fields even if they are provided in fields Returns : (Dict) : dictionary with keys corresponding to model fields names and values are database values","title":"populate_nested_models_from_row"},{"location":"api/models/model/#extract_prefixed_table_columns","text":"1 2 | @classmethod | extract_prefixed_table_columns ( cls , item : dict , row : sqlalchemy . engine . result . ResultProxy , table_prefix : str , fields : Optional [ Union [ Dict , Set ]] = None , exclude_fields : Optional [ Union [ Dict , Set ]] = None ) -> dict Extracts own fields from raw sql result, using a given prefix. Prefix changes depending on the table's position in a join. If the table is a main table, there is no prefix. All joined tables have prefixes to allow duplicate column names, as well as duplicated joins to the same table from multiple different tables. Extracted fields populates the related dict later used to construct a Model. Used in Model.from_row and PrefetchQuery._populate_rows methods. Arguments : item (Dict) : dictionary of already populated nested models, otherwise empty dict row (sqlalchemy.engine.result.ResultProxy) : raw result row from the database table_prefix (str) : prefix of the table from AliasManager each pair of tables have own prefix (two of them depending on direction) - used in joins to allow multiple joins to the same table. fields (Optional[Union[Dict, Set]]) : fields and related model fields to include - if provided only those are included exclude_fields (Optional[Union[Dict, Set]]) : fields and related model fields to exclude excludes the fields even if they are provided in fields Returns : (Dict) : dictionary with keys corresponding to model fields names and values are database values","title":"extract_prefixed_table_columns"},{"location":"api/models/model/#upsert","text":"1 | async upsert ( ** kwargs : Any ) -> T Performs either a save or an update depending on the presence of the pk. If the pk field is filled it's an update, otherwise the save is performed. For save kwargs are ignored, used only in update if provided. Arguments : kwargs (Any) : list of fields to update Returns : (Model) : saved Model","title":"upsert"},{"location":"api/models/model/#save","text":"1 | async save () -> T Performs a save of given Model instance. If primary key is already saved, db backend will throw integrity error. Related models are saved by pk number, reverse relation and many to many fields are not saved - use corresponding relations methods. If there are fields with server_default set and those fields are not already filled save will trigger also a second query to refreshed the fields populated server side. Does not recognize if model was previously saved. If you want to perform update or insert depending on the pk fields presence use upsert. Sends pre_save and post_save signals. Sets model save status to True. Returns : (Model) : saved Model","title":"save"},{"location":"api/models/model/#save_related","text":"1 | async save_related ( follow : bool = False , visited : Set = None , update_count : int = 0 ) -> int Triggers a upsert method on all related models if the instances are not already saved. By default saves only the directly related ones. If follow=True is set it saves also related models of related models. To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept. That way already visited models that are nested are saved, but the save do not follow them inside. So Model A -> Model B -> Model A -> Model C will save second Model A but will never follow into Model C. Nested relations of those kind need to be persisted manually. Arguments : follow (bool) : flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved visited (Set) : internal parameter for recursive calls - already visited models update_count (int) : internal parameter for recursive calls - number of updated instances Returns : (int) : number of updated/saved models","title":"save_related"},{"location":"api/models/model/#_update_and_follow","text":"1 2 | @staticmethod | async _update_and_follow ( rel : T , follow : bool , visited : Set , update_count : int ) -> Tuple [ int , Set ] Internal method used in save_related to follow related models and update numbers of updated related instances. Arguments : rel (Model) : Model to follow follow (bool) : flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved visited (Set) : internal parameter for recursive calls - already visited models update_count (int) : internal parameter for recursive calls - number of updated instances Returns : (Tuple[int, Set]) : tuple of update count and visited","title":"_update_and_follow"},{"location":"api/models/model/#update","text":"1 | async update ( ** kwargs : Any ) -> T Performs update of Model instance in the database. Fields can be updated before or you can pass them as kwargs. Sends pre_update and post_update signals. Sets model save status to True. Raises : ModelPersistenceError : If the pk column is not set Arguments : kwargs (Any) : list of fields to update as field=value pairs Returns : (Model) : updated Model","title":"update"},{"location":"api/models/model/#delete","text":"1 | async delete () -> int Removes the Model instance from the database. Sends pre_delete and post_delete signals. Sets model save status to False. Note it does not delete the Model itself (python object). So you can delete and later save (since pk is deleted no conflict will arise) or update and the Model will be saved in database again. Returns : (int) : number of deleted rows (for some backends)","title":"delete"},{"location":"api/models/model/#load","text":"1 | async load () -> T Allow to refresh existing Models fields from database. Be careful as the related models can be overwritten by pk_only models in load. Does NOT refresh the related models fields if they were loaded before. Raises : NoMatch : If given pk is not found in database. Returns : (Model) : reloaded Model","title":"load"},{"location":"api/models/new-basemodel/","text":"models.newbasemodel NewBaseModel Objects 1 class NewBaseModel ( pydantic . BaseModel , ModelTableProxy , metaclass = ModelMetaclass ) Main base class of ormar Model. Inherits from pydantic BaseModel and has all mixins combined in ModelTableProxy. Constructed with ModelMetaclass which in turn also inherits pydantic metaclass. Abstracts away all internals and helper functions, so final Model class has only the logic concerned with database connection and data persistance. __init__ 1 | __init__ ( * args : Any , ** kwargs : Any ) -> None Initializer that creates a new ormar Model that is also pydantic Model at the same time. Passed keyword arguments can be only field names and their corresponding values as those will be passed to pydantic validation that will complain if extra params are passed. If relations are defined each relation is expanded and children models are also initialized and validated. Relation from both sides is registered so you can access related models from both sides. Json fields are automatically loaded/dumped if needed. Models marked as abstract=True in internal Meta class cannot be initialized. Accepts also special pk_only flag that indicates that Model is constructed only with primary key value (so no other fields, it's a child model on other Model), that causes skipping the validation, that's the only case when the validation can be skipped. Accepts also special excluded parameter that contains a set of fields that should be explicitly set to None, as otherwise pydantic will try to populate them with their default values if default is set. Raises : ModelError : if abstract model is initialized, model has ForwardRefs that has not been updated or unknown field is passed Arguments : args (Any) : ignored args kwargs (Any) : keyword arguments - all fields values and some special params __setattr__ 1 | __setattr__ ( name : str , value : Any ) -> None Overwrites setattr in object to allow for special behaviour of certain params. Parameter \"pk\" is translated into actual primary key field name. Relations are expanded (child model constructed if needed) and registered on both ends of the relation. The related models are handled by RelationshipManager exposed at _orm param. Json fields converted if needed. Setting pk, foreign key value or any other field value sets Model save status to False. Setting a reverse relation or many to many relation does not as it does not modify the state of the model (but related model or through model). To short circuit all checks and expansions the set of attribute names present on each model is gathered into _quick_access_fields that is looked first and if field is in this set the object setattr is called directly. Arguments : name (str) : name of the attribute to set value (Any) : value of the attribute to set Returns : (None) : None __getattribute__ 1 | __getattribute__ ( item : str ) -> Any Because we need to overwrite getting the attribute by ormar instead of pydantic as well as returning related models and not the value stored on the model the getattribute needs to be used not getattr . It's used to access all attributes so it can be a big overhead that's why a number of short circuits is used. To short circuit all checks and expansions the set of attribute names present on each model is gathered into _quick_access_fields that is looked first and if field is in this set the object setattr is called directly. To avoid recursion object's getattribute is used to actually get the attribute value from the model after the checks. Even the function calls are constructed with objects functions. Parameter \"pk\" is translated into actual primary key field name. Relations are returned so the actual related model is returned and not current model's field. The related models are handled by RelationshipManager exposed at _orm param. Json fields are converted if needed. Arguments : item (str) : name of the attribute to retrieve Returns : (Any) : value of the attribute _verify_model_can_be_initialized 1 | _verify_model_can_be_initialized () -> None Raises exception if model is abstract or has ForwardRefs in relation fields. Returns : (None) : None _extract_related_model_instead_of_field 1 | _extract_related_model_instead_of_field ( item : str ) -> Optional [ Union [ \"T\" , Sequence [ \"T\" ]]] Retrieves the related model/models from RelationshipManager. Arguments : item (str) : name of the relation Returns : (Optional[Union[Model, List[Model]]]) : related model, list of related models or None __eq__ 1 | __eq__ ( other : object ) -> bool Compares other model to this model. when == is called. Arguments : other (object) : other model to compare Returns : (bool) : result of comparison __same__ 1 | __same__ ( other : \"NewBaseModel\" ) -> bool Used by eq , compares other model to this model. Compares: * _orm_ids, * primary key values if it's set * dictionary of own fields (excluding relations) Arguments : other (NewBaseModel) : model to compare to Returns : (bool) : result of comparison get_name 1 2 | @classmethod | get_name ( cls , lower : bool = True ) -> str Returns name of the Model class, by default lowercase. Arguments : lower (bool) : flag if name should be set to lowercase Returns : (str) : name of the model pk_column 1 2 | @property | pk_column () -> sqlalchemy . Column Retrieves primary key sqlalchemy column from models Meta.table. Each model has to have primary key. Only one primary key column is allowed. Returns : (sqlalchemy.Column) : primary key sqlalchemy column saved 1 2 | @property | saved () -> bool Saved status of the model. Changed by setattr and loading from db signals 1 2 | @property | signals () -> \"SignalEmitter\" Exposes signals from model Meta pk_type 1 2 | @classmethod | pk_type ( cls ) -> Any Shortcut to models primary key field type db_backend_name 1 2 | @classmethod | db_backend_name ( cls ) -> str Shortcut to database dialect, cause some dialect require different treatment remove 1 | remove ( parent : \"T\" , name : str ) -> None Removes child from relation with given name in RelationshipManager set_save_status 1 | set_save_status ( status : bool ) -> None Sets value of the save status get_properties 1 2 | @classmethod | get_properties ( cls , include : Union [ Set , Dict , None ], exclude : Union [ Set , Dict , None ]) -> Set [ str ] Returns a set of names of functions/fields decorated with @property_field decorator. They are added to dictionary when called directly and therefore also are present in fastapi responses. Arguments : include (Union[Set, Dict, None]) : fields to include exclude (Union[Set, Dict, None]) : fields to exclude Returns : (Set[str]) : set of property fields names update_forward_refs 1 2 | @classmethod | update_forward_refs ( cls , ** localns : Any ) -> None Processes fields that are ForwardRef and need to be evaluated into actual models. Expands relationships, register relation in alias manager and substitutes sqlalchemy columns with new ones with proper column type (null before). Populates Meta table of the Model which is left empty before. Sets self_reference flag on models that links to themselves. Calls the pydantic method to evaluate pydantic fields. Arguments : localns (Any) : local namespace Returns : (None) : None _get_related_not_excluded_fields 1 | _get_related_not_excluded_fields ( include : Optional [ Dict ], exclude : Optional [ Dict ]) -> List Returns related field names applying on them include and exclude set. Arguments : include (Union[Set, Dict, None]) : fields to include exclude (Union[Set, Dict, None]) : fields to exclude Returns : (List of fields with relations that is not excluded) : _extract_nested_models_from_list 1 2 | @staticmethod | _extract_nested_models_from_list ( models : MutableSequence , include : Union [ Set , Dict , None ], exclude : Union [ Set , Dict , None ]) -> List Converts list of models into list of dictionaries. Arguments : models (List) : List of models include (Union[Set, Dict, None]) : fields to include exclude (Union[Set, Dict, None]) : fields to exclude Returns : (List[Dict]) : list of models converted to dictionaries _skip_ellipsis 1 | _skip_ellipsis ( items : Union [ Set , Dict , None ], key : str ) -> Union [ Set , Dict , None ] Helper to traverse the include/exclude dictionaries. In dict() Ellipsis should be skipped as it indicates all fields required and not the actual set/dict with fields names. Arguments : items (Union[Set, Dict, None]) : current include/exclude value key (str) : key for nested relations to check Returns : (Union[Set, Dict, None]) : nested value of the items _extract_nested_models 1 | _extract_nested_models ( nested : bool , dict_instance : Dict , include : Optional [ Dict ], exclude : Optional [ Dict ]) -> Dict Traverse nested models and converts them into dictionaries. Calls itself recursively if needed. Arguments : nested (bool) : flag if current instance is nested dict_instance (Dict) : current instance dict include (Optional[Dict]) : fields to include exclude (Optional[Dict]) : fields to exclude Returns : (Dict) : current model dict with child models converted to dictionaries dict 1 | dict ( * , include : Union [ Set , Dict ] = None , exclude : Union [ Set , Dict ] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , nested : bool = False ) -> \"DictStrAny\" Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Nested models are also parsed to dictionaries. Additionally fields decorated with @property_field are also added. Arguments : include (Union[Set, Dict, None]) : fields to include exclude (Union[Set, Dict, None]) : fields to exclude by_alias (bool) : flag to get values by alias - passed to pydantic skip_defaults (bool) : flag to not set values - passed to pydantic exclude_unset (bool) : flag to exclude not set values - passed to pydantic exclude_defaults (bool) : flag to exclude default values - passed to pydantic exclude_none (bool) : flag to exclude None values - passed to pydantic nested (bool) : flag if the current model is nested Returns : () : update_from_dict 1 | update_from_dict ( value_dict : Dict ) -> \"NewBaseModel\" Updates self with values of fields passed in the dictionary. Arguments : value_dict (Dict) : dictionary of fields names and values Returns : (NewBaseModel) : self _convert_json 1 | _convert_json ( column_name : str , value : Any , op : str ) -> Union [ str , Dict ] Converts value to/from json if needed (for Json columns). Arguments : column_name (str) : name of the field value (Any) : value fo the field op (str) : operator on json Returns : (Any) : converted value if needed, else original value _is_conversion_to_json_needed 1 | _is_conversion_to_json_needed ( column_name : str ) -> bool Checks if given column name is related to JSON field. Arguments : column_name (str) : name of the field Returns : (bool) : result of the check _extract_own_model_fields 1 | _extract_own_model_fields () -> Dict Returns a dictionary with field names and values for fields that are not relations fields (ForeignKey, ManyToMany etc.) Returns : (Dict) : dictionary of fields names and values. _extract_model_db_fields 1 | _extract_model_db_fields () -> Dict Returns a dictionary with field names and values for fields that are stored in current model's table. That includes own non-relational fields ang foreign key fields. Returns : (Dict) : dictionary of fields names and values. get_relation_model_id 1 | get_relation_model_id ( target_field : Type [ \"BaseField\" ]) -> Optional [ int ] Returns an id of the relation side model to use in prefetch query. Arguments : target_field (Type[\"BaseField\"]) : field with relation definition Returns : (Optional[int]) : value of pk if set","title":"New BaseModel"},{"location":"api/models/new-basemodel/#modelsnewbasemodel","text":"","title":"models.newbasemodel"},{"location":"api/models/new-basemodel/#newbasemodel-objects","text":"1 class NewBaseModel ( pydantic . BaseModel , ModelTableProxy , metaclass = ModelMetaclass ) Main base class of ormar Model. Inherits from pydantic BaseModel and has all mixins combined in ModelTableProxy. Constructed with ModelMetaclass which in turn also inherits pydantic metaclass. Abstracts away all internals and helper functions, so final Model class has only the logic concerned with database connection and data persistance.","title":"NewBaseModel Objects"},{"location":"api/models/new-basemodel/#__init__","text":"1 | __init__ ( * args : Any , ** kwargs : Any ) -> None Initializer that creates a new ormar Model that is also pydantic Model at the same time. Passed keyword arguments can be only field names and their corresponding values as those will be passed to pydantic validation that will complain if extra params are passed. If relations are defined each relation is expanded and children models are also initialized and validated. Relation from both sides is registered so you can access related models from both sides. Json fields are automatically loaded/dumped if needed. Models marked as abstract=True in internal Meta class cannot be initialized. Accepts also special pk_only flag that indicates that Model is constructed only with primary key value (so no other fields, it's a child model on other Model), that causes skipping the validation, that's the only case when the validation can be skipped. Accepts also special excluded parameter that contains a set of fields that should be explicitly set to None, as otherwise pydantic will try to populate them with their default values if default is set. Raises : ModelError : if abstract model is initialized, model has ForwardRefs that has not been updated or unknown field is passed Arguments : args (Any) : ignored args kwargs (Any) : keyword arguments - all fields values and some special params","title":"__init__"},{"location":"api/models/new-basemodel/#__setattr__","text":"1 | __setattr__ ( name : str , value : Any ) -> None Overwrites setattr in object to allow for special behaviour of certain params. Parameter \"pk\" is translated into actual primary key field name. Relations are expanded (child model constructed if needed) and registered on both ends of the relation. The related models are handled by RelationshipManager exposed at _orm param. Json fields converted if needed. Setting pk, foreign key value or any other field value sets Model save status to False. Setting a reverse relation or many to many relation does not as it does not modify the state of the model (but related model or through model). To short circuit all checks and expansions the set of attribute names present on each model is gathered into _quick_access_fields that is looked first and if field is in this set the object setattr is called directly. Arguments : name (str) : name of the attribute to set value (Any) : value of the attribute to set Returns : (None) : None","title":"__setattr__"},{"location":"api/models/new-basemodel/#__getattribute__","text":"1 | __getattribute__ ( item : str ) -> Any Because we need to overwrite getting the attribute by ormar instead of pydantic as well as returning related models and not the value stored on the model the getattribute needs to be used not getattr . It's used to access all attributes so it can be a big overhead that's why a number of short circuits is used. To short circuit all checks and expansions the set of attribute names present on each model is gathered into _quick_access_fields that is looked first and if field is in this set the object setattr is called directly. To avoid recursion object's getattribute is used to actually get the attribute value from the model after the checks. Even the function calls are constructed with objects functions. Parameter \"pk\" is translated into actual primary key field name. Relations are returned so the actual related model is returned and not current model's field. The related models are handled by RelationshipManager exposed at _orm param. Json fields are converted if needed. Arguments : item (str) : name of the attribute to retrieve Returns : (Any) : value of the attribute","title":"__getattribute__"},{"location":"api/models/new-basemodel/#_verify_model_can_be_initialized","text":"1 | _verify_model_can_be_initialized () -> None Raises exception if model is abstract or has ForwardRefs in relation fields. Returns : (None) : None","title":"_verify_model_can_be_initialized"},{"location":"api/models/new-basemodel/#_extract_related_model_instead_of_field","text":"1 | _extract_related_model_instead_of_field ( item : str ) -> Optional [ Union [ \"T\" , Sequence [ \"T\" ]]] Retrieves the related model/models from RelationshipManager. Arguments : item (str) : name of the relation Returns : (Optional[Union[Model, List[Model]]]) : related model, list of related models or None","title":"_extract_related_model_instead_of_field"},{"location":"api/models/new-basemodel/#__eq__","text":"1 | __eq__ ( other : object ) -> bool Compares other model to this model. when == is called. Arguments : other (object) : other model to compare Returns : (bool) : result of comparison","title":"__eq__"},{"location":"api/models/new-basemodel/#__same__","text":"1 | __same__ ( other : \"NewBaseModel\" ) -> bool Used by eq , compares other model to this model. Compares: * _orm_ids, * primary key values if it's set * dictionary of own fields (excluding relations) Arguments : other (NewBaseModel) : model to compare to Returns : (bool) : result of comparison","title":"__same__"},{"location":"api/models/new-basemodel/#get_name","text":"1 2 | @classmethod | get_name ( cls , lower : bool = True ) -> str Returns name of the Model class, by default lowercase. Arguments : lower (bool) : flag if name should be set to lowercase Returns : (str) : name of the model","title":"get_name"},{"location":"api/models/new-basemodel/#pk_column","text":"1 2 | @property | pk_column () -> sqlalchemy . Column Retrieves primary key sqlalchemy column from models Meta.table. Each model has to have primary key. Only one primary key column is allowed. Returns : (sqlalchemy.Column) : primary key sqlalchemy column","title":"pk_column"},{"location":"api/models/new-basemodel/#saved","text":"1 2 | @property | saved () -> bool Saved status of the model. Changed by setattr and loading from db","title":"saved"},{"location":"api/models/new-basemodel/#signals","text":"1 2 | @property | signals () -> \"SignalEmitter\" Exposes signals from model Meta","title":"signals"},{"location":"api/models/new-basemodel/#pk_type","text":"1 2 | @classmethod | pk_type ( cls ) -> Any Shortcut to models primary key field type","title":"pk_type"},{"location":"api/models/new-basemodel/#db_backend_name","text":"1 2 | @classmethod | db_backend_name ( cls ) -> str Shortcut to database dialect, cause some dialect require different treatment","title":"db_backend_name"},{"location":"api/models/new-basemodel/#remove","text":"1 | remove ( parent : \"T\" , name : str ) -> None Removes child from relation with given name in RelationshipManager","title":"remove"},{"location":"api/models/new-basemodel/#set_save_status","text":"1 | set_save_status ( status : bool ) -> None Sets value of the save status","title":"set_save_status"},{"location":"api/models/new-basemodel/#get_properties","text":"1 2 | @classmethod | get_properties ( cls , include : Union [ Set , Dict , None ], exclude : Union [ Set , Dict , None ]) -> Set [ str ] Returns a set of names of functions/fields decorated with @property_field decorator. They are added to dictionary when called directly and therefore also are present in fastapi responses. Arguments : include (Union[Set, Dict, None]) : fields to include exclude (Union[Set, Dict, None]) : fields to exclude Returns : (Set[str]) : set of property fields names","title":"get_properties"},{"location":"api/models/new-basemodel/#update_forward_refs","text":"1 2 | @classmethod | update_forward_refs ( cls , ** localns : Any ) -> None Processes fields that are ForwardRef and need to be evaluated into actual models. Expands relationships, register relation in alias manager and substitutes sqlalchemy columns with new ones with proper column type (null before). Populates Meta table of the Model which is left empty before. Sets self_reference flag on models that links to themselves. Calls the pydantic method to evaluate pydantic fields. Arguments : localns (Any) : local namespace Returns : (None) : None","title":"update_forward_refs"},{"location":"api/models/new-basemodel/#_get_related_not_excluded_fields","text":"1 | _get_related_not_excluded_fields ( include : Optional [ Dict ], exclude : Optional [ Dict ]) -> List Returns related field names applying on them include and exclude set. Arguments : include (Union[Set, Dict, None]) : fields to include exclude (Union[Set, Dict, None]) : fields to exclude Returns : (List of fields with relations that is not excluded) :","title":"_get_related_not_excluded_fields"},{"location":"api/models/new-basemodel/#_extract_nested_models_from_list","text":"1 2 | @staticmethod | _extract_nested_models_from_list ( models : MutableSequence , include : Union [ Set , Dict , None ], exclude : Union [ Set , Dict , None ]) -> List Converts list of models into list of dictionaries. Arguments : models (List) : List of models include (Union[Set, Dict, None]) : fields to include exclude (Union[Set, Dict, None]) : fields to exclude Returns : (List[Dict]) : list of models converted to dictionaries","title":"_extract_nested_models_from_list"},{"location":"api/models/new-basemodel/#_skip_ellipsis","text":"1 | _skip_ellipsis ( items : Union [ Set , Dict , None ], key : str ) -> Union [ Set , Dict , None ] Helper to traverse the include/exclude dictionaries. In dict() Ellipsis should be skipped as it indicates all fields required and not the actual set/dict with fields names. Arguments : items (Union[Set, Dict, None]) : current include/exclude value key (str) : key for nested relations to check Returns : (Union[Set, Dict, None]) : nested value of the items","title":"_skip_ellipsis"},{"location":"api/models/new-basemodel/#_extract_nested_models","text":"1 | _extract_nested_models ( nested : bool , dict_instance : Dict , include : Optional [ Dict ], exclude : Optional [ Dict ]) -> Dict Traverse nested models and converts them into dictionaries. Calls itself recursively if needed. Arguments : nested (bool) : flag if current instance is nested dict_instance (Dict) : current instance dict include (Optional[Dict]) : fields to include exclude (Optional[Dict]) : fields to exclude Returns : (Dict) : current model dict with child models converted to dictionaries","title":"_extract_nested_models"},{"location":"api/models/new-basemodel/#dict","text":"1 | dict ( * , include : Union [ Set , Dict ] = None , exclude : Union [ Set , Dict ] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , nested : bool = False ) -> \"DictStrAny\" Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Nested models are also parsed to dictionaries. Additionally fields decorated with @property_field are also added. Arguments : include (Union[Set, Dict, None]) : fields to include exclude (Union[Set, Dict, None]) : fields to exclude by_alias (bool) : flag to get values by alias - passed to pydantic skip_defaults (bool) : flag to not set values - passed to pydantic exclude_unset (bool) : flag to exclude not set values - passed to pydantic exclude_defaults (bool) : flag to exclude default values - passed to pydantic exclude_none (bool) : flag to exclude None values - passed to pydantic nested (bool) : flag if the current model is nested Returns : () :","title":"dict"},{"location":"api/models/new-basemodel/#update_from_dict","text":"1 | update_from_dict ( value_dict : Dict ) -> \"NewBaseModel\" Updates self with values of fields passed in the dictionary. Arguments : value_dict (Dict) : dictionary of fields names and values Returns : (NewBaseModel) : self","title":"update_from_dict"},{"location":"api/models/new-basemodel/#_convert_json","text":"1 | _convert_json ( column_name : str , value : Any , op : str ) -> Union [ str , Dict ] Converts value to/from json if needed (for Json columns). Arguments : column_name (str) : name of the field value (Any) : value fo the field op (str) : operator on json Returns : (Any) : converted value if needed, else original value","title":"_convert_json"},{"location":"api/models/new-basemodel/#_is_conversion_to_json_needed","text":"1 | _is_conversion_to_json_needed ( column_name : str ) -> bool Checks if given column name is related to JSON field. Arguments : column_name (str) : name of the field Returns : (bool) : result of the check","title":"_is_conversion_to_json_needed"},{"location":"api/models/new-basemodel/#_extract_own_model_fields","text":"1 | _extract_own_model_fields () -> Dict Returns a dictionary with field names and values for fields that are not relations fields (ForeignKey, ManyToMany etc.) Returns : (Dict) : dictionary of fields names and values.","title":"_extract_own_model_fields"},{"location":"api/models/new-basemodel/#_extract_model_db_fields","text":"1 | _extract_model_db_fields () -> Dict Returns a dictionary with field names and values for fields that are stored in current model's table. That includes own non-relational fields ang foreign key fields. Returns : (Dict) : dictionary of fields names and values.","title":"_extract_model_db_fields"},{"location":"api/models/new-basemodel/#get_relation_model_id","text":"1 | get_relation_model_id ( target_field : Type [ \"BaseField\" ]) -> Optional [ int ] Returns an id of the relation side model to use in prefetch query. Arguments : target_field (Type[\"BaseField\"]) : field with relation definition Returns : (Optional[int]) : value of pk if set","title":"get_relation_model_id"},{"location":"api/models/helpers/models/","text":"models.helpers.models is_field_an_forward_ref 1 is_field_an_forward_ref ( field : Type [ \"BaseField\" ]) -> bool Checks if field is a relation field and whether any of the referenced models are ForwardRefs that needs to be updated before proceeding. Arguments : field (Type[BaseField]) : model field to verify Returns : (bool) : result of the check populate_default_options_values 1 populate_default_options_values ( new_model : Type [ \"Model\" ], model_fields : Dict ) -> None Sets all optional Meta values to it's defaults and set model_fields that were already previously extracted. Here should live all options that are not overwritten/set for all models. Current options are: * constraints = [] * abstract = False Arguments : new_model (Model class) : newly constructed Model model_fields (Union[Dict[str, type], Dict]) : extract_annotations_and_default_vals 1 extract_annotations_and_default_vals ( attrs : Dict ) -> Tuple [ Dict , Dict ] Extracts annotations from class namespace dict and triggers extraction of ormar model_fields. Arguments : attrs (Dict) : namespace of the class created Returns : (Tuple[Dict, Dict]) : namespace of the class updated, dict of extracted model_fields validate_related_names_in_relations 1 validate_related_names_in_relations ( model_fields : Dict , new_model : Type [ \"Model\" ]) -> None Performs a validation of relation_names in relation fields. If multiple fields are leading to the same related model only one can have empty related_name param (populated by default as model.name.lower()+'s'). Also related_names have to be unique for given related model. Raises : ModelDefinitionError : if validation of related_names fail Arguments : model_fields (Dict[str, ormar.Field]) : dictionary of declared ormar model fields new_model (Model class) : group_related_list 1 group_related_list ( list_ : List ) -> Dict Translates the list of related strings into a dictionary. That way nested models are grouped to traverse them in a right order and to avoid repetition. Sample: [\"people__houses\", \"people__cars__models\", \"people__cars__colors\"] will become: {'people': {'houses': [], 'cars': ['models', 'colors']}} Result dictionary is sorted by length of the values and by key Arguments : list_ (List[str]) : list of related models used in select related Returns : (Dict[str, List]) : list converted to dictionary to avoid repetition and group nested models","title":"Models"},{"location":"api/models/helpers/models/#modelshelpersmodels","text":"","title":"models.helpers.models"},{"location":"api/models/helpers/models/#is_field_an_forward_ref","text":"1 is_field_an_forward_ref ( field : Type [ \"BaseField\" ]) -> bool Checks if field is a relation field and whether any of the referenced models are ForwardRefs that needs to be updated before proceeding. Arguments : field (Type[BaseField]) : model field to verify Returns : (bool) : result of the check","title":"is_field_an_forward_ref"},{"location":"api/models/helpers/models/#populate_default_options_values","text":"1 populate_default_options_values ( new_model : Type [ \"Model\" ], model_fields : Dict ) -> None Sets all optional Meta values to it's defaults and set model_fields that were already previously extracted. Here should live all options that are not overwritten/set for all models. Current options are: * constraints = [] * abstract = False Arguments : new_model (Model class) : newly constructed Model model_fields (Union[Dict[str, type], Dict]) :","title":"populate_default_options_values"},{"location":"api/models/helpers/models/#extract_annotations_and_default_vals","text":"1 extract_annotations_and_default_vals ( attrs : Dict ) -> Tuple [ Dict , Dict ] Extracts annotations from class namespace dict and triggers extraction of ormar model_fields. Arguments : attrs (Dict) : namespace of the class created Returns : (Tuple[Dict, Dict]) : namespace of the class updated, dict of extracted model_fields","title":"extract_annotations_and_default_vals"},{"location":"api/models/helpers/models/#validate_related_names_in_relations","text":"1 validate_related_names_in_relations ( model_fields : Dict , new_model : Type [ \"Model\" ]) -> None Performs a validation of relation_names in relation fields. If multiple fields are leading to the same related model only one can have empty related_name param (populated by default as model.name.lower()+'s'). Also related_names have to be unique for given related model. Raises : ModelDefinitionError : if validation of related_names fail Arguments : model_fields (Dict[str, ormar.Field]) : dictionary of declared ormar model fields new_model (Model class) :","title":"validate_related_names_in_relations"},{"location":"api/models/helpers/models/#group_related_list","text":"1 group_related_list ( list_ : List ) -> Dict Translates the list of related strings into a dictionary. That way nested models are grouped to traverse them in a right order and to avoid repetition. Sample: [\"people__houses\", \"people__cars__models\", \"people__cars__colors\"] will become: {'people': {'houses': [], 'cars': ['models', 'colors']}} Result dictionary is sorted by length of the values and by key Arguments : list_ (List[str]) : list of related models used in select related Returns : (Dict[str, List]) : list converted to dictionary to avoid repetition and group nested models","title":"group_related_list"},{"location":"api/models/helpers/pydantic/","text":"models.helpers.pydantic create_pydantic_field 1 create_pydantic_field ( field_name : str , model : Type [ \"Model\" ], model_field : Type [ ManyToManyField ]) -> None Registers pydantic field on through model that leads to passed model and is registered as field_name passed. Through model is fetched from through attributed on passed model_field. Arguments : field_name (str) : field name to register model (Model class) : type of field to register model_field (ManyToManyField class) : relation field from which through model is extracted get_pydantic_field 1 get_pydantic_field ( field_name : str , model : Type [ \"Model\" ]) -> \"ModelField\" Extracts field type and if it's required from Model model_fields by passed field_name. Returns a pydantic field with type of field_name field type. Arguments : field_name (str) : field name to fetch from Model and name of pydantic field model (Model class) : type of field to register Returns : (pydantic.ModelField) : newly created pydantic field populate_default_pydantic_field_value 1 populate_default_pydantic_field_value ( ormar_field : Type [ BaseField ], field_name : str , attrs : dict ) -> dict Grabs current value of the ormar Field in class namespace (so the default_value declared on ormar model if set) and converts it to pydantic.FieldInfo that pydantic is able to extract later. On FieldInfo there are saved all needed params like max_length of the string and other constraints that pydantic can use to build it's own field validation used by ormar. Arguments : ormar_field (ormar Field) : field to convert field_name (str) : field to convert name attrs (Dict) : current class namespace Returns : (Dict) : updated namespace dict populate_pydantic_default_values 1 populate_pydantic_default_values ( attrs : Dict ) -> Tuple [ Dict , Dict ] Extracts ormar fields from annotations (deprecated) and from namespace dictionary of the class. Fields declared on model are all subclasses of the BaseField class. Trigger conversion of ormar field into pydantic FieldInfo, which has all needed paramaters saved. Overwrites the annotations of ormar fields to corresponding types declared on ormar fields (constructed dynamically for relations). Those annotations are later used by pydantic to construct it's own fields. Arguments : attrs (Dict) : current class namespace Returns : (Tuple[Dict, Dict]) : namespace of the class updated, dict of extracted model_fields get_pydantic_base_orm_config 1 get_pydantic_base_orm_config () -> Type [ BaseConfig ] Returns empty pydantic Config with orm_mode set to True. Returns : (pydantic Config) : empty default config with orm_mode set. get_potential_fields 1 get_potential_fields ( attrs : Dict ) -> Dict Gets all the fields in current class namespace that are Fields. Arguments : attrs (Dict) : current class namespace Returns : (Dict) : extracted fields that are ormar Fields","title":"Pydantic"},{"location":"api/models/helpers/pydantic/#modelshelperspydantic","text":"","title":"models.helpers.pydantic"},{"location":"api/models/helpers/pydantic/#create_pydantic_field","text":"1 create_pydantic_field ( field_name : str , model : Type [ \"Model\" ], model_field : Type [ ManyToManyField ]) -> None Registers pydantic field on through model that leads to passed model and is registered as field_name passed. Through model is fetched from through attributed on passed model_field. Arguments : field_name (str) : field name to register model (Model class) : type of field to register model_field (ManyToManyField class) : relation field from which through model is extracted","title":"create_pydantic_field"},{"location":"api/models/helpers/pydantic/#get_pydantic_field","text":"1 get_pydantic_field ( field_name : str , model : Type [ \"Model\" ]) -> \"ModelField\" Extracts field type and if it's required from Model model_fields by passed field_name. Returns a pydantic field with type of field_name field type. Arguments : field_name (str) : field name to fetch from Model and name of pydantic field model (Model class) : type of field to register Returns : (pydantic.ModelField) : newly created pydantic field","title":"get_pydantic_field"},{"location":"api/models/helpers/pydantic/#populate_default_pydantic_field_value","text":"1 populate_default_pydantic_field_value ( ormar_field : Type [ BaseField ], field_name : str , attrs : dict ) -> dict Grabs current value of the ormar Field in class namespace (so the default_value declared on ormar model if set) and converts it to pydantic.FieldInfo that pydantic is able to extract later. On FieldInfo there are saved all needed params like max_length of the string and other constraints that pydantic can use to build it's own field validation used by ormar. Arguments : ormar_field (ormar Field) : field to convert field_name (str) : field to convert name attrs (Dict) : current class namespace Returns : (Dict) : updated namespace dict","title":"populate_default_pydantic_field_value"},{"location":"api/models/helpers/pydantic/#populate_pydantic_default_values","text":"1 populate_pydantic_default_values ( attrs : Dict ) -> Tuple [ Dict , Dict ] Extracts ormar fields from annotations (deprecated) and from namespace dictionary of the class. Fields declared on model are all subclasses of the BaseField class. Trigger conversion of ormar field into pydantic FieldInfo, which has all needed paramaters saved. Overwrites the annotations of ormar fields to corresponding types declared on ormar fields (constructed dynamically for relations). Those annotations are later used by pydantic to construct it's own fields. Arguments : attrs (Dict) : current class namespace Returns : (Tuple[Dict, Dict]) : namespace of the class updated, dict of extracted model_fields","title":"populate_pydantic_default_values"},{"location":"api/models/helpers/pydantic/#get_pydantic_base_orm_config","text":"1 get_pydantic_base_orm_config () -> Type [ BaseConfig ] Returns empty pydantic Config with orm_mode set to True. Returns : (pydantic Config) : empty default config with orm_mode set.","title":"get_pydantic_base_orm_config"},{"location":"api/models/helpers/pydantic/#get_potential_fields","text":"1 get_potential_fields ( attrs : Dict ) -> Dict Gets all the fields in current class namespace that are Fields. Arguments : attrs (Dict) : current class namespace Returns : (Dict) : extracted fields that are ormar Fields","title":"get_potential_fields"},{"location":"api/models/helpers/relations/","text":"models.helpers.relations register_relation_on_build 1 register_relation_on_build ( field : Type [ \"ForeignKeyField\" ]) -> None Registers ForeignKey relation in alias_manager to set a table_prefix. Registration include also reverse relation side to be able to join both sides. Relation is registered by model name and relation field name to allow for multiple relations between two Models that needs to have different aliases for proper sql joins. Arguments : field (ForeignKey class) : relation field register_many_to_many_relation_on_build 1 register_many_to_many_relation_on_build ( field : Type [ ManyToManyField ]) -> None Registers connection between through model and both sides of the m2m relation. Registration include also reverse relation side to be able to join both sides. Relation is registered by model name and relation field name to allow for multiple relations between two Models that needs to have different aliases for proper sql joins. By default relation name is a model.name.lower(). Arguments : field (ManyToManyField class) : relation field expand_reverse_relationship 1 expand_reverse_relationship ( model_field : Type [ \"ForeignKeyField\" ]) -> None If the reverse relation has not been set before it's set here. Arguments : model_field () : Returns : (None) : None expand_reverse_relationships 1 expand_reverse_relationships ( model : Type [ \"Model\" ]) -> None Iterates through model_fields of given model and verifies if all reverse relation have been populated on related models. If the reverse relation has not been set before it's set here. Arguments : model (Model class) : model on which relation should be checked and registered register_reverse_model_fields 1 register_reverse_model_fields ( model_field : Type [ \"ForeignKeyField\" ]) -> None Registers reverse ForeignKey field on related model. By default it's name.lower()+'s' of the model on which relation is defined. But if the related_model name is provided it's registered with that name. Autogenerated reverse fields also set related_name to the original field name. Arguments : model_field (relation Field) : original relation ForeignKey field register_relation_in_alias_manager 1 register_relation_in_alias_manager ( field : Type [ ForeignKeyField ]) -> None Registers the relation (and reverse relation) in alias manager. The m2m relations require registration of through model between actual end models of the relation. Delegates the actual registration to: m2m - register_many_to_many_relation_on_build fk - register_relation_on_build Arguments : field (ForeignKey or ManyToManyField class) : relation field verify_related_name_dont_duplicate 1 verify_related_name_dont_duplicate ( related_name : str , model_field : Type [ \"ForeignKeyField\" ]) -> None Verifies whether the used related_name (regardless of the fact if user defined or auto generated) is already used on related model, but is connected with other model than the one that we connect right now. Raises : ModelDefinitionError : if name is already used but lead to different related model Arguments : related_name () : model_field (relation Field) : original relation ForeignKey field Returns : (None) : None reverse_field_not_already_registered 1 reverse_field_not_already_registered ( model_field : Type [ \"ForeignKeyField\" ]) -> bool Checks if child is already registered in parents pydantic fields. Raises : ModelDefinitionError : if related name is already used but lead to different related model Arguments : model_field (relation Field) : original relation ForeignKey field Returns : (bool) : result of the check","title":"Relations"},{"location":"api/models/helpers/relations/#modelshelpersrelations","text":"","title":"models.helpers.relations"},{"location":"api/models/helpers/relations/#register_relation_on_build","text":"1 register_relation_on_build ( field : Type [ \"ForeignKeyField\" ]) -> None Registers ForeignKey relation in alias_manager to set a table_prefix. Registration include also reverse relation side to be able to join both sides. Relation is registered by model name and relation field name to allow for multiple relations between two Models that needs to have different aliases for proper sql joins. Arguments : field (ForeignKey class) : relation field","title":"register_relation_on_build"},{"location":"api/models/helpers/relations/#register_many_to_many_relation_on_build","text":"1 register_many_to_many_relation_on_build ( field : Type [ ManyToManyField ]) -> None Registers connection between through model and both sides of the m2m relation. Registration include also reverse relation side to be able to join both sides. Relation is registered by model name and relation field name to allow for multiple relations between two Models that needs to have different aliases for proper sql joins. By default relation name is a model.name.lower(). Arguments : field (ManyToManyField class) : relation field","title":"register_many_to_many_relation_on_build"},{"location":"api/models/helpers/relations/#expand_reverse_relationship","text":"1 expand_reverse_relationship ( model_field : Type [ \"ForeignKeyField\" ]) -> None If the reverse relation has not been set before it's set here. Arguments : model_field () : Returns : (None) : None","title":"expand_reverse_relationship"},{"location":"api/models/helpers/relations/#expand_reverse_relationships","text":"1 expand_reverse_relationships ( model : Type [ \"Model\" ]) -> None Iterates through model_fields of given model and verifies if all reverse relation have been populated on related models. If the reverse relation has not been set before it's set here. Arguments : model (Model class) : model on which relation should be checked and registered","title":"expand_reverse_relationships"},{"location":"api/models/helpers/relations/#register_reverse_model_fields","text":"1 register_reverse_model_fields ( model_field : Type [ \"ForeignKeyField\" ]) -> None Registers reverse ForeignKey field on related model. By default it's name.lower()+'s' of the model on which relation is defined. But if the related_model name is provided it's registered with that name. Autogenerated reverse fields also set related_name to the original field name. Arguments : model_field (relation Field) : original relation ForeignKey field","title":"register_reverse_model_fields"},{"location":"api/models/helpers/relations/#register_relation_in_alias_manager","text":"1 register_relation_in_alias_manager ( field : Type [ ForeignKeyField ]) -> None Registers the relation (and reverse relation) in alias manager. The m2m relations require registration of through model between actual end models of the relation. Delegates the actual registration to: m2m - register_many_to_many_relation_on_build fk - register_relation_on_build Arguments : field (ForeignKey or ManyToManyField class) : relation field","title":"register_relation_in_alias_manager"},{"location":"api/models/helpers/relations/#verify_related_name_dont_duplicate","text":"1 verify_related_name_dont_duplicate ( related_name : str , model_field : Type [ \"ForeignKeyField\" ]) -> None Verifies whether the used related_name (regardless of the fact if user defined or auto generated) is already used on related model, but is connected with other model than the one that we connect right now. Raises : ModelDefinitionError : if name is already used but lead to different related model Arguments : related_name () : model_field (relation Field) : original relation ForeignKey field Returns : (None) : None","title":"verify_related_name_dont_duplicate"},{"location":"api/models/helpers/relations/#reverse_field_not_already_registered","text":"1 reverse_field_not_already_registered ( model_field : Type [ \"ForeignKeyField\" ]) -> bool Checks if child is already registered in parents pydantic fields. Raises : ModelDefinitionError : if related name is already used but lead to different related model Arguments : model_field (relation Field) : original relation ForeignKey field Returns : (bool) : result of the check","title":"reverse_field_not_already_registered"},{"location":"api/models/helpers/sqlalchemy/","text":"models.helpers.sqlalchemy adjust_through_many_to_many_model 1 adjust_through_many_to_many_model ( model_field : Type [ ManyToManyField ]) -> None Registers m2m relation on through model. Sets ormar.ForeignKey from through model to both child and parent models. Sets sqlalchemy.ForeignKey to both child and parent models. Sets pydantic fields with child and parent model types. Arguments : model_field (ManyToManyField) : relation field defined in parent model create_and_append_m2m_fk 1 create_and_append_m2m_fk ( model : Type [ \"Model\" ], model_field : Type [ ManyToManyField ], field_name : str ) -> None Registers sqlalchemy Column with sqlalchemy.ForeignKey leading to the model. Newly created field is added to m2m relation through model Meta columns and table. Arguments : field_name (str) : name of the column to create model (Model class) : Model class to which FK should be created model_field (ManyToManyField field) : field with ManyToMany relation check_pk_column_validity 1 check_pk_column_validity ( field_name : str , field : BaseField , pkname : Optional [ str ]) -> Optional [ str ] Receives the field marked as primary key and verifies if the pkname was not already set (only one allowed per model) and if field is not marked as pydantic_only as it needs to be a database field. Raises : ModelDefintionError : if pkname already set or field is pydantic_only Arguments : field_name (str) : name of field field (BaseField) : ormar.Field pkname (Optional[str]) : already set pkname Returns : (str) : name of the field that should be set as pkname sqlalchemy_columns_from_model_fields 1 sqlalchemy_columns_from_model_fields ( model_fields : Dict , new_model : Type [ \"Model\" ]) -> Tuple [ Optional [ str ], List [ sqlalchemy . Column ]] Iterates over declared on Model model fields and extracts fields that should be treated as database fields. If the model is empty it sets mandatory id field as primary key (used in through models in m2m relations). Triggers a validation of relation_names in relation fields. If multiple fields are leading to the same related model only one can have empty related_name param. Also related_names have to be unique. Trigger validation of primary_key - only one and required pk can be set, cannot be pydantic_only. Append fields to columns if it's not pydantic_only, virtual ForeignKey or ManyToMany field. Sets owner on each model_field as reference to newly created Model. Raises : ModelDefinitionError : if validation of related_names fail, or pkname validation fails. Arguments : model_fields (Dict[str, ormar.Field]) : dictionary of declared ormar model fields new_model (Model class) : Returns : (Tuple[Optional[str], List[sqlalchemy.Column]]) : pkname, list of sqlalchemy columns populate_meta_tablename_columns_and_pk 1 populate_meta_tablename_columns_and_pk ( name : str , new_model : Type [ \"Model\" ]) -> Type [ \"Model\" ] Sets Model tablename if it's not already set in Meta. Default tablename if not present is class name lower + s (i.e. Bed becomes -> beds) Checks if Model's Meta have pkname and columns set. If not calls the sqlalchemy_columns_from_model_fields to populate columns from ormar.fields definitions. Raises : ModelDefinitionError : if pkname is not present raises ModelDefinitionError. Each model has to have pk. Arguments : name (str) : name of the current Model new_model (ormar.models.metaclass.ModelMetaclass) : currently constructed Model Returns : (ormar.models.metaclass.ModelMetaclass) : Model with populated pkname and columns in Meta check_for_null_type_columns_from_forward_refs 1 check_for_null_type_columns_from_forward_refs ( meta : \"ModelMeta\" ) -> bool Check is any column is of NUllType() meaning it's empty column from ForwardRef Arguments : meta (Model class Meta) : Meta class of the Model without sqlalchemy table constructed Returns : (bool) : result of the check populate_meta_sqlalchemy_table_if_required 1 populate_meta_sqlalchemy_table_if_required ( meta : \"ModelMeta\" ) -> None Constructs sqlalchemy table out of columns and parameters set on Meta class. It populates name, metadata, columns and constraints. Arguments : meta (Model class Meta) : Meta class of the Model without sqlalchemy table constructed Returns : (Model class) : class with populated Meta.table update_column_definition 1 update_column_definition ( model : Union [ Type [ \"Model\" ], Type [ \"NewBaseModel\" ]], field : Type [ ForeignKeyField ]) -> None Updates a column with a new type column based on updated parameters in FK fields. Arguments : model (Type[\"Model\"]) : model on which columns needs to be updated field (Type[ForeignKeyField]) : field with column definition that requires update Returns : (None) : None","title":"Sqlalchemy"},{"location":"api/models/helpers/sqlalchemy/#modelshelperssqlalchemy","text":"","title":"models.helpers.sqlalchemy"},{"location":"api/models/helpers/sqlalchemy/#adjust_through_many_to_many_model","text":"1 adjust_through_many_to_many_model ( model_field : Type [ ManyToManyField ]) -> None Registers m2m relation on through model. Sets ormar.ForeignKey from through model to both child and parent models. Sets sqlalchemy.ForeignKey to both child and parent models. Sets pydantic fields with child and parent model types. Arguments : model_field (ManyToManyField) : relation field defined in parent model","title":"adjust_through_many_to_many_model"},{"location":"api/models/helpers/sqlalchemy/#create_and_append_m2m_fk","text":"1 create_and_append_m2m_fk ( model : Type [ \"Model\" ], model_field : Type [ ManyToManyField ], field_name : str ) -> None Registers sqlalchemy Column with sqlalchemy.ForeignKey leading to the model. Newly created field is added to m2m relation through model Meta columns and table. Arguments : field_name (str) : name of the column to create model (Model class) : Model class to which FK should be created model_field (ManyToManyField field) : field with ManyToMany relation","title":"create_and_append_m2m_fk"},{"location":"api/models/helpers/sqlalchemy/#check_pk_column_validity","text":"1 check_pk_column_validity ( field_name : str , field : BaseField , pkname : Optional [ str ]) -> Optional [ str ] Receives the field marked as primary key and verifies if the pkname was not already set (only one allowed per model) and if field is not marked as pydantic_only as it needs to be a database field. Raises : ModelDefintionError : if pkname already set or field is pydantic_only Arguments : field_name (str) : name of field field (BaseField) : ormar.Field pkname (Optional[str]) : already set pkname Returns : (str) : name of the field that should be set as pkname","title":"check_pk_column_validity"},{"location":"api/models/helpers/sqlalchemy/#sqlalchemy_columns_from_model_fields","text":"1 sqlalchemy_columns_from_model_fields ( model_fields : Dict , new_model : Type [ \"Model\" ]) -> Tuple [ Optional [ str ], List [ sqlalchemy . Column ]] Iterates over declared on Model model fields and extracts fields that should be treated as database fields. If the model is empty it sets mandatory id field as primary key (used in through models in m2m relations). Triggers a validation of relation_names in relation fields. If multiple fields are leading to the same related model only one can have empty related_name param. Also related_names have to be unique. Trigger validation of primary_key - only one and required pk can be set, cannot be pydantic_only. Append fields to columns if it's not pydantic_only, virtual ForeignKey or ManyToMany field. Sets owner on each model_field as reference to newly created Model. Raises : ModelDefinitionError : if validation of related_names fail, or pkname validation fails. Arguments : model_fields (Dict[str, ormar.Field]) : dictionary of declared ormar model fields new_model (Model class) : Returns : (Tuple[Optional[str], List[sqlalchemy.Column]]) : pkname, list of sqlalchemy columns","title":"sqlalchemy_columns_from_model_fields"},{"location":"api/models/helpers/sqlalchemy/#populate_meta_tablename_columns_and_pk","text":"1 populate_meta_tablename_columns_and_pk ( name : str , new_model : Type [ \"Model\" ]) -> Type [ \"Model\" ] Sets Model tablename if it's not already set in Meta. Default tablename if not present is class name lower + s (i.e. Bed becomes -> beds) Checks if Model's Meta have pkname and columns set. If not calls the sqlalchemy_columns_from_model_fields to populate columns from ormar.fields definitions. Raises : ModelDefinitionError : if pkname is not present raises ModelDefinitionError. Each model has to have pk. Arguments : name (str) : name of the current Model new_model (ormar.models.metaclass.ModelMetaclass) : currently constructed Model Returns : (ormar.models.metaclass.ModelMetaclass) : Model with populated pkname and columns in Meta","title":"populate_meta_tablename_columns_and_pk"},{"location":"api/models/helpers/sqlalchemy/#check_for_null_type_columns_from_forward_refs","text":"1 check_for_null_type_columns_from_forward_refs ( meta : \"ModelMeta\" ) -> bool Check is any column is of NUllType() meaning it's empty column from ForwardRef Arguments : meta (Model class Meta) : Meta class of the Model without sqlalchemy table constructed Returns : (bool) : result of the check","title":"check_for_null_type_columns_from_forward_refs"},{"location":"api/models/helpers/sqlalchemy/#populate_meta_sqlalchemy_table_if_required","text":"1 populate_meta_sqlalchemy_table_if_required ( meta : \"ModelMeta\" ) -> None Constructs sqlalchemy table out of columns and parameters set on Meta class. It populates name, metadata, columns and constraints. Arguments : meta (Model class Meta) : Meta class of the Model without sqlalchemy table constructed Returns : (Model class) : class with populated Meta.table","title":"populate_meta_sqlalchemy_table_if_required"},{"location":"api/models/helpers/sqlalchemy/#update_column_definition","text":"1 update_column_definition ( model : Union [ Type [ \"Model\" ], Type [ \"NewBaseModel\" ]], field : Type [ ForeignKeyField ]) -> None Updates a column with a new type column based on updated parameters in FK fields. Arguments : model (Type[\"Model\"]) : model on which columns needs to be updated field (Type[ForeignKeyField]) : field with column definition that requires update Returns : (None) : None","title":"update_column_definition"},{"location":"api/models/mixins/alias-mixin/","text":"models.mixins.alias_mixin AliasMixin Objects 1 class AliasMixin () Used to translate field names into database column names. get_column_alias 1 2 | @classmethod | get_column_alias ( cls , field_name : str ) -> str Returns db alias (column name in db) for given ormar field. For fields without alias field name is returned. Arguments : field_name (str) : name of the field to get alias from Returns : (str) : alias (db name) if set, otherwise passed name get_column_name_from_alias 1 2 | @classmethod | get_column_name_from_alias ( cls , alias : str ) -> str Returns ormar field name for given db alias (column name in db). If field do not have alias it's returned as is. Arguments : alias (str) : Returns : (str) : field name if set, otherwise passed alias (db name) translate_columns_to_aliases 1 2 | @classmethod | translate_columns_to_aliases ( cls , new_kwargs : Dict ) -> Dict Translates dictionary of model fields changing field names into aliases. If field has no alias the field name remains intact. Only fields present in the dictionary are translated. Arguments : new_kwargs (Dict) : dict with fields names and their values Returns : (Dict) : dict with aliases and their values translate_aliases_to_columns 1 2 | @classmethod | translate_aliases_to_columns ( cls , new_kwargs : Dict ) -> Dict Translates dictionary of model fields changing aliases into field names. If field has no alias the alias is already a field name. Only fields present in the dictionary are translated. Arguments : new_kwargs (Dict) : dict with aliases and their values Returns : (Dict) : dict with fields names and their values","title":"Alias Mixin"},{"location":"api/models/mixins/alias-mixin/#modelsmixinsalias_mixin","text":"","title":"models.mixins.alias_mixin"},{"location":"api/models/mixins/alias-mixin/#aliasmixin-objects","text":"1 class AliasMixin () Used to translate field names into database column names.","title":"AliasMixin Objects"},{"location":"api/models/mixins/alias-mixin/#get_column_alias","text":"1 2 | @classmethod | get_column_alias ( cls , field_name : str ) -> str Returns db alias (column name in db) for given ormar field. For fields without alias field name is returned. Arguments : field_name (str) : name of the field to get alias from Returns : (str) : alias (db name) if set, otherwise passed name","title":"get_column_alias"},{"location":"api/models/mixins/alias-mixin/#get_column_name_from_alias","text":"1 2 | @classmethod | get_column_name_from_alias ( cls , alias : str ) -> str Returns ormar field name for given db alias (column name in db). If field do not have alias it's returned as is. Arguments : alias (str) : Returns : (str) : field name if set, otherwise passed alias (db name)","title":"get_column_name_from_alias"},{"location":"api/models/mixins/alias-mixin/#translate_columns_to_aliases","text":"1 2 | @classmethod | translate_columns_to_aliases ( cls , new_kwargs : Dict ) -> Dict Translates dictionary of model fields changing field names into aliases. If field has no alias the field name remains intact. Only fields present in the dictionary are translated. Arguments : new_kwargs (Dict) : dict with fields names and their values Returns : (Dict) : dict with aliases and their values","title":"translate_columns_to_aliases"},{"location":"api/models/mixins/alias-mixin/#translate_aliases_to_columns","text":"1 2 | @classmethod | translate_aliases_to_columns ( cls , new_kwargs : Dict ) -> Dict Translates dictionary of model fields changing aliases into field names. If field has no alias the alias is already a field name. Only fields present in the dictionary are translated. Arguments : new_kwargs (Dict) : dict with aliases and their values Returns : (Dict) : dict with fields names and their values","title":"translate_aliases_to_columns"},{"location":"api/models/mixins/excludable-mixin/","text":"models.mixins.excludable_mixin ExcludableMixin Objects 1 class ExcludableMixin ( RelationMixin ) Used to include/exclude given set of fields on models during load and dict() calls. get_child 1 2 | @staticmethod | get_child ( items : Union [ Set , Dict , None ], key : str = None ) -> Union [ Set , Dict , None ] Used to get nested dictionaries keys if they exists otherwise returns passed items. Arguments : items (Union[Set, Dict, None]) : bag of items to include or exclude key (str) : name of the child to extract Returns : (Union[Set, Dict, None]) : child extracted from items if exists get_excluded 1 2 | @staticmethod | get_excluded ( exclude : Union [ Set , Dict , None ], key : str = None ) -> Union [ Set , Dict , None ] Proxy to ExcludableMixin.get_child for exclusions. Arguments : exclude (Union[Set, Dict, None]) : bag of items to exclude key (str) : name of the child to extract Returns : (Union[Set, Dict, None]) : child extracted from items if exists get_included 1 2 | @staticmethod | get_included ( include : Union [ Set , Dict , None ], key : str = None ) -> Union [ Set , Dict , None ] Proxy to ExcludableMixin.get_child for inclusions. Arguments : include (Union[Set, Dict, None]) : bag of items to include key (str) : name of the child to extract Returns : (Union[Set, Dict, None]) : child extracted from items if exists is_excluded 1 2 | @staticmethod | is_excluded ( exclude : Union [ Set , Dict , None ], key : str = None ) -> bool Checks if given key should be excluded on model/ dict. Arguments : exclude (Union[Set, Dict, None]) : bag of items to exclude key (str) : name of the child to extract Returns : (Union[Set, Dict, None]) : child extracted from items if exists is_included 1 2 | @staticmethod | is_included ( include : Union [ Set , Dict , None ], key : str = None ) -> bool Checks if given key should be included on model/ dict. Arguments : include (Union[Set, Dict, None]) : bag of items to include key (str) : name of the child to extract Returns : (Union[Set, Dict, None]) : child extracted from items if exists _populate_pk_column 1 2 | @staticmethod | _populate_pk_column ( model : Type [ \"Model\" ], columns : List [ str ], use_alias : bool = False ) -> List [ str ] Adds primary key column/alias (depends on use_alias flag) to list of column names that are selected. Arguments : model (Type[\"Model\"]) : model on columns are selected columns (List[str]) : list of columns names use_alias (bool) : flag to set if aliases or field names should be used Returns : (List[str]) : list of columns names with pk column in it own_table_columns 1 2 | @classmethod | own_table_columns ( cls , model : Type [ \"Model\" ], fields : Optional [ Union [ Set , Dict ]], exclude_fields : Optional [ Union [ Set , Dict ]], use_alias : bool = False ) -> List [ str ] Returns list of aliases or field names for given model. Aliases/names switch is use_alias flag. If provided only fields included in fields will be returned. If provided fields in exclude_fields will be excluded in return. Primary key field is always added and cannot be excluded (will be added anyway). Arguments : model (Type[\"Model\"]) : model on columns are selected fields (Optional[Union[Set, Dict]]) : set/dict of fields to include exclude_fields (Optional[Union[Set, Dict]]) : set/dict of fields to exclude use_alias (bool) : flag if aliases or field names should be used Returns : (List[str]) : list of column field names or aliases _update_excluded_with_related_not_required 1 2 | @classmethod | _update_excluded_with_related_not_required ( cls , exclude : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" , None ], nested : bool = False ) -> Union [ Set , Dict ] Used during generation of the dict(). To avoid cyclical references and max recurrence limit nested models have to exclude related models that are not mandatory. For a main model (not nested) only nullable related field names are added to exclusion, for nested models all related models are excluded. Arguments : exclude (Union[Set, Dict, None]) : set/dict with fields to exclude nested (bool) : flag setting nested models (child of previous one, not main one) Returns : (Union[Set, Dict]) : set or dict with excluded fields added. get_names_to_exclude 1 2 | @classmethod | get_names_to_exclude ( cls , fields : Optional [ Union [ Dict , Set ]] = None , exclude_fields : Optional [ Union [ Dict , Set ]] = None ) -> Set Returns a set of models field names that should be explicitly excluded during model initialization. Those fields will be set to None to avoid ormar/pydantic setting default values on them. They should be returned as None in any case. Used in parsing data from database rows that construct Models by initializing them with dicts constructed from those db rows. Arguments : fields (Optional[Union[Set, Dict]]) : set/dict of fields to include exclude_fields (Optional[Union[Set, Dict]]) : set/dict of fields to exclude Returns : (Set) : set of field names that should be excluded","title":"Excludable Mixin"},{"location":"api/models/mixins/excludable-mixin/#modelsmixinsexcludable_mixin","text":"","title":"models.mixins.excludable_mixin"},{"location":"api/models/mixins/excludable-mixin/#excludablemixin-objects","text":"1 class ExcludableMixin ( RelationMixin ) Used to include/exclude given set of fields on models during load and dict() calls.","title":"ExcludableMixin Objects"},{"location":"api/models/mixins/excludable-mixin/#get_child","text":"1 2 | @staticmethod | get_child ( items : Union [ Set , Dict , None ], key : str = None ) -> Union [ Set , Dict , None ] Used to get nested dictionaries keys if they exists otherwise returns passed items. Arguments : items (Union[Set, Dict, None]) : bag of items to include or exclude key (str) : name of the child to extract Returns : (Union[Set, Dict, None]) : child extracted from items if exists","title":"get_child"},{"location":"api/models/mixins/excludable-mixin/#get_excluded","text":"1 2 | @staticmethod | get_excluded ( exclude : Union [ Set , Dict , None ], key : str = None ) -> Union [ Set , Dict , None ] Proxy to ExcludableMixin.get_child for exclusions. Arguments : exclude (Union[Set, Dict, None]) : bag of items to exclude key (str) : name of the child to extract Returns : (Union[Set, Dict, None]) : child extracted from items if exists","title":"get_excluded"},{"location":"api/models/mixins/excludable-mixin/#get_included","text":"1 2 | @staticmethod | get_included ( include : Union [ Set , Dict , None ], key : str = None ) -> Union [ Set , Dict , None ] Proxy to ExcludableMixin.get_child for inclusions. Arguments : include (Union[Set, Dict, None]) : bag of items to include key (str) : name of the child to extract Returns : (Union[Set, Dict, None]) : child extracted from items if exists","title":"get_included"},{"location":"api/models/mixins/excludable-mixin/#is_excluded","text":"1 2 | @staticmethod | is_excluded ( exclude : Union [ Set , Dict , None ], key : str = None ) -> bool Checks if given key should be excluded on model/ dict. Arguments : exclude (Union[Set, Dict, None]) : bag of items to exclude key (str) : name of the child to extract Returns : (Union[Set, Dict, None]) : child extracted from items if exists","title":"is_excluded"},{"location":"api/models/mixins/excludable-mixin/#is_included","text":"1 2 | @staticmethod | is_included ( include : Union [ Set , Dict , None ], key : str = None ) -> bool Checks if given key should be included on model/ dict. Arguments : include (Union[Set, Dict, None]) : bag of items to include key (str) : name of the child to extract Returns : (Union[Set, Dict, None]) : child extracted from items if exists","title":"is_included"},{"location":"api/models/mixins/excludable-mixin/#_populate_pk_column","text":"1 2 | @staticmethod | _populate_pk_column ( model : Type [ \"Model\" ], columns : List [ str ], use_alias : bool = False ) -> List [ str ] Adds primary key column/alias (depends on use_alias flag) to list of column names that are selected. Arguments : model (Type[\"Model\"]) : model on columns are selected columns (List[str]) : list of columns names use_alias (bool) : flag to set if aliases or field names should be used Returns : (List[str]) : list of columns names with pk column in it","title":"_populate_pk_column"},{"location":"api/models/mixins/excludable-mixin/#own_table_columns","text":"1 2 | @classmethod | own_table_columns ( cls , model : Type [ \"Model\" ], fields : Optional [ Union [ Set , Dict ]], exclude_fields : Optional [ Union [ Set , Dict ]], use_alias : bool = False ) -> List [ str ] Returns list of aliases or field names for given model. Aliases/names switch is use_alias flag. If provided only fields included in fields will be returned. If provided fields in exclude_fields will be excluded in return. Primary key field is always added and cannot be excluded (will be added anyway). Arguments : model (Type[\"Model\"]) : model on columns are selected fields (Optional[Union[Set, Dict]]) : set/dict of fields to include exclude_fields (Optional[Union[Set, Dict]]) : set/dict of fields to exclude use_alias (bool) : flag if aliases or field names should be used Returns : (List[str]) : list of column field names or aliases","title":"own_table_columns"},{"location":"api/models/mixins/excludable-mixin/#_update_excluded_with_related_not_required","text":"1 2 | @classmethod | _update_excluded_with_related_not_required ( cls , exclude : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" , None ], nested : bool = False ) -> Union [ Set , Dict ] Used during generation of the dict(). To avoid cyclical references and max recurrence limit nested models have to exclude related models that are not mandatory. For a main model (not nested) only nullable related field names are added to exclusion, for nested models all related models are excluded. Arguments : exclude (Union[Set, Dict, None]) : set/dict with fields to exclude nested (bool) : flag setting nested models (child of previous one, not main one) Returns : (Union[Set, Dict]) : set or dict with excluded fields added.","title":"_update_excluded_with_related_not_required"},{"location":"api/models/mixins/excludable-mixin/#get_names_to_exclude","text":"1 2 | @classmethod | get_names_to_exclude ( cls , fields : Optional [ Union [ Dict , Set ]] = None , exclude_fields : Optional [ Union [ Dict , Set ]] = None ) -> Set Returns a set of models field names that should be explicitly excluded during model initialization. Those fields will be set to None to avoid ormar/pydantic setting default values on them. They should be returned as None in any case. Used in parsing data from database rows that construct Models by initializing them with dicts constructed from those db rows. Arguments : fields (Optional[Union[Set, Dict]]) : set/dict of fields to include exclude_fields (Optional[Union[Set, Dict]]) : set/dict of fields to exclude Returns : (Set) : set of field names that should be excluded","title":"get_names_to_exclude"},{"location":"api/models/mixins/merge-model-mixin/","text":"models.mixins.merge_mixin MergeModelMixin Objects 1 class MergeModelMixin () Used to merge models instances returned by database, but already initialized to ormar Models.keys Models can duplicate during joins when parent model has multiple child rows, in the end all parent (main) models should be unique. merge_instances_list 1 2 | @classmethod | merge_instances_list ( cls , result_rows : Sequence [ \"Model\" ]) -> Sequence [ \"Model\" ] Merges a list of models into list of unique models. Models can duplicate during joins when parent model has multiple child rows, in the end all parent (main) models should be unique. Arguments : result_rows (List[\"Model\"]) : list of already initialized Models with child models populated, each instance is one row in db and some models can duplicate Returns : (List[\"Model\"]) : list of merged models where each main model is unique merge_two_instances 1 2 | @classmethod | merge_two_instances ( cls , one : \"Model\" , other : \"Model\" ) -> \"Model\" Merges current (other) Model and previous one (one) and returns the current Model instance with data merged from previous one. If needed it's calling itself recurrently and merges also children models. Arguments : one (Model) : previous model instance other (Model) : current model instance Returns : (Model) : current Model instance with data merged from previous one.","title":"Merge Model Mixin"},{"location":"api/models/mixins/merge-model-mixin/#modelsmixinsmerge_mixin","text":"","title":"models.mixins.merge_mixin"},{"location":"api/models/mixins/merge-model-mixin/#mergemodelmixin-objects","text":"1 class MergeModelMixin () Used to merge models instances returned by database, but already initialized to ormar Models.keys Models can duplicate during joins when parent model has multiple child rows, in the end all parent (main) models should be unique.","title":"MergeModelMixin Objects"},{"location":"api/models/mixins/merge-model-mixin/#merge_instances_list","text":"1 2 | @classmethod | merge_instances_list ( cls , result_rows : Sequence [ \"Model\" ]) -> Sequence [ \"Model\" ] Merges a list of models into list of unique models. Models can duplicate during joins when parent model has multiple child rows, in the end all parent (main) models should be unique. Arguments : result_rows (List[\"Model\"]) : list of already initialized Models with child models populated, each instance is one row in db and some models can duplicate Returns : (List[\"Model\"]) : list of merged models where each main model is unique","title":"merge_instances_list"},{"location":"api/models/mixins/merge-model-mixin/#merge_two_instances","text":"1 2 | @classmethod | merge_two_instances ( cls , one : \"Model\" , other : \"Model\" ) -> \"Model\" Merges current (other) Model and previous one (one) and returns the current Model instance with data merged from previous one. If needed it's calling itself recurrently and merges also children models. Arguments : one (Model) : previous model instance other (Model) : current model instance Returns : (Model) : current Model instance with data merged from previous one.","title":"merge_two_instances"},{"location":"api/models/mixins/prefetch-query-mixin/","text":"models.mixins.prefetch_mixin PrefetchQueryMixin Objects 1 class PrefetchQueryMixin ( RelationMixin ) Used in PrefetchQuery to extract ids and names of models to prefetch. get_clause_target_and_filter_column_name 1 2 | @staticmethod | get_clause_target_and_filter_column_name ( parent_model : Type [ \"Model\" ], target_model : Type [ \"Model\" ], reverse : bool , related : str ) -> Tuple [ Type [ \"Model\" ], str ] Returns Model on which query clause should be performed and name of the column. Arguments : parent_model (Type[Model]) : related model that the relation lead to target_model (Type[Model]) : model on which query should be perfomed reverse (bool) : flag if the relation is reverse related (str) : name of the relation field Returns : (Tuple[Type[Model], str]) : Model on which query clause should be performed and name of the column get_column_name_for_id_extraction 1 2 | @staticmethod | get_column_name_for_id_extraction ( parent_model : Type [ \"Model\" ], reverse : bool , related : str , use_raw : bool ) -> str Returns name of the column that should be used to extract ids from model. Depending on the relation side it's either primary key column of parent model or field name specified by related parameter. Arguments : parent_model (Type[Model]) : model from which id column should be extracted reverse (bool) : flag if the relation is reverse related (str) : name of the relation field use_raw (bool) : flag if aliases or field names should be used Returns : () : get_related_field_name 1 2 | @classmethod | get_related_field_name ( cls , target_field : Type [ \"ForeignKeyField\" ]) -> str Returns name of the relation field that should be used in prefetch query. This field is later used to register relation in prefetch query, populate relations dict, and populate nested model in prefetch query. Arguments : target_field (Type[BaseField]) : relation field that should be used in prefetch Returns : (str) : name of the field get_filtered_names_to_extract 1 2 | @classmethod | get_filtered_names_to_extract ( cls , prefetch_dict : Dict ) -> List Returns list of related fields names that should be followed to prefetch related models from. List of models is translated into dict to assure each model is extracted only once in one query, that's why this function accepts prefetch_dict not list. Only relations from current model are returned. Arguments : prefetch_dict (Dict) : dictionary of fields to extract Returns : (List) : list of fields names to extract","title":"Prefetch Query Mixin"},{"location":"api/models/mixins/prefetch-query-mixin/#modelsmixinsprefetch_mixin","text":"","title":"models.mixins.prefetch_mixin"},{"location":"api/models/mixins/prefetch-query-mixin/#prefetchquerymixin-objects","text":"1 class PrefetchQueryMixin ( RelationMixin ) Used in PrefetchQuery to extract ids and names of models to prefetch.","title":"PrefetchQueryMixin Objects"},{"location":"api/models/mixins/prefetch-query-mixin/#get_clause_target_and_filter_column_name","text":"1 2 | @staticmethod | get_clause_target_and_filter_column_name ( parent_model : Type [ \"Model\" ], target_model : Type [ \"Model\" ], reverse : bool , related : str ) -> Tuple [ Type [ \"Model\" ], str ] Returns Model on which query clause should be performed and name of the column. Arguments : parent_model (Type[Model]) : related model that the relation lead to target_model (Type[Model]) : model on which query should be perfomed reverse (bool) : flag if the relation is reverse related (str) : name of the relation field Returns : (Tuple[Type[Model], str]) : Model on which query clause should be performed and name of the column","title":"get_clause_target_and_filter_column_name"},{"location":"api/models/mixins/prefetch-query-mixin/#get_column_name_for_id_extraction","text":"1 2 | @staticmethod | get_column_name_for_id_extraction ( parent_model : Type [ \"Model\" ], reverse : bool , related : str , use_raw : bool ) -> str Returns name of the column that should be used to extract ids from model. Depending on the relation side it's either primary key column of parent model or field name specified by related parameter. Arguments : parent_model (Type[Model]) : model from which id column should be extracted reverse (bool) : flag if the relation is reverse related (str) : name of the relation field use_raw (bool) : flag if aliases or field names should be used Returns : () :","title":"get_column_name_for_id_extraction"},{"location":"api/models/mixins/prefetch-query-mixin/#get_related_field_name","text":"1 2 | @classmethod | get_related_field_name ( cls , target_field : Type [ \"ForeignKeyField\" ]) -> str Returns name of the relation field that should be used in prefetch query. This field is later used to register relation in prefetch query, populate relations dict, and populate nested model in prefetch query. Arguments : target_field (Type[BaseField]) : relation field that should be used in prefetch Returns : (str) : name of the field","title":"get_related_field_name"},{"location":"api/models/mixins/prefetch-query-mixin/#get_filtered_names_to_extract","text":"1 2 | @classmethod | get_filtered_names_to_extract ( cls , prefetch_dict : Dict ) -> List Returns list of related fields names that should be followed to prefetch related models from. List of models is translated into dict to assure each model is extracted only once in one query, that's why this function accepts prefetch_dict not list. Only relations from current model are returned. Arguments : prefetch_dict (Dict) : dictionary of fields to extract Returns : (List) : list of fields names to extract","title":"get_filtered_names_to_extract"},{"location":"api/models/mixins/relation-mixin/","text":"models.mixins.relation_mixin RelationMixin Objects 1 class RelationMixin () Used to return relation fields/names etc. from given model extract_db_own_fields 1 2 | @classmethod | extract_db_own_fields ( cls ) -> Set Returns only fields that are stored in the own database table, exclude all related fields. Returns : (Set) : set of model fields with relation fields excluded extract_related_fields 1 2 | @classmethod | extract_related_fields ( cls ) -> List Returns List of ormar Fields for all relations declared on a model. List is cached in cls._related_fields for quicker access. Returns : (List) : list of related fields extract_related_names 1 2 | @classmethod | extract_related_names ( cls ) -> Set Returns List of fields names for all relations declared on a model. List is cached in cls._related_names for quicker access. Returns : (List) : list of related fields names _extract_db_related_names 1 2 | @classmethod | _extract_db_related_names ( cls ) -> Set Returns only fields that are stored in the own database table, exclude related fields that are not stored as foreign keys on given model. Returns : (Set) : set of model fields with non fk relation fields excluded _exclude_related_names_not_required 1 2 | @classmethod | _exclude_related_names_not_required ( cls , nested : bool = False ) -> Set Returns a set of non mandatory related models field names. For a main model (not nested) only nullable related field names are returned, for nested models all related models are returned. Arguments : nested (bool) : flag setting nested models (child of previous one, not main one) Returns : (Set) : set of non mandatory related fields","title":"Relation Mixin"},{"location":"api/models/mixins/relation-mixin/#modelsmixinsrelation_mixin","text":"","title":"models.mixins.relation_mixin"},{"location":"api/models/mixins/relation-mixin/#relationmixin-objects","text":"1 class RelationMixin () Used to return relation fields/names etc. from given model","title":"RelationMixin Objects"},{"location":"api/models/mixins/relation-mixin/#extract_db_own_fields","text":"1 2 | @classmethod | extract_db_own_fields ( cls ) -> Set Returns only fields that are stored in the own database table, exclude all related fields. Returns : (Set) : set of model fields with relation fields excluded","title":"extract_db_own_fields"},{"location":"api/models/mixins/relation-mixin/#extract_related_fields","text":"1 2 | @classmethod | extract_related_fields ( cls ) -> List Returns List of ormar Fields for all relations declared on a model. List is cached in cls._related_fields for quicker access. Returns : (List) : list of related fields","title":"extract_related_fields"},{"location":"api/models/mixins/relation-mixin/#extract_related_names","text":"1 2 | @classmethod | extract_related_names ( cls ) -> Set Returns List of fields names for all relations declared on a model. List is cached in cls._related_names for quicker access. Returns : (List) : list of related fields names","title":"extract_related_names"},{"location":"api/models/mixins/relation-mixin/#_extract_db_related_names","text":"1 2 | @classmethod | _extract_db_related_names ( cls ) -> Set Returns only fields that are stored in the own database table, exclude related fields that are not stored as foreign keys on given model. Returns : (Set) : set of model fields with non fk relation fields excluded","title":"_extract_db_related_names"},{"location":"api/models/mixins/relation-mixin/#_exclude_related_names_not_required","text":"1 2 | @classmethod | _exclude_related_names_not_required ( cls , nested : bool = False ) -> Set Returns a set of non mandatory related models field names. For a main model (not nested) only nullable related field names are returned, for nested models all related models are returned. Arguments : nested (bool) : flag setting nested models (child of previous one, not main one) Returns : (Set) : set of non mandatory related fields","title":"_exclude_related_names_not_required"},{"location":"api/models/mixins/save-prepare-mixin/","text":"models.mixins.save_mixin SavePrepareMixin Objects 1 class SavePrepareMixin ( RelationMixin , AliasMixin ) Used to prepare models to be saved in database prepare_model_to_save 1 2 | @classmethod | prepare_model_to_save ( cls , new_kwargs : dict ) -> dict Combines all preparation methods before saving. Removes primary key for if it's nullable or autoincrement pk field, and it's set to None. Substitute related models with their primary key values as fk column. Populates the default values for field with default set and no value. Translate columns into aliases (db names). Arguments : new_kwargs (Dict[str, str]) : dictionary of model that is about to be saved Returns : (Dict[str, str]) : dictionary of model that is about to be saved _remove_pk_from_kwargs 1 2 | @classmethod | _remove_pk_from_kwargs ( cls , new_kwargs : dict ) -> dict Removes primary key for if it's nullable or autoincrement pk field, and it's set to None. Arguments : new_kwargs (Dict[str, str]) : dictionary of model that is about to be saved Returns : (Dict[str, str]) : dictionary of model that is about to be saved substitute_models_with_pks 1 2 | @classmethod | substitute_models_with_pks ( cls , model_dict : Dict ) -> Dict Receives dictionary of model that is about to be saved and changes all related models that are stored as foreign keys to their fk value. Arguments : model_dict (Dict) : dictionary of model that is about to be saved Returns : (Dict) : dictionary of model that is about to be saved populate_default_values 1 2 | @classmethod | populate_default_values ( cls , new_kwargs : Dict ) -> Dict Receives dictionary of model that is about to be saved and populates the default value on the fields that have the default value set, but no actual value was passed by the user. Arguments : new_kwargs (Dict) : dictionary of model that is about to be saved Returns : (Dict) : dictionary of model that is about to be saved","title":"Save Prepare Mixin"},{"location":"api/models/mixins/save-prepare-mixin/#modelsmixinssave_mixin","text":"","title":"models.mixins.save_mixin"},{"location":"api/models/mixins/save-prepare-mixin/#savepreparemixin-objects","text":"1 class SavePrepareMixin ( RelationMixin , AliasMixin ) Used to prepare models to be saved in database","title":"SavePrepareMixin Objects"},{"location":"api/models/mixins/save-prepare-mixin/#prepare_model_to_save","text":"1 2 | @classmethod | prepare_model_to_save ( cls , new_kwargs : dict ) -> dict Combines all preparation methods before saving. Removes primary key for if it's nullable or autoincrement pk field, and it's set to None. Substitute related models with their primary key values as fk column. Populates the default values for field with default set and no value. Translate columns into aliases (db names). Arguments : new_kwargs (Dict[str, str]) : dictionary of model that is about to be saved Returns : (Dict[str, str]) : dictionary of model that is about to be saved","title":"prepare_model_to_save"},{"location":"api/models/mixins/save-prepare-mixin/#_remove_pk_from_kwargs","text":"1 2 | @classmethod | _remove_pk_from_kwargs ( cls , new_kwargs : dict ) -> dict Removes primary key for if it's nullable or autoincrement pk field, and it's set to None. Arguments : new_kwargs (Dict[str, str]) : dictionary of model that is about to be saved Returns : (Dict[str, str]) : dictionary of model that is about to be saved","title":"_remove_pk_from_kwargs"},{"location":"api/models/mixins/save-prepare-mixin/#substitute_models_with_pks","text":"1 2 | @classmethod | substitute_models_with_pks ( cls , model_dict : Dict ) -> Dict Receives dictionary of model that is about to be saved and changes all related models that are stored as foreign keys to their fk value. Arguments : model_dict (Dict) : dictionary of model that is about to be saved Returns : (Dict) : dictionary of model that is about to be saved","title":"substitute_models_with_pks"},{"location":"api/models/mixins/save-prepare-mixin/#populate_default_values","text":"1 2 | @classmethod | populate_default_values ( cls , new_kwargs : Dict ) -> Dict Receives dictionary of model that is about to be saved and populates the default value on the fields that have the default value set, but no actual value was passed by the user. Arguments : new_kwargs (Dict) : dictionary of model that is about to be saved Returns : (Dict) : dictionary of model that is about to be saved","title":"populate_default_values"},{"location":"api/query-set/clause/","text":"queryset.clause QueryClause Objects 1 class QueryClause () Constructs FilterActions from strings passed as arguments prepare_filter 1 | prepare_filter ( ** kwargs : Any ) -> Tuple [ List [ FilterAction ], List [ str ]] Main external access point that processes the clauses into sqlalchemy text clauses and updates select_related list with implicit related tables mentioned in select_related strings but not included in select_related. Arguments : kwargs (Any) : key, value pair with column names and values Returns : (Tuple[List[sqlalchemy.sql.elements.TextClause], List[str]]) : Tuple with list of where clauses and updated select_related list _populate_filter_clauses 1 | _populate_filter_clauses ( ** kwargs : Any ) -> Tuple [ List [ FilterAction ], List [ str ]] Iterates all clauses and extracts used operator and field from related models if needed. Based on the chain of related names the target table is determined and the final clause is escaped if needed and compiled. Arguments : kwargs (Any) : key, value pair with column names and values Returns : (Tuple[List[sqlalchemy.sql.elements.TextClause], List[str]]) : Tuple with list of where clauses and updated select_related list _register_complex_duplicates 1 | _register_complex_duplicates ( select_related : List [ str ]) -> None Checks if duplicate aliases are presented which can happen in self relation or when two joins end with the same pair of models. If there are duplicates, the all duplicated joins are registered as source model and whole relation key (not just last relation name). Arguments : select_related (List[str]) : list of relation strings Returns : (None) : None _parse_related_prefixes 1 | _parse_related_prefixes ( select_related : List [ str ]) -> List [ Prefix ] Walks all relation strings and parses the target models and prefixes. Arguments : select_related (List[str]) : list of relation strings Returns : (List[Prefix]) : list of parsed prefixes _switch_filter_action_prefixes 1 | _switch_filter_action_prefixes ( filter_clauses : List [ FilterAction ]) -> List [ FilterAction ] Substitutes aliases for filter action if the complex key (whole relation str) is present in alias_manager. Arguments : filter_clauses (List[FilterAction]) : raw list of actions Returns : (List[FilterAction]) : list of actions with aliases changed if needed","title":"Clause"},{"location":"api/query-set/clause/#querysetclause","text":"","title":"queryset.clause"},{"location":"api/query-set/clause/#queryclause-objects","text":"1 class QueryClause () Constructs FilterActions from strings passed as arguments","title":"QueryClause Objects"},{"location":"api/query-set/clause/#prepare_filter","text":"1 | prepare_filter ( ** kwargs : Any ) -> Tuple [ List [ FilterAction ], List [ str ]] Main external access point that processes the clauses into sqlalchemy text clauses and updates select_related list with implicit related tables mentioned in select_related strings but not included in select_related. Arguments : kwargs (Any) : key, value pair with column names and values Returns : (Tuple[List[sqlalchemy.sql.elements.TextClause], List[str]]) : Tuple with list of where clauses and updated select_related list","title":"prepare_filter"},{"location":"api/query-set/clause/#_populate_filter_clauses","text":"1 | _populate_filter_clauses ( ** kwargs : Any ) -> Tuple [ List [ FilterAction ], List [ str ]] Iterates all clauses and extracts used operator and field from related models if needed. Based on the chain of related names the target table is determined and the final clause is escaped if needed and compiled. Arguments : kwargs (Any) : key, value pair with column names and values Returns : (Tuple[List[sqlalchemy.sql.elements.TextClause], List[str]]) : Tuple with list of where clauses and updated select_related list","title":"_populate_filter_clauses"},{"location":"api/query-set/clause/#_register_complex_duplicates","text":"1 | _register_complex_duplicates ( select_related : List [ str ]) -> None Checks if duplicate aliases are presented which can happen in self relation or when two joins end with the same pair of models. If there are duplicates, the all duplicated joins are registered as source model and whole relation key (not just last relation name). Arguments : select_related (List[str]) : list of relation strings Returns : (None) : None","title":"_register_complex_duplicates"},{"location":"api/query-set/clause/#_parse_related_prefixes","text":"1 | _parse_related_prefixes ( select_related : List [ str ]) -> List [ Prefix ] Walks all relation strings and parses the target models and prefixes. Arguments : select_related (List[str]) : list of relation strings Returns : (List[Prefix]) : list of parsed prefixes","title":"_parse_related_prefixes"},{"location":"api/query-set/clause/#_switch_filter_action_prefixes","text":"1 | _switch_filter_action_prefixes ( filter_clauses : List [ FilterAction ]) -> List [ FilterAction ] Substitutes aliases for filter action if the complex key (whole relation str) is present in alias_manager. Arguments : filter_clauses (List[FilterAction]) : raw list of actions Returns : (List[FilterAction]) : list of actions with aliases changed if needed","title":"_switch_filter_action_prefixes"},{"location":"api/query-set/filter-query/","text":"queryset.filter_query FilterQuery Objects 1 class FilterQuery () Modifies the select query with given list of where/filter clauses. apply 1 | apply ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Applies all filter clauses if set. Arguments : expr (sqlalchemy.sql.selectable.Select) : query to modify Returns : (sqlalchemy.sql.selectable.Select) : modified query","title":"Filter Query"},{"location":"api/query-set/filter-query/#querysetfilter_query","text":"","title":"queryset.filter_query"},{"location":"api/query-set/filter-query/#filterquery-objects","text":"1 class FilterQuery () Modifies the select query with given list of where/filter clauses.","title":"FilterQuery Objects"},{"location":"api/query-set/filter-query/#apply","text":"1 | apply ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Applies all filter clauses if set. Arguments : expr (sqlalchemy.sql.selectable.Select) : query to modify Returns : (sqlalchemy.sql.selectable.Select) : modified query","title":"apply"},{"location":"api/query-set/join/","text":"queryset.join SqlJoin Objects 1 class SqlJoin () alias_manager 1 2 | @property | alias_manager () -> AliasManager Shortcut for ormar's model AliasManager stored on Meta. Returns : (AliasManager) : alias manager from model's Meta on_clause 1 | on_clause ( previous_alias : str , from_clause : str , to_clause : str ) -> text Receives aliases and names of both ends of the join and combines them into one text clause used in joins. Arguments : previous_alias (str) : alias of previous table from_clause (str) : from table name to_clause (str) : to table name Returns : (sqlalchemy.text) : clause combining all strings build_join 1 | build_join () -> Tuple [ List , sqlalchemy . sql . select , List , OrderedDict ] Main external access point for building a join. Splits the join definition, updates fields and exclude_fields if needed, handles switching to through models for m2m relations, returns updated lists of used_aliases and sort_orders. Returns : (Tuple[List[str], Join, List[TextClause], collections.OrderedDict]) : list of used aliases, select from, list of aliased columns, sort orders _forward_join 1 | _forward_join () -> None Process actual join. Registers complex relation join on encountering of the duplicated alias. _process_following_joins 1 | _process_following_joins () -> None Iterates through nested models to create subsequent joins. _process_deeper_join 1 | _process_deeper_join ( related_name : str , remainder : Any ) -> None Creates nested recurrent instance of SqlJoin for each nested join table, updating needed return params here as a side effect. Updated are: self.used_aliases, self.select_from, self.columns, self.sorted_orders, Arguments : related_name (str) : name of the relation to follow remainder (Any) : deeper tables if there are more nested joins process_m2m_through_table 1 | process_m2m_through_table () -> None Process Through table of the ManyToMany relation so that source table is linked to the through table (one additional join) Replaces needed parameters like: self.next_model, self.next_alias, self.relation_name, self.own_alias, self.target_field To point to through model process_m2m_related_name_change 1 | process_m2m_related_name_change ( reverse : bool = False ) -> str Extracts relation name to link join through the Through model declared on relation field. Changes the same names in order_by queries if they are present. Arguments : reverse (bool) : flag if it's on_clause lookup - use reverse fields Returns : (str) : new relation name switched to through model field _process_join 1 | _process_join () -> None Resolves to and from column names and table names. Produces on_clause. Performs actual join updating select_from parameter. Adds aliases of required column to list of columns to include in query. Updates the used aliases list directly. Process order_by causes for non m2m relations. _replace_many_to_many_order_by_columns 1 | _replace_many_to_many_order_by_columns ( part : str , new_part : str ) -> None Substitutes the name of the relation with actual model name in m2m order bys. Arguments : part (str) : name of the field with relation new_part (str) : name of the target model _check_if_condition_apply 1 2 | @staticmethod | _check_if_condition_apply ( condition : List , part : str ) -> bool Checks filter conditions to find if they apply to current join. Arguments : condition (List[str]) : list of parts of condition split by '__' part (str) : name of the current relation join. Returns : (bool) : result of the check set_aliased_order_by 1 | set_aliased_order_by ( condition : List [ str ], to_table : str ) -> None Substitute hyphens ('-') with descending order. Construct actual sqlalchemy text clause using aliased table and column name. Arguments : condition (List[str]) : list of parts of a current condition split by '__' to_table (sqlalchemy.sql.elements.quoted_name) : target table get_order_bys 1 | get_order_bys ( to_table : str , pkname_alias : str ) -> None Triggers construction of order bys if they are given. Otherwise by default each table is sorted by a primary key column asc. Arguments : to_table (sqlalchemy.sql.elements.quoted_name) : target table pkname_alias (str) : alias of the primary key column get_to_and_from_keys 1 | get_to_and_from_keys () -> Tuple [ str , str ] Based on the relation type, name of the relation and previous models and parts stored in JoinParameters it resolves the current to and from keys, which are different for ManyToMany relation, ForeignKey and reverse related of relations. Returns : (Tuple[str, str]) : to key and from key","title":"Join"},{"location":"api/query-set/join/#querysetjoin","text":"","title":"queryset.join"},{"location":"api/query-set/join/#sqljoin-objects","text":"1 class SqlJoin ()","title":"SqlJoin Objects"},{"location":"api/query-set/join/#alias_manager","text":"1 2 | @property | alias_manager () -> AliasManager Shortcut for ormar's model AliasManager stored on Meta. Returns : (AliasManager) : alias manager from model's Meta","title":"alias_manager"},{"location":"api/query-set/join/#on_clause","text":"1 | on_clause ( previous_alias : str , from_clause : str , to_clause : str ) -> text Receives aliases and names of both ends of the join and combines them into one text clause used in joins. Arguments : previous_alias (str) : alias of previous table from_clause (str) : from table name to_clause (str) : to table name Returns : (sqlalchemy.text) : clause combining all strings","title":"on_clause"},{"location":"api/query-set/join/#build_join","text":"1 | build_join () -> Tuple [ List , sqlalchemy . sql . select , List , OrderedDict ] Main external access point for building a join. Splits the join definition, updates fields and exclude_fields if needed, handles switching to through models for m2m relations, returns updated lists of used_aliases and sort_orders. Returns : (Tuple[List[str], Join, List[TextClause], collections.OrderedDict]) : list of used aliases, select from, list of aliased columns, sort orders","title":"build_join"},{"location":"api/query-set/join/#_forward_join","text":"1 | _forward_join () -> None Process actual join. Registers complex relation join on encountering of the duplicated alias.","title":"_forward_join"},{"location":"api/query-set/join/#_process_following_joins","text":"1 | _process_following_joins () -> None Iterates through nested models to create subsequent joins.","title":"_process_following_joins"},{"location":"api/query-set/join/#_process_deeper_join","text":"1 | _process_deeper_join ( related_name : str , remainder : Any ) -> None Creates nested recurrent instance of SqlJoin for each nested join table, updating needed return params here as a side effect. Updated are: self.used_aliases, self.select_from, self.columns, self.sorted_orders, Arguments : related_name (str) : name of the relation to follow remainder (Any) : deeper tables if there are more nested joins","title":"_process_deeper_join"},{"location":"api/query-set/join/#process_m2m_through_table","text":"1 | process_m2m_through_table () -> None Process Through table of the ManyToMany relation so that source table is linked to the through table (one additional join) Replaces needed parameters like: self.next_model, self.next_alias, self.relation_name, self.own_alias, self.target_field To point to through model","title":"process_m2m_through_table"},{"location":"api/query-set/join/#process_m2m_related_name_change","text":"1 | process_m2m_related_name_change ( reverse : bool = False ) -> str Extracts relation name to link join through the Through model declared on relation field. Changes the same names in order_by queries if they are present. Arguments : reverse (bool) : flag if it's on_clause lookup - use reverse fields Returns : (str) : new relation name switched to through model field","title":"process_m2m_related_name_change"},{"location":"api/query-set/join/#_process_join","text":"1 | _process_join () -> None Resolves to and from column names and table names. Produces on_clause. Performs actual join updating select_from parameter. Adds aliases of required column to list of columns to include in query. Updates the used aliases list directly. Process order_by causes for non m2m relations.","title":"_process_join"},{"location":"api/query-set/join/#_replace_many_to_many_order_by_columns","text":"1 | _replace_many_to_many_order_by_columns ( part : str , new_part : str ) -> None Substitutes the name of the relation with actual model name in m2m order bys. Arguments : part (str) : name of the field with relation new_part (str) : name of the target model","title":"_replace_many_to_many_order_by_columns"},{"location":"api/query-set/join/#_check_if_condition_apply","text":"1 2 | @staticmethod | _check_if_condition_apply ( condition : List , part : str ) -> bool Checks filter conditions to find if they apply to current join. Arguments : condition (List[str]) : list of parts of condition split by '__' part (str) : name of the current relation join. Returns : (bool) : result of the check","title":"_check_if_condition_apply"},{"location":"api/query-set/join/#set_aliased_order_by","text":"1 | set_aliased_order_by ( condition : List [ str ], to_table : str ) -> None Substitute hyphens ('-') with descending order. Construct actual sqlalchemy text clause using aliased table and column name. Arguments : condition (List[str]) : list of parts of a current condition split by '__' to_table (sqlalchemy.sql.elements.quoted_name) : target table","title":"set_aliased_order_by"},{"location":"api/query-set/join/#get_order_bys","text":"1 | get_order_bys ( to_table : str , pkname_alias : str ) -> None Triggers construction of order bys if they are given. Otherwise by default each table is sorted by a primary key column asc. Arguments : to_table (sqlalchemy.sql.elements.quoted_name) : target table pkname_alias (str) : alias of the primary key column","title":"get_order_bys"},{"location":"api/query-set/join/#get_to_and_from_keys","text":"1 | get_to_and_from_keys () -> Tuple [ str , str ] Based on the relation type, name of the relation and previous models and parts stored in JoinParameters it resolves the current to and from keys, which are different for ManyToMany relation, ForeignKey and reverse related of relations. Returns : (Tuple[str, str]) : to key and from key","title":"get_to_and_from_keys"},{"location":"api/query-set/limit-query/","text":"queryset.limit_query LimitQuery Objects 1 class LimitQuery () Modifies the select query with limit clause. apply 1 | apply ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Applies the limit clause. Arguments : expr (sqlalchemy.sql.selectable.Select) : query to modify Returns : (sqlalchemy.sql.selectable.Select) : modified query","title":"Limit Query"},{"location":"api/query-set/limit-query/#querysetlimit_query","text":"","title":"queryset.limit_query"},{"location":"api/query-set/limit-query/#limitquery-objects","text":"1 class LimitQuery () Modifies the select query with limit clause.","title":"LimitQuery Objects"},{"location":"api/query-set/limit-query/#apply","text":"1 | apply ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Applies the limit clause. Arguments : expr (sqlalchemy.sql.selectable.Select) : query to modify Returns : (sqlalchemy.sql.selectable.Select) : modified query","title":"apply"},{"location":"api/query-set/offset-query/","text":"queryset.offset_query OffsetQuery Objects 1 class OffsetQuery () Modifies the select query with offset if set apply 1 | apply ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Applies the offset clause. Arguments : expr (sqlalchemy.sql.selectable.Select) : query to modify Returns : (sqlalchemy.sql.selectable.Select) : modified query","title":"Offset Query"},{"location":"api/query-set/offset-query/#querysetoffset_query","text":"","title":"queryset.offset_query"},{"location":"api/query-set/offset-query/#offsetquery-objects","text":"1 class OffsetQuery () Modifies the select query with offset if set","title":"OffsetQuery Objects"},{"location":"api/query-set/offset-query/#apply","text":"1 | apply ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Applies the offset clause. Arguments : expr (sqlalchemy.sql.selectable.Select) : query to modify Returns : (sqlalchemy.sql.selectable.Select) : modified query","title":"apply"},{"location":"api/query-set/order-query/","text":"queryset.order_query OrderQuery Objects 1 class OrderQuery () Modifies the select query with given list of order_by clauses. apply 1 | apply ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Applies all order_by clauses if set. Arguments : expr (sqlalchemy.sql.selectable.Select) : query to modify Returns : (sqlalchemy.sql.selectable.Select) : modified query","title":"Order Query"},{"location":"api/query-set/order-query/#querysetorder_query","text":"","title":"queryset.order_query"},{"location":"api/query-set/order-query/#orderquery-objects","text":"1 class OrderQuery () Modifies the select query with given list of order_by clauses.","title":"OrderQuery Objects"},{"location":"api/query-set/order-query/#apply","text":"1 | apply ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Applies all order_by clauses if set. Arguments : expr (sqlalchemy.sql.selectable.Select) : query to modify Returns : (sqlalchemy.sql.selectable.Select) : modified query","title":"apply"},{"location":"api/query-set/prefetch-query/","text":"queryset.prefetch_query add_relation_field_to_fields 1 add_relation_field_to_fields ( fields : Union [ Set [ Any ], Dict [ Any , Any ], None ], related_field_name : str ) -> Union [ Set [ Any ], Dict [ Any , Any ], None ] Adds related field into fields to include as otherwise it would be skipped. Related field is added only if fields are already populated. Empty fields implies all fields. Arguments : fields (Dict) : Union[Set[Any], Dict[Any, Any], None] related_field_name (str) : name of the field with relation Returns : (Union[Set[Any], Dict[Any, Any], None]) : updated fields dict sort_models 1 sort_models ( models : List [ \"Model\" ], orders_by : Dict ) -> List [ \"Model\" ] Since prefetch query gets all related models by ids the sorting needs to happen in python. Since by default models are already sorted by id here we resort only if order_by parameters was set. Arguments : models (List[tests.test_prefetch_related.Division]) : list of models already fetched from db orders_by (Dict[str, str]) : order by dictionary Returns : (List[tests.test_prefetch_related.Division]) : sorted list of models set_children_on_model 1 set_children_on_model ( model : \"Model\" , related : str , children : Dict , model_id : int , models : Dict , orders_by : Dict ) -> None Extract ids of child models by given relation id key value. Based on those ids the actual children model instances are fetched from already fetched data. If needed the child models are resorted according to passed orders_by dict. Also relation is registered as each child is set as parent related field name value. Arguments : model (Model) : parent model instance related (str) : name of the related field children (Dict[int, set]) : dictionary of children ids/ related field value model_id (int) : id of the model on which children should be set models (Dict) : dictionary of child models instances orders_by (Dict) : order_by dictionary PrefetchQuery Objects 1 class PrefetchQuery () Query used to fetch related models in subsequent queries. Each model is fetched only ones by the name of the relation. That means that for each prefetch_related entry next query is issued to database. prefetch_related 1 | async prefetch_related ( models : Sequence [ \"Model\" ], rows : List ) -> Sequence [ \"Model\" ] Main entry point for prefetch_query. Receives list of already initialized parent models with all children from select_related already populated. Receives also list of row sql result rows as it's quicker to extract ids that way instead of calling each model. Returns list with related models already prefetched and set. Arguments : models (List[Model]) : list of already instantiated models from main query rows (List[sqlalchemy.engine.result.RowProxy]) : row sql result of the main query before the prefetch Returns : (List[Model]) : list of models with children prefetched _extract_ids_from_raw_data 1 | _extract_ids_from_raw_data ( parent_model : Type [ \"Model\" ], column_name : str ) -> Set Iterates over raw rows and extract id values of relation columns by using prefixed column name. Arguments : parent_model (Type[Model]) : ormar model class column_name (str) : name of the relation column which is a key column Returns : (set) : set of ids of related model that should be extracted _extract_ids_from_preloaded_models 1 | _extract_ids_from_preloaded_models ( parent_model : Type [ \"Model\" ], column_name : str ) -> Set Extracts relation ids from already populated models if they were included in the original query before. Arguments : parent_model (Type[\"Model\"]) : model from which related ids should be extracted column_name (str) : name of the relation column which is a key column Returns : (set) : set of ids of related model that should be extracted _extract_required_ids 1 | _extract_required_ids ( parent_model : Type [ \"Model\" ], reverse : bool , related : str ) -> Set Delegates extraction of the fields to either get ids from raw sql response or from already populated models. Arguments : parent_model (Type[\"Model\"]) : model from which related ids should be extracted reverse (bool) : flag if the relation is reverse related (str) : name of the field with relation Returns : (set) : set of ids of related model that should be extracted _get_filter_for_prefetch 1 | _get_filter_for_prefetch ( parent_model : Type [ \"Model\" ], target_model : Type [ \"Model\" ], reverse : bool , related : str ) -> List Populates where clause with condition to return only models within the set of extracted ids. If there are no ids for relation the empty list is returned. Arguments : parent_model (Type[\"Model\"]) : model from which related ids should be extracted target_model (Type[\"Model\"]) : model to which relation leads to reverse (bool) : flag if the relation is reverse related (str) : name of the field with relation Returns : (List[sqlalchemy.sql.elements.TextClause]) : _populate_nested_related 1 | _populate_nested_related ( model : \"Model\" , prefetch_dict : Dict , orders_by : Dict ) -> \"Model\" Populates all related models children of parent model that are included in prefetch query. Arguments : model (Model) : ormar model instance prefetch_dict (Dict) : dictionary of models to prefetch orders_by (Dict) : dictionary of order bys Returns : (Model) : model with children populated _prefetch_related_models 1 | async _prefetch_related_models ( models : Sequence [ \"Model\" ], rows : List ) -> Sequence [ \"Model\" ] Main method of the query. Translates select nad prefetch list into dictionaries to avoid querying the same related models multiple times. Keeps the list of already extracted models. Extracts the related models from the database and later populate all children on each of the parent models from list. Arguments : models (List[Model]) : list of parent models from main query rows (List[sqlalchemy.engine.result.RowProxy]) : raw response from sql query Returns : (List[Model]) : list of models with prefetch children populated _extract_related_models 1 | async _extract_related_models ( related : str , target_model : Type [ \"Model\" ], prefetch_dict : Dict , select_dict : Dict , fields : Union [ Set [ Any ], Dict [ Any , Any ], None ], exclude_fields : Union [ Set [ Any ], Dict [ Any , Any ], None ], orders_by : Dict ) -> None Constructs queries with required ids and extracts data with fields that should be included/excluded. Runs the queries against the database and populated dictionaries with ids and with actual extracted children models. Calls itself recurrently to extract deeper nested relations of related model. Arguments : related (str) : name of the relation target_model (Type[Model]) : model to which relation leads to prefetch_dict (Dict) : prefetch related list converted into dictionary select_dict (Dict) : select related list converted into dictionary fields (Union[Set[Any], Dict[Any, Any], None]) : fields to include exclude_fields (Union[Set[Any], Dict[Any, Any], None]) : fields to exclude orders_by (Dict) : dictionary of order bys clauses Returns : (None) : None _run_prefetch_query 1 | async _run_prefetch_query ( target_field : Type [ \"BaseField\" ], fields : Union [ Set [ Any ], Dict [ Any , Any ], None ], exclude_fields : Union [ Set [ Any ], Dict [ Any , Any ], None ], filter_clauses : List ) -> Tuple [ str , List ] Actually runs the queries against the database and populates the raw response for given related model. Returns table prefix as it's later needed to eventually initialize the children models. Arguments : target_field (Type[\"BaseField\"]) : ormar field with relation definition fields (Union[Set[Any], Dict[Any, Any], None]) : fields to include exclude_fields (Union[Set[Any], Dict[Any, Any], None]) : fields to exclude filter_clauses (List[sqlalchemy.sql.elements.TextClause]) : list of clauses, actually one clause with ids of relation Returns : (Tuple[str, List]) : table prefix and raw rows from sql response _get_select_related_if_apply 1 2 | @staticmethod | _get_select_related_if_apply ( related : str , select_dict : Dict ) -> Dict Extract nested related of select_related dictionary to extract models nested deeper on related model and already loaded in select related query. Arguments : related (str) : name of the relation select_dict (Dict) : dictionary of select related models in main query Returns : (Dict) : dictionary with nested related of select related _update_already_loaded_rows 1 | _update_already_loaded_rows ( target_field : Type [ \"BaseField\" ], prefetch_dict : Dict , orders_by : Dict ) -> None Updates models that are already loaded, usually children of children. Arguments : target_field (Type[\"BaseField\"]) : ormar field with relation definition prefetch_dict (Dict) : dictionaries of related models to prefetch orders_by (Dict) : dictionary of order by clauses by model _populate_rows 1 | _populate_rows ( rows : List , target_field : Type [ \"ForeignKeyField\" ], parent_model : Type [ \"Model\" ], table_prefix : str , fields : Union [ Set [ Any ], Dict [ Any , Any ], None ], exclude_fields : Union [ Set [ Any ], Dict [ Any , Any ], None ], prefetch_dict : Dict , orders_by : Dict ) -> None Instantiates children models extracted from given relation. Populates them with their own nested children if they are included in prefetch query. Sets the initialized models and ids of them under corresponding keys in already_extracted dictionary. Later those instances will be fetched by ids and set on the parent model after sorting if needed. Arguments : rows (List[sqlalchemy.engine.result.RowProxy]) : raw sql response from the prefetch query target_field (Type[\"BaseField\"]) : field with relation definition from parent model parent_model (Type[Model]) : model with relation definition table_prefix (str) : prefix of the target table from current relation fields (Union[Set[Any], Dict[Any, Any], None]) : fields to include exclude_fields (Union[Set[Any], Dict[Any, Any], None]) : fields to exclude prefetch_dict (Dict) : dictionaries of related models to prefetch orders_by (Dict) : dictionary of order by clauses by model","title":"Prefetch Query"},{"location":"api/query-set/prefetch-query/#querysetprefetch_query","text":"","title":"queryset.prefetch_query"},{"location":"api/query-set/prefetch-query/#add_relation_field_to_fields","text":"1 add_relation_field_to_fields ( fields : Union [ Set [ Any ], Dict [ Any , Any ], None ], related_field_name : str ) -> Union [ Set [ Any ], Dict [ Any , Any ], None ] Adds related field into fields to include as otherwise it would be skipped. Related field is added only if fields are already populated. Empty fields implies all fields. Arguments : fields (Dict) : Union[Set[Any], Dict[Any, Any], None] related_field_name (str) : name of the field with relation Returns : (Union[Set[Any], Dict[Any, Any], None]) : updated fields dict","title":"add_relation_field_to_fields"},{"location":"api/query-set/prefetch-query/#sort_models","text":"1 sort_models ( models : List [ \"Model\" ], orders_by : Dict ) -> List [ \"Model\" ] Since prefetch query gets all related models by ids the sorting needs to happen in python. Since by default models are already sorted by id here we resort only if order_by parameters was set. Arguments : models (List[tests.test_prefetch_related.Division]) : list of models already fetched from db orders_by (Dict[str, str]) : order by dictionary Returns : (List[tests.test_prefetch_related.Division]) : sorted list of models","title":"sort_models"},{"location":"api/query-set/prefetch-query/#set_children_on_model","text":"1 set_children_on_model ( model : \"Model\" , related : str , children : Dict , model_id : int , models : Dict , orders_by : Dict ) -> None Extract ids of child models by given relation id key value. Based on those ids the actual children model instances are fetched from already fetched data. If needed the child models are resorted according to passed orders_by dict. Also relation is registered as each child is set as parent related field name value. Arguments : model (Model) : parent model instance related (str) : name of the related field children (Dict[int, set]) : dictionary of children ids/ related field value model_id (int) : id of the model on which children should be set models (Dict) : dictionary of child models instances orders_by (Dict) : order_by dictionary","title":"set_children_on_model"},{"location":"api/query-set/prefetch-query/#prefetchquery-objects","text":"1 class PrefetchQuery () Query used to fetch related models in subsequent queries. Each model is fetched only ones by the name of the relation. That means that for each prefetch_related entry next query is issued to database.","title":"PrefetchQuery Objects"},{"location":"api/query-set/prefetch-query/#prefetch_related","text":"1 | async prefetch_related ( models : Sequence [ \"Model\" ], rows : List ) -> Sequence [ \"Model\" ] Main entry point for prefetch_query. Receives list of already initialized parent models with all children from select_related already populated. Receives also list of row sql result rows as it's quicker to extract ids that way instead of calling each model. Returns list with related models already prefetched and set. Arguments : models (List[Model]) : list of already instantiated models from main query rows (List[sqlalchemy.engine.result.RowProxy]) : row sql result of the main query before the prefetch Returns : (List[Model]) : list of models with children prefetched","title":"prefetch_related"},{"location":"api/query-set/prefetch-query/#_extract_ids_from_raw_data","text":"1 | _extract_ids_from_raw_data ( parent_model : Type [ \"Model\" ], column_name : str ) -> Set Iterates over raw rows and extract id values of relation columns by using prefixed column name. Arguments : parent_model (Type[Model]) : ormar model class column_name (str) : name of the relation column which is a key column Returns : (set) : set of ids of related model that should be extracted","title":"_extract_ids_from_raw_data"},{"location":"api/query-set/prefetch-query/#_extract_ids_from_preloaded_models","text":"1 | _extract_ids_from_preloaded_models ( parent_model : Type [ \"Model\" ], column_name : str ) -> Set Extracts relation ids from already populated models if they were included in the original query before. Arguments : parent_model (Type[\"Model\"]) : model from which related ids should be extracted column_name (str) : name of the relation column which is a key column Returns : (set) : set of ids of related model that should be extracted","title":"_extract_ids_from_preloaded_models"},{"location":"api/query-set/prefetch-query/#_extract_required_ids","text":"1 | _extract_required_ids ( parent_model : Type [ \"Model\" ], reverse : bool , related : str ) -> Set Delegates extraction of the fields to either get ids from raw sql response or from already populated models. Arguments : parent_model (Type[\"Model\"]) : model from which related ids should be extracted reverse (bool) : flag if the relation is reverse related (str) : name of the field with relation Returns : (set) : set of ids of related model that should be extracted","title":"_extract_required_ids"},{"location":"api/query-set/prefetch-query/#_get_filter_for_prefetch","text":"1 | _get_filter_for_prefetch ( parent_model : Type [ \"Model\" ], target_model : Type [ \"Model\" ], reverse : bool , related : str ) -> List Populates where clause with condition to return only models within the set of extracted ids. If there are no ids for relation the empty list is returned. Arguments : parent_model (Type[\"Model\"]) : model from which related ids should be extracted target_model (Type[\"Model\"]) : model to which relation leads to reverse (bool) : flag if the relation is reverse related (str) : name of the field with relation Returns : (List[sqlalchemy.sql.elements.TextClause]) :","title":"_get_filter_for_prefetch"},{"location":"api/query-set/prefetch-query/#_populate_nested_related","text":"1 | _populate_nested_related ( model : \"Model\" , prefetch_dict : Dict , orders_by : Dict ) -> \"Model\" Populates all related models children of parent model that are included in prefetch query. Arguments : model (Model) : ormar model instance prefetch_dict (Dict) : dictionary of models to prefetch orders_by (Dict) : dictionary of order bys Returns : (Model) : model with children populated","title":"_populate_nested_related"},{"location":"api/query-set/prefetch-query/#_prefetch_related_models","text":"1 | async _prefetch_related_models ( models : Sequence [ \"Model\" ], rows : List ) -> Sequence [ \"Model\" ] Main method of the query. Translates select nad prefetch list into dictionaries to avoid querying the same related models multiple times. Keeps the list of already extracted models. Extracts the related models from the database and later populate all children on each of the parent models from list. Arguments : models (List[Model]) : list of parent models from main query rows (List[sqlalchemy.engine.result.RowProxy]) : raw response from sql query Returns : (List[Model]) : list of models with prefetch children populated","title":"_prefetch_related_models"},{"location":"api/query-set/prefetch-query/#_extract_related_models","text":"1 | async _extract_related_models ( related : str , target_model : Type [ \"Model\" ], prefetch_dict : Dict , select_dict : Dict , fields : Union [ Set [ Any ], Dict [ Any , Any ], None ], exclude_fields : Union [ Set [ Any ], Dict [ Any , Any ], None ], orders_by : Dict ) -> None Constructs queries with required ids and extracts data with fields that should be included/excluded. Runs the queries against the database and populated dictionaries with ids and with actual extracted children models. Calls itself recurrently to extract deeper nested relations of related model. Arguments : related (str) : name of the relation target_model (Type[Model]) : model to which relation leads to prefetch_dict (Dict) : prefetch related list converted into dictionary select_dict (Dict) : select related list converted into dictionary fields (Union[Set[Any], Dict[Any, Any], None]) : fields to include exclude_fields (Union[Set[Any], Dict[Any, Any], None]) : fields to exclude orders_by (Dict) : dictionary of order bys clauses Returns : (None) : None","title":"_extract_related_models"},{"location":"api/query-set/prefetch-query/#_run_prefetch_query","text":"1 | async _run_prefetch_query ( target_field : Type [ \"BaseField\" ], fields : Union [ Set [ Any ], Dict [ Any , Any ], None ], exclude_fields : Union [ Set [ Any ], Dict [ Any , Any ], None ], filter_clauses : List ) -> Tuple [ str , List ] Actually runs the queries against the database and populates the raw response for given related model. Returns table prefix as it's later needed to eventually initialize the children models. Arguments : target_field (Type[\"BaseField\"]) : ormar field with relation definition fields (Union[Set[Any], Dict[Any, Any], None]) : fields to include exclude_fields (Union[Set[Any], Dict[Any, Any], None]) : fields to exclude filter_clauses (List[sqlalchemy.sql.elements.TextClause]) : list of clauses, actually one clause with ids of relation Returns : (Tuple[str, List]) : table prefix and raw rows from sql response","title":"_run_prefetch_query"},{"location":"api/query-set/prefetch-query/#_get_select_related_if_apply","text":"1 2 | @staticmethod | _get_select_related_if_apply ( related : str , select_dict : Dict ) -> Dict Extract nested related of select_related dictionary to extract models nested deeper on related model and already loaded in select related query. Arguments : related (str) : name of the relation select_dict (Dict) : dictionary of select related models in main query Returns : (Dict) : dictionary with nested related of select related","title":"_get_select_related_if_apply"},{"location":"api/query-set/prefetch-query/#_update_already_loaded_rows","text":"1 | _update_already_loaded_rows ( target_field : Type [ \"BaseField\" ], prefetch_dict : Dict , orders_by : Dict ) -> None Updates models that are already loaded, usually children of children. Arguments : target_field (Type[\"BaseField\"]) : ormar field with relation definition prefetch_dict (Dict) : dictionaries of related models to prefetch orders_by (Dict) : dictionary of order by clauses by model","title":"_update_already_loaded_rows"},{"location":"api/query-set/prefetch-query/#_populate_rows","text":"1 | _populate_rows ( rows : List , target_field : Type [ \"ForeignKeyField\" ], parent_model : Type [ \"Model\" ], table_prefix : str , fields : Union [ Set [ Any ], Dict [ Any , Any ], None ], exclude_fields : Union [ Set [ Any ], Dict [ Any , Any ], None ], prefetch_dict : Dict , orders_by : Dict ) -> None Instantiates children models extracted from given relation. Populates them with their own nested children if they are included in prefetch query. Sets the initialized models and ids of them under corresponding keys in already_extracted dictionary. Later those instances will be fetched by ids and set on the parent model after sorting if needed. Arguments : rows (List[sqlalchemy.engine.result.RowProxy]) : raw sql response from the prefetch query target_field (Type[\"BaseField\"]) : field with relation definition from parent model parent_model (Type[Model]) : model with relation definition table_prefix (str) : prefix of the target table from current relation fields (Union[Set[Any], Dict[Any, Any], None]) : fields to include exclude_fields (Union[Set[Any], Dict[Any, Any], None]) : fields to exclude prefetch_dict (Dict) : dictionaries of related models to prefetch orders_by (Dict) : dictionary of order by clauses by model","title":"_populate_rows"},{"location":"api/query-set/query-set/","text":"queryset.queryset QuerySet Objects 1 class QuerySet () Main class to perform database queries, exposed on each model as objects attribute. model_meta 1 2 | @property | model_meta () -> \"ModelMeta\" Shortcut to model class Meta set on QuerySet model. Returns : (model Meta class) : Meta class of the model model 1 2 | @property | model () -> Type [ \"Model\" ] Shortcut to model class set on QuerySet. Returns : (Type[Model]) : model class _prefetch_related_models 1 | async _prefetch_related_models ( models : Sequence [ Optional [ \"Model\" ]], rows : List ) -> Sequence [ Optional [ \"Model\" ]] Performs prefetch query for selected models names. Arguments : models (List[Model]) : list of already parsed main Models from main query rows (List[sqlalchemy.engine.result.RowProxy]) : database rows from main query Returns : (List[Model]) : list of models with prefetch models populated _process_query_result_rows 1 | _process_query_result_rows ( rows : List ) -> Sequence [ Optional [ \"Model\" ]] Process database rows and initialize ormar Model from each of the rows. Arguments : rows (List[sqlalchemy.engine.result.RowProxy]) : list of database rows from query result Returns : (List[Model]) : list of models check_single_result_rows_count 1 2 | @staticmethod | check_single_result_rows_count ( rows : Sequence [ Optional [ \"Model\" ]]) -> None Verifies if the result has one and only one row. Arguments : rows (List[Model]) : one element list of Models database 1 2 | @property | database () -> databases . Database Shortcut to models database from Meta class. Returns : (databases.Database) : database table 1 2 | @property | table () -> sqlalchemy . Table Shortcut to models table from Meta class. Returns : (sqlalchemy.Table) : database table build_select_expression 1 | build_select_expression ( limit : int = None , offset : int = None , order_bys : List = None ) -> sqlalchemy . sql . select Constructs the actual database query used in the QuerySet. If any of the params is not passed the QuerySet own value is used. Arguments : limit (int) : number to limit the query offset (int) : number to offset by order_bys (List) : list of order-by fields names Returns : (sqlalchemy.sql.selectable.Select) : built sqlalchemy select expression filter 1 | filter ( _exclude : bool = False , ** kwargs : Any ) -> \"QuerySet\" Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. You can use special filter suffix to change the filter operands: exact - like album__name__exact='Malibu' (exact match) iexact - like album__name__iexact='malibu' (exact match case insensitive) contains - like album__name__contains='Mal' (sql like) icontains - like album__name__icontains='mal' (sql like case insensitive) in - like album__name__in=['Malibu', 'Barclay'] (sql in) gt - like position__gt=3 (sql >) gte - like position__gte=3 (sql >=) lt - like position__lt=3 (sql <) lte - like position__lte=3 (sql <=) startswith - like album__name__startswith='Mal' (exact start match) istartswith - like album__name__istartswith='mal' (case insensitive) endswith - like album__name__endswith='ibu' (exact end match) iendswith - like album__name__iendswith='IBU' (case insensitive) Arguments : _exclude (bool) : flag if it should be exclude or filter kwargs (Any) : fields names and proper value types Returns : (QuerySet) : filtered QuerySet exclude 1 | exclude ( ** kwargs : Any ) -> \"QuerySet\" Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. So if you use filter(name='John') which is where name = 'John' in SQL, the exclude(name='John') equals to where name <> 'John' Note that all conditions are joined so if you pass multiple values it becomes a union of conditions. exclude(name='John', age>=35) will become where not (name='John' and age>=35) Arguments : kwargs (Any) : fields names and proper value types Returns : (QuerySet) : filtered QuerySet select_related 1 | select_related ( related : Union [ List , str ]) -> \"QuerySet\" Allows to prefetch related models during the same query. With select_related always only one query is run against the database , meaning that one (sometimes complicated) join is generated and later nested models are processed in python. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Arguments : related (Union[List, str]) : list of relation field names, can be linked by '__' to nest Returns : (QuerySet) : QuerySet prefetch_related 1 | prefetch_related ( related : Union [ List , str ]) -> \"QuerySet\" Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database , meaning that you will have multiple queries executed one after another. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Arguments : related (Union[List, str]) : list of relation field names, can be linked by '__' to nest Returns : (QuerySet) : QuerySet fields 1 | fields ( columns : Union [ List , str , Set , Dict ]) -> \"QuerySet\" With fields() you can select subset of model columns to limit the data load. Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). You can select specified fields by passing a str, List[str], Set[str] or dict with nested definition. To include related models use notation {related_name}__{column}[__{optional_next} etc.] . fields() can be called several times, building up the columns to select. If you include related models into select_related() call but you won't specify columns for those models in fields - implies a list of all fields for those nested models. Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Pk column cannot be excluded - it's always auto added even if not explicitly included. You can also pass fields to include as dictionary or set. To mark a field as included in a dictionary use it's name as key and ellipsis as value. To traverse nested models use nested dictionaries. To include fields at last level instead of nested dictionary a set can be used. To include whole nested model specify model related field name and ellipsis. Arguments : columns (Union[List, str, Set, Dict]) : columns to include Returns : (QuerySet) : QuerySet exclude_fields 1 | exclude_fields ( columns : Union [ List , str , Set , Dict ]) -> \"QuerySet\" With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. It's the opposite of fields() method so check documentation above to see what options are available. Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy. Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Pk column cannot be excluded - it's always auto added even if explicitly excluded. Arguments : columns (Union[List, str, Set, Dict]) : columns to exclude Returns : (QuerySet) : QuerySet order_by 1 | order_by ( columns : Union [ List , str ]) -> \"QuerySet\" With order_by() you can order the results from database based on your choice of fields. You can provide a string with field name or list of strings with fields names. Ordering in sql will be applied in order of names you provide in order_by. By default if you do not provide ordering ormar explicitly orders by all primary keys If you are sorting by nested models that causes that the result rows are unsorted by the main model ormar will combine those children rows into one main model. The main model will never duplicate in the result To order by main model field just provide a field name To sort on nested models separate field names with dunder '__'. You can sort this way across all relation types -> ForeignKey , reverse virtual FK and ManyToMany fields. To sort in descending order provide a hyphen in front of the field name Arguments : columns (Union[List, str]) : columns by which models should be sorted Returns : (QuerySet) : QuerySet exists 1 | async exists () -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude if set). Returns : (bool) : result of the check count 1 | async count () -> int Returns number of rows matching the given criteria (applied with filter and exclude if set before). Returns : (int) : number of rows update 1 | async update ( each : bool = False , ** kwargs : Any ) -> int Updates the model table after applying the filters from kwargs. You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table. Arguments : each (bool) : flag if whole table should be affected if no filter is passed kwargs (Any) : fields names and proper value types Returns : (int) : number of updated rows delete 1 | async delete ( each : bool = False , ** kwargs : Any ) -> int Deletes from the model table after applying the filters from kwargs. You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table. Arguments : each (bool) : flag if whole table should be affected if no filter is passed kwargs (Any) : fields names and proper value types Returns : (int) : number of deleted rows paginate 1 | paginate ( page : int , page_size : int = 20 ) -> \"QuerySet\" You can paginate the result which is a combination of offset and limit clauses. Limit is set to page size and offset is set to (page-1) * page_size. Arguments : page_size (int) : numbers of items per page page (int) : page number Returns : (QuerySet) : QuerySet limit 1 | limit ( limit_count : int , limit_raw_sql : bool = None ) -> \"QuerySet\" You can limit the results to desired number of parent models. To limit the actual number of database query rows instead of number of main models use the limit_raw_sql parameter flag, and set it to True . Arguments : limit_raw_sql (bool) : flag if raw sql should be limited limit_count (int) : number of models to limit Returns : (QuerySet) : QuerySet offset 1 | offset ( offset : int , limit_raw_sql : bool = None ) -> \"QuerySet\" You can also offset the results by desired number of main models. To offset the actual number of database query rows instead of number of main models use the limit_raw_sql parameter flag, and set it to True . Arguments : limit_raw_sql (bool) : flag if raw sql should be offset offset (int) : numbers of models to offset Returns : (QuerySet) : QuerySet first 1 | async first ( ** kwargs : Any ) -> \"Model\" Gets the first row from the db ordered by primary key column ascending. Raises : NoMatch : if no rows are returned MultipleMatches : if more than 1 row is returned. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : returned model get 1 | async get ( ** kwargs : Any ) -> \"Model\" Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the last row in db sorted by pk. Passing a criteria is actually calling filter(**kwargs) method described below. Raises : NoMatch : if no rows are returned MultipleMatches : if more than 1 row is returned. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : returned model get_or_create 1 | async get_or_create ( ** kwargs : Any ) -> \"Model\" Combination of create and get methods. Tries to get a row meeting the criteria fro kwargs and if NoMatch exception is raised it creates a new one with given kwargs. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : returned or created Model update_or_create 1 | async update_or_create ( ** kwargs : Any ) -> \"Model\" Updates the model, or in case there is no match in database creates a new one. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : updated or created model all 1 | async all ( ** kwargs : Any ) -> Sequence [ Optional [ \"Model\" ]] Returns all rows from a database for given model for set filter options. Passing kwargs is a shortcut and equals to calling filter(**kwrags).all() . If there are no rows meeting the criteria an empty list is returned. Arguments : kwargs (Any) : fields names and proper value types Returns : (List[Model]) : list of returned models create 1 | async create ( ** kwargs : Any ) -> \"Model\" Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set). The allowed kwargs are Model fields names and proper value types. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : created model bulk_create 1 | async bulk_create ( objects : List [ \"Model\" ]) -> None Performs a bulk update in one database session to speed up the process. Allows you to create multiple objects at once. A valid list of Model objects needs to be passed. Bulk operations do not send signals. Arguments : objects (List[Model]) : list of ormar models already initialized and ready to save. bulk_update 1 | async bulk_update ( objects : List [ \"Model\" ], columns : List [ str ] = None ) -> None Performs bulk update in one database session to speed up the process. Allows to update multiple instance at once. All Models passed need to have primary key column populated. You can also select which fields to update by passing columns list as a list of string names. Bulk operations do not send signals. Arguments : objects (List[Model]) : list of ormar models columns (List[str]) : list of columns to update","title":"Query Set"},{"location":"api/query-set/query-set/#querysetqueryset","text":"","title":"queryset.queryset"},{"location":"api/query-set/query-set/#queryset-objects","text":"1 class QuerySet () Main class to perform database queries, exposed on each model as objects attribute.","title":"QuerySet Objects"},{"location":"api/query-set/query-set/#model_meta","text":"1 2 | @property | model_meta () -> \"ModelMeta\" Shortcut to model class Meta set on QuerySet model. Returns : (model Meta class) : Meta class of the model","title":"model_meta"},{"location":"api/query-set/query-set/#model","text":"1 2 | @property | model () -> Type [ \"Model\" ] Shortcut to model class set on QuerySet. Returns : (Type[Model]) : model class","title":"model"},{"location":"api/query-set/query-set/#_prefetch_related_models","text":"1 | async _prefetch_related_models ( models : Sequence [ Optional [ \"Model\" ]], rows : List ) -> Sequence [ Optional [ \"Model\" ]] Performs prefetch query for selected models names. Arguments : models (List[Model]) : list of already parsed main Models from main query rows (List[sqlalchemy.engine.result.RowProxy]) : database rows from main query Returns : (List[Model]) : list of models with prefetch models populated","title":"_prefetch_related_models"},{"location":"api/query-set/query-set/#_process_query_result_rows","text":"1 | _process_query_result_rows ( rows : List ) -> Sequence [ Optional [ \"Model\" ]] Process database rows and initialize ormar Model from each of the rows. Arguments : rows (List[sqlalchemy.engine.result.RowProxy]) : list of database rows from query result Returns : (List[Model]) : list of models","title":"_process_query_result_rows"},{"location":"api/query-set/query-set/#check_single_result_rows_count","text":"1 2 | @staticmethod | check_single_result_rows_count ( rows : Sequence [ Optional [ \"Model\" ]]) -> None Verifies if the result has one and only one row. Arguments : rows (List[Model]) : one element list of Models","title":"check_single_result_rows_count"},{"location":"api/query-set/query-set/#database","text":"1 2 | @property | database () -> databases . Database Shortcut to models database from Meta class. Returns : (databases.Database) : database","title":"database"},{"location":"api/query-set/query-set/#table","text":"1 2 | @property | table () -> sqlalchemy . Table Shortcut to models table from Meta class. Returns : (sqlalchemy.Table) : database table","title":"table"},{"location":"api/query-set/query-set/#build_select_expression","text":"1 | build_select_expression ( limit : int = None , offset : int = None , order_bys : List = None ) -> sqlalchemy . sql . select Constructs the actual database query used in the QuerySet. If any of the params is not passed the QuerySet own value is used. Arguments : limit (int) : number to limit the query offset (int) : number to offset by order_bys (List) : list of order-by fields names Returns : (sqlalchemy.sql.selectable.Select) : built sqlalchemy select expression","title":"build_select_expression"},{"location":"api/query-set/query-set/#filter","text":"1 | filter ( _exclude : bool = False , ** kwargs : Any ) -> \"QuerySet\" Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. You can use special filter suffix to change the filter operands: exact - like album__name__exact='Malibu' (exact match) iexact - like album__name__iexact='malibu' (exact match case insensitive) contains - like album__name__contains='Mal' (sql like) icontains - like album__name__icontains='mal' (sql like case insensitive) in - like album__name__in=['Malibu', 'Barclay'] (sql in) gt - like position__gt=3 (sql >) gte - like position__gte=3 (sql >=) lt - like position__lt=3 (sql <) lte - like position__lte=3 (sql <=) startswith - like album__name__startswith='Mal' (exact start match) istartswith - like album__name__istartswith='mal' (case insensitive) endswith - like album__name__endswith='ibu' (exact end match) iendswith - like album__name__iendswith='IBU' (case insensitive) Arguments : _exclude (bool) : flag if it should be exclude or filter kwargs (Any) : fields names and proper value types Returns : (QuerySet) : filtered QuerySet","title":"filter"},{"location":"api/query-set/query-set/#exclude","text":"1 | exclude ( ** kwargs : Any ) -> \"QuerySet\" Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. So if you use filter(name='John') which is where name = 'John' in SQL, the exclude(name='John') equals to where name <> 'John' Note that all conditions are joined so if you pass multiple values it becomes a union of conditions. exclude(name='John', age>=35) will become where not (name='John' and age>=35) Arguments : kwargs (Any) : fields names and proper value types Returns : (QuerySet) : filtered QuerySet","title":"exclude"},{"location":"api/query-set/query-set/#select_related","text":"1 | select_related ( related : Union [ List , str ]) -> \"QuerySet\" Allows to prefetch related models during the same query. With select_related always only one query is run against the database , meaning that one (sometimes complicated) join is generated and later nested models are processed in python. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Arguments : related (Union[List, str]) : list of relation field names, can be linked by '__' to nest Returns : (QuerySet) : QuerySet","title":"select_related"},{"location":"api/query-set/query-set/#prefetch_related","text":"1 | prefetch_related ( related : Union [ List , str ]) -> \"QuerySet\" Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database , meaning that you will have multiple queries executed one after another. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Arguments : related (Union[List, str]) : list of relation field names, can be linked by '__' to nest Returns : (QuerySet) : QuerySet","title":"prefetch_related"},{"location":"api/query-set/query-set/#fields","text":"1 | fields ( columns : Union [ List , str , Set , Dict ]) -> \"QuerySet\" With fields() you can select subset of model columns to limit the data load. Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). You can select specified fields by passing a str, List[str], Set[str] or dict with nested definition. To include related models use notation {related_name}__{column}[__{optional_next} etc.] . fields() can be called several times, building up the columns to select. If you include related models into select_related() call but you won't specify columns for those models in fields - implies a list of all fields for those nested models. Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Pk column cannot be excluded - it's always auto added even if not explicitly included. You can also pass fields to include as dictionary or set. To mark a field as included in a dictionary use it's name as key and ellipsis as value. To traverse nested models use nested dictionaries. To include fields at last level instead of nested dictionary a set can be used. To include whole nested model specify model related field name and ellipsis. Arguments : columns (Union[List, str, Set, Dict]) : columns to include Returns : (QuerySet) : QuerySet","title":"fields"},{"location":"api/query-set/query-set/#exclude_fields","text":"1 | exclude_fields ( columns : Union [ List , str , Set , Dict ]) -> \"QuerySet\" With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. It's the opposite of fields() method so check documentation above to see what options are available. Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy. Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Pk column cannot be excluded - it's always auto added even if explicitly excluded. Arguments : columns (Union[List, str, Set, Dict]) : columns to exclude Returns : (QuerySet) : QuerySet","title":"exclude_fields"},{"location":"api/query-set/query-set/#order_by","text":"1 | order_by ( columns : Union [ List , str ]) -> \"QuerySet\" With order_by() you can order the results from database based on your choice of fields. You can provide a string with field name or list of strings with fields names. Ordering in sql will be applied in order of names you provide in order_by. By default if you do not provide ordering ormar explicitly orders by all primary keys If you are sorting by nested models that causes that the result rows are unsorted by the main model ormar will combine those children rows into one main model. The main model will never duplicate in the result To order by main model field just provide a field name To sort on nested models separate field names with dunder '__'. You can sort this way across all relation types -> ForeignKey , reverse virtual FK and ManyToMany fields. To sort in descending order provide a hyphen in front of the field name Arguments : columns (Union[List, str]) : columns by which models should be sorted Returns : (QuerySet) : QuerySet","title":"order_by"},{"location":"api/query-set/query-set/#exists","text":"1 | async exists () -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude if set). Returns : (bool) : result of the check","title":"exists"},{"location":"api/query-set/query-set/#count","text":"1 | async count () -> int Returns number of rows matching the given criteria (applied with filter and exclude if set before). Returns : (int) : number of rows","title":"count"},{"location":"api/query-set/query-set/#update","text":"1 | async update ( each : bool = False , ** kwargs : Any ) -> int Updates the model table after applying the filters from kwargs. You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table. Arguments : each (bool) : flag if whole table should be affected if no filter is passed kwargs (Any) : fields names and proper value types Returns : (int) : number of updated rows","title":"update"},{"location":"api/query-set/query-set/#delete","text":"1 | async delete ( each : bool = False , ** kwargs : Any ) -> int Deletes from the model table after applying the filters from kwargs. You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table. Arguments : each (bool) : flag if whole table should be affected if no filter is passed kwargs (Any) : fields names and proper value types Returns : (int) : number of deleted rows","title":"delete"},{"location":"api/query-set/query-set/#paginate","text":"1 | paginate ( page : int , page_size : int = 20 ) -> \"QuerySet\" You can paginate the result which is a combination of offset and limit clauses. Limit is set to page size and offset is set to (page-1) * page_size. Arguments : page_size (int) : numbers of items per page page (int) : page number Returns : (QuerySet) : QuerySet","title":"paginate"},{"location":"api/query-set/query-set/#limit","text":"1 | limit ( limit_count : int , limit_raw_sql : bool = None ) -> \"QuerySet\" You can limit the results to desired number of parent models. To limit the actual number of database query rows instead of number of main models use the limit_raw_sql parameter flag, and set it to True . Arguments : limit_raw_sql (bool) : flag if raw sql should be limited limit_count (int) : number of models to limit Returns : (QuerySet) : QuerySet","title":"limit"},{"location":"api/query-set/query-set/#offset","text":"1 | offset ( offset : int , limit_raw_sql : bool = None ) -> \"QuerySet\" You can also offset the results by desired number of main models. To offset the actual number of database query rows instead of number of main models use the limit_raw_sql parameter flag, and set it to True . Arguments : limit_raw_sql (bool) : flag if raw sql should be offset offset (int) : numbers of models to offset Returns : (QuerySet) : QuerySet","title":"offset"},{"location":"api/query-set/query-set/#first","text":"1 | async first ( ** kwargs : Any ) -> \"Model\" Gets the first row from the db ordered by primary key column ascending. Raises : NoMatch : if no rows are returned MultipleMatches : if more than 1 row is returned. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : returned model","title":"first"},{"location":"api/query-set/query-set/#get","text":"1 | async get ( ** kwargs : Any ) -> \"Model\" Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the last row in db sorted by pk. Passing a criteria is actually calling filter(**kwargs) method described below. Raises : NoMatch : if no rows are returned MultipleMatches : if more than 1 row is returned. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : returned model","title":"get"},{"location":"api/query-set/query-set/#get_or_create","text":"1 | async get_or_create ( ** kwargs : Any ) -> \"Model\" Combination of create and get methods. Tries to get a row meeting the criteria fro kwargs and if NoMatch exception is raised it creates a new one with given kwargs. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : returned or created Model","title":"get_or_create"},{"location":"api/query-set/query-set/#update_or_create","text":"1 | async update_or_create ( ** kwargs : Any ) -> \"Model\" Updates the model, or in case there is no match in database creates a new one. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : updated or created model","title":"update_or_create"},{"location":"api/query-set/query-set/#all","text":"1 | async all ( ** kwargs : Any ) -> Sequence [ Optional [ \"Model\" ]] Returns all rows from a database for given model for set filter options. Passing kwargs is a shortcut and equals to calling filter(**kwrags).all() . If there are no rows meeting the criteria an empty list is returned. Arguments : kwargs (Any) : fields names and proper value types Returns : (List[Model]) : list of returned models","title":"all"},{"location":"api/query-set/query-set/#create","text":"1 | async create ( ** kwargs : Any ) -> \"Model\" Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set). The allowed kwargs are Model fields names and proper value types. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : created model","title":"create"},{"location":"api/query-set/query-set/#bulk_create","text":"1 | async bulk_create ( objects : List [ \"Model\" ]) -> None Performs a bulk update in one database session to speed up the process. Allows you to create multiple objects at once. A valid list of Model objects needs to be passed. Bulk operations do not send signals. Arguments : objects (List[Model]) : list of ormar models already initialized and ready to save.","title":"bulk_create"},{"location":"api/query-set/query-set/#bulk_update","text":"1 | async bulk_update ( objects : List [ \"Model\" ], columns : List [ str ] = None ) -> None Performs bulk update in one database session to speed up the process. Allows to update multiple instance at once. All Models passed need to have primary key column populated. You can also select which fields to update by passing columns list as a list of string names. Bulk operations do not send signals. Arguments : objects (List[Model]) : list of ormar models columns (List[str]) : list of columns to update","title":"bulk_update"},{"location":"api/query-set/query/","text":"queryset.query Query Objects 1 class Query () _init_sorted_orders 1 | _init_sorted_orders () -> None Initialize empty order_by dict to be populated later during the query call prefixed_pk_name 1 2 | @property | prefixed_pk_name () -> str Shortcut for extracting prefixed with alias primary key column name from main model Returns : (str) : alias of pk column prefix with table name. alias 1 | alias ( name : str ) -> str Shortcut to extracting column alias from given master model. Arguments : name (str) : name of column Returns : (str) : alias of given column name apply_order_bys_for_primary_model 1 | apply_order_bys_for_primary_model () -> None Applies order_by queries on main model when it's used as a subquery. That way the subquery with limit and offset only on main model has proper sorting applied and correct models are fetched. _pagination_query_required 1 | _pagination_query_required () -> bool Checks if limit or offset are set, the flag limit_sql_raw is not set and query has select_related applied. Otherwise we can limit/offset normally at the end of whole query. Returns : (bool) : result of the check build_select_expression 1 | build_select_expression () -> Tuple [ sqlalchemy . sql . select , List [ str ]] Main entry point from outside (after proper initialization). Extracts columns list to fetch, construct all required joins for select related, then applies all conditional and sort clauses. Returns ready to run query with all joins and clauses. Returns : (sqlalchemy.sql.selectable.Select) : ready to run query with all joins and clauses. _build_pagination_subquery 1 | _build_pagination_subquery () -> sqlalchemy . sql . select In order to apply limit and offset on main table in join only (otherwise you can get only partially constructed main model if number of children exceeds the applied limit and select_related is used) Used also to change first and get() without argument behaviour. Needed only if limit or offset are set, the flag limit_sql_raw is not set and query has select_related applied. Otherwise we can limit/offset normally at the end of whole query. Returns : (sqlalchemy.sql.select) : constructed subquery on main table with limit, offset and order applied _apply_expression_modifiers 1 | _apply_expression_modifiers ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Receives the select query (might be join) and applies: * Filter clauses * Exclude filter clauses * Limit clauses * Offset clauses * Order by clauses Returns complete ready to run query. Arguments : expr (sqlalchemy.sql.selectable.Select) : select expression before clauses Returns : (sqlalchemy.sql.selectable.Select) : expresion with all present clauses applied _reset_query_parameters 1 | _reset_query_parameters () -> None Although it should be created each time before the call we reset the key params anyway.","title":"Query"},{"location":"api/query-set/query/#querysetquery","text":"","title":"queryset.query"},{"location":"api/query-set/query/#query-objects","text":"1 class Query ()","title":"Query Objects"},{"location":"api/query-set/query/#_init_sorted_orders","text":"1 | _init_sorted_orders () -> None Initialize empty order_by dict to be populated later during the query call","title":"_init_sorted_orders"},{"location":"api/query-set/query/#prefixed_pk_name","text":"1 2 | @property | prefixed_pk_name () -> str Shortcut for extracting prefixed with alias primary key column name from main model Returns : (str) : alias of pk column prefix with table name.","title":"prefixed_pk_name"},{"location":"api/query-set/query/#alias","text":"1 | alias ( name : str ) -> str Shortcut to extracting column alias from given master model. Arguments : name (str) : name of column Returns : (str) : alias of given column name","title":"alias"},{"location":"api/query-set/query/#apply_order_bys_for_primary_model","text":"1 | apply_order_bys_for_primary_model () -> None Applies order_by queries on main model when it's used as a subquery. That way the subquery with limit and offset only on main model has proper sorting applied and correct models are fetched.","title":"apply_order_bys_for_primary_model"},{"location":"api/query-set/query/#_pagination_query_required","text":"1 | _pagination_query_required () -> bool Checks if limit or offset are set, the flag limit_sql_raw is not set and query has select_related applied. Otherwise we can limit/offset normally at the end of whole query. Returns : (bool) : result of the check","title":"_pagination_query_required"},{"location":"api/query-set/query/#build_select_expression","text":"1 | build_select_expression () -> Tuple [ sqlalchemy . sql . select , List [ str ]] Main entry point from outside (after proper initialization). Extracts columns list to fetch, construct all required joins for select related, then applies all conditional and sort clauses. Returns ready to run query with all joins and clauses. Returns : (sqlalchemy.sql.selectable.Select) : ready to run query with all joins and clauses.","title":"build_select_expression"},{"location":"api/query-set/query/#_build_pagination_subquery","text":"1 | _build_pagination_subquery () -> sqlalchemy . sql . select In order to apply limit and offset on main table in join only (otherwise you can get only partially constructed main model if number of children exceeds the applied limit and select_related is used) Used also to change first and get() without argument behaviour. Needed only if limit or offset are set, the flag limit_sql_raw is not set and query has select_related applied. Otherwise we can limit/offset normally at the end of whole query. Returns : (sqlalchemy.sql.select) : constructed subquery on main table with limit, offset and order applied","title":"_build_pagination_subquery"},{"location":"api/query-set/query/#_apply_expression_modifiers","text":"1 | _apply_expression_modifiers ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Receives the select query (might be join) and applies: * Filter clauses * Exclude filter clauses * Limit clauses * Offset clauses * Order by clauses Returns complete ready to run query. Arguments : expr (sqlalchemy.sql.selectable.Select) : select expression before clauses Returns : (sqlalchemy.sql.selectable.Select) : expresion with all present clauses applied","title":"_apply_expression_modifiers"},{"location":"api/query-set/query/#_reset_query_parameters","text":"1 | _reset_query_parameters () -> None Although it should be created each time before the call we reset the key params anyway.","title":"_reset_query_parameters"},{"location":"api/query-set/utils/","text":"queryset.utils check_node_not_dict_or_not_last_node 1 check_node_not_dict_or_not_last_node ( part : str , parts : List , current_level : Any ) -> bool Checks if given name is not present in the current level of the structure. Checks if given name is not the last name in the split list of parts. Checks if the given name in current level is not a dictionary. All those checks verify if there is a need for deeper traversal. Arguments : part (str) : parts (List[str]) : current_level (Any) : current level of the traversed structure Returns : (bool) : result of the check translate_list_to_dict 1 translate_list_to_dict ( list_to_trans : Union [ List , Set ], is_order : bool = False ) -> Dict Splits the list of strings by '__' and converts them to dictionary with nested models grouped by parent model. That way each model appears only once in the whole dictionary and children are grouped under parent name. Default required key ise Ellipsis like in pydantic. Arguments : list_to_trans (set) : input list is_order (bool) : flag if change affects order_by clauses are they require special default value with sort order. Returns : (Dict) : converted to dictionary input list convert_set_to_required_dict 1 convert_set_to_required_dict ( set_to_convert : set ) -> Dict Converts set to dictionary of required keys. Required key is Ellipsis. Arguments : set_to_convert (set) : set to convert to dict Returns : (Dict) : set converted to dict of ellipsis update 1 update ( current_dict : Any , updating_dict : Any ) -> Dict Update one dict with another but with regard for nested keys. That way nested sets are unionised, dicts updated and only other values are overwritten. Arguments : current_dict (Dict[str, ellipsis]) : dict to update updating_dict (Dict) : dict with values to update Returns : (Dict) : combination of both dicts update_dict_from_list 1 update_dict_from_list ( curr_dict : Dict , list_to_update : Union [ List , Set ]) -> Dict Converts the list into dictionary and later performs special update, where nested keys that are sets or dicts are combined and not overwritten. Arguments : curr_dict (Dict) : dict to update list_to_update (List[str]) : list with values to update the dict Returns : (Dict) : updated dict extract_nested_models 1 extract_nested_models ( model : \"Model\" , model_type : Type [ \"Model\" ], select_dict : Dict , extracted : Dict ) -> None Iterates over model relations and extracts all nested models from select_dict and puts them in corresponding list under relation name in extracted dict.keys Basically flattens all relation to dictionary of all related models, that can be used on several models and extract all of their children into dictionary of lists witch children models. Goes also into nested relations if needed (specified in select_dict). Arguments : model (Model) : parent Model model_type (Type[Model]) : parent model class select_dict (Dict) : dictionary of related models from select_related extracted (Dict) : dictionary with already extracted models extract_models_to_dict_of_lists 1 extract_models_to_dict_of_lists ( model_type : Type [ \"Model\" ], models : Sequence [ \"Model\" ], select_dict : Dict , extracted : Dict = None ) -> Dict Receives a list of models and extracts all of the children and their children into dictionary of lists with children models, flattening the structure to one dict with all children models under their relation keys. Arguments : model_type (Type[Model]) : parent model class models (List[Model]) : list of models from which related models should be extracted. select_dict (Dict) : dictionary of related models from select_related extracted (Dict) : dictionary with already extracted models Returns : (Dict) : dictionary of lists f related models get_relationship_alias_model_and_str 1 get_relationship_alias_model_and_str ( source_model : Type [ \"Model\" ], related_parts : List ) -> Tuple [ str , Type [ \"Model\" ], str ] Walks the relation to retrieve the actual model on which the clause should be constructed, extracts alias based on last relation leading to target model. Arguments : related_parts (Union[List, List[str]]) : list of related names extracted from string source_model (Type[Model]) : model from which relation starts Returns : (Tuple[str, Type[\"Model\"], str]) : table prefix, target model and relation string","title":"Utils"},{"location":"api/query-set/utils/#querysetutils","text":"","title":"queryset.utils"},{"location":"api/query-set/utils/#check_node_not_dict_or_not_last_node","text":"1 check_node_not_dict_or_not_last_node ( part : str , parts : List , current_level : Any ) -> bool Checks if given name is not present in the current level of the structure. Checks if given name is not the last name in the split list of parts. Checks if the given name in current level is not a dictionary. All those checks verify if there is a need for deeper traversal. Arguments : part (str) : parts (List[str]) : current_level (Any) : current level of the traversed structure Returns : (bool) : result of the check","title":"check_node_not_dict_or_not_last_node"},{"location":"api/query-set/utils/#translate_list_to_dict","text":"1 translate_list_to_dict ( list_to_trans : Union [ List , Set ], is_order : bool = False ) -> Dict Splits the list of strings by '__' and converts them to dictionary with nested models grouped by parent model. That way each model appears only once in the whole dictionary and children are grouped under parent name. Default required key ise Ellipsis like in pydantic. Arguments : list_to_trans (set) : input list is_order (bool) : flag if change affects order_by clauses are they require special default value with sort order. Returns : (Dict) : converted to dictionary input list","title":"translate_list_to_dict"},{"location":"api/query-set/utils/#convert_set_to_required_dict","text":"1 convert_set_to_required_dict ( set_to_convert : set ) -> Dict Converts set to dictionary of required keys. Required key is Ellipsis. Arguments : set_to_convert (set) : set to convert to dict Returns : (Dict) : set converted to dict of ellipsis","title":"convert_set_to_required_dict"},{"location":"api/query-set/utils/#update","text":"1 update ( current_dict : Any , updating_dict : Any ) -> Dict Update one dict with another but with regard for nested keys. That way nested sets are unionised, dicts updated and only other values are overwritten. Arguments : current_dict (Dict[str, ellipsis]) : dict to update updating_dict (Dict) : dict with values to update Returns : (Dict) : combination of both dicts","title":"update"},{"location":"api/query-set/utils/#update_dict_from_list","text":"1 update_dict_from_list ( curr_dict : Dict , list_to_update : Union [ List , Set ]) -> Dict Converts the list into dictionary and later performs special update, where nested keys that are sets or dicts are combined and not overwritten. Arguments : curr_dict (Dict) : dict to update list_to_update (List[str]) : list with values to update the dict Returns : (Dict) : updated dict","title":"update_dict_from_list"},{"location":"api/query-set/utils/#extract_nested_models","text":"1 extract_nested_models ( model : \"Model\" , model_type : Type [ \"Model\" ], select_dict : Dict , extracted : Dict ) -> None Iterates over model relations and extracts all nested models from select_dict and puts them in corresponding list under relation name in extracted dict.keys Basically flattens all relation to dictionary of all related models, that can be used on several models and extract all of their children into dictionary of lists witch children models. Goes also into nested relations if needed (specified in select_dict). Arguments : model (Model) : parent Model model_type (Type[Model]) : parent model class select_dict (Dict) : dictionary of related models from select_related extracted (Dict) : dictionary with already extracted models","title":"extract_nested_models"},{"location":"api/query-set/utils/#extract_models_to_dict_of_lists","text":"1 extract_models_to_dict_of_lists ( model_type : Type [ \"Model\" ], models : Sequence [ \"Model\" ], select_dict : Dict , extracted : Dict = None ) -> Dict Receives a list of models and extracts all of the children and their children into dictionary of lists with children models, flattening the structure to one dict with all children models under their relation keys. Arguments : model_type (Type[Model]) : parent model class models (List[Model]) : list of models from which related models should be extracted. select_dict (Dict) : dictionary of related models from select_related extracted (Dict) : dictionary with already extracted models Returns : (Dict) : dictionary of lists f related models","title":"extract_models_to_dict_of_lists"},{"location":"api/query-set/utils/#get_relationship_alias_model_and_str","text":"1 get_relationship_alias_model_and_str ( source_model : Type [ \"Model\" ], related_parts : List ) -> Tuple [ str , Type [ \"Model\" ], str ] Walks the relation to retrieve the actual model on which the clause should be constructed, extracts alias based on last relation leading to target model. Arguments : related_parts (Union[List, List[str]]) : list of related names extracted from string source_model (Type[Model]) : model from which relation starts Returns : (Tuple[str, Type[\"Model\"], str]) : table prefix, target model and relation string","title":"get_relationship_alias_model_and_str"},{"location":"api/relations/alias-manager/","text":"relations.alias_manager get_table_alias 1 get_table_alias () -> str Creates a random string that is used to alias tables in joins. It's necessary that each relation has it's own aliases cause you can link to the same target tables from multiple fields on one model as well as from multiple different models in one join. Returns : (str) : randomly generated alias AliasManager Objects 1 class AliasManager () Keep all aliases of relations between different tables. One global instance is shared between all models. prefixed_columns 1 2 | @staticmethod | prefixed_columns ( alias : str , table : sqlalchemy . Table , fields : List = None ) -> List [ text ] Creates a list of aliases sqlalchemy text clauses from string alias and sqlalchemy.Table. Optional list of fields to include can be passed to extract only those columns. List has to have sqlalchemy names of columns (ormar aliases) not the ormar ones. Arguments : alias (str) : alias of given table table (sqlalchemy.Table) : table from which fields should be aliased fields (Optional[List[str]]) : fields to include Returns : (List[text]) : list of sqlalchemy text clauses with \"column name as aliased name\" prefixed_table_name 1 2 | @staticmethod | prefixed_table_name ( alias : str , name : str ) -> text Creates text clause with table name with aliased name. Arguments : alias (str) : alias of given table name (str) : table name Returns : (sqlalchemy text clause) : sqlalchemy text clause as \"table_name aliased_name\" add_relation_type 1 | add_relation_type ( source_model : Type [ \"Model\" ], relation_name : str , reverse_name : str = None ) -> None Registers the relations defined in ormar models. Given the relation it registers also the reverse side of this relation. Used by both ForeignKey and ManyToMany relations. Each relation is registered as Model name and relation name. Each alias registered has to be unique. Aliases are used to construct joins to assure proper links between tables. That way you can link to the same target tables from multiple fields on one model as well as from multiple different models in one join. Arguments : source_model (source Model) : model with relation defined relation_name (str) : name of the relation to define reverse_name (Optional[str]) : name of related_name fo given relation for m2m relations Returns : (None) : none add_alias 1 | add_alias ( alias_key : str ) -> str Adds alias to the dictionary of aliases under given key. Arguments : alias_key (str) : key of relation to generate alias for Returns : (str) : generated alias resolve_relation_alias 1 | resolve_relation_alias ( from_model : Type [ \"Model\" ], relation_name : str ) -> str Given model and relation name returns the alias for this relation. Arguments : from_model (source Model) : model with relation defined relation_name (str) : name of the relation field Returns : (str) : alias of the relation","title":"Alias Manager"},{"location":"api/relations/alias-manager/#relationsalias_manager","text":"","title":"relations.alias_manager"},{"location":"api/relations/alias-manager/#get_table_alias","text":"1 get_table_alias () -> str Creates a random string that is used to alias tables in joins. It's necessary that each relation has it's own aliases cause you can link to the same target tables from multiple fields on one model as well as from multiple different models in one join. Returns : (str) : randomly generated alias","title":"get_table_alias"},{"location":"api/relations/alias-manager/#aliasmanager-objects","text":"1 class AliasManager () Keep all aliases of relations between different tables. One global instance is shared between all models.","title":"AliasManager Objects"},{"location":"api/relations/alias-manager/#prefixed_columns","text":"1 2 | @staticmethod | prefixed_columns ( alias : str , table : sqlalchemy . Table , fields : List = None ) -> List [ text ] Creates a list of aliases sqlalchemy text clauses from string alias and sqlalchemy.Table. Optional list of fields to include can be passed to extract only those columns. List has to have sqlalchemy names of columns (ormar aliases) not the ormar ones. Arguments : alias (str) : alias of given table table (sqlalchemy.Table) : table from which fields should be aliased fields (Optional[List[str]]) : fields to include Returns : (List[text]) : list of sqlalchemy text clauses with \"column name as aliased name\"","title":"prefixed_columns"},{"location":"api/relations/alias-manager/#prefixed_table_name","text":"1 2 | @staticmethod | prefixed_table_name ( alias : str , name : str ) -> text Creates text clause with table name with aliased name. Arguments : alias (str) : alias of given table name (str) : table name Returns : (sqlalchemy text clause) : sqlalchemy text clause as \"table_name aliased_name\"","title":"prefixed_table_name"},{"location":"api/relations/alias-manager/#add_relation_type","text":"1 | add_relation_type ( source_model : Type [ \"Model\" ], relation_name : str , reverse_name : str = None ) -> None Registers the relations defined in ormar models. Given the relation it registers also the reverse side of this relation. Used by both ForeignKey and ManyToMany relations. Each relation is registered as Model name and relation name. Each alias registered has to be unique. Aliases are used to construct joins to assure proper links between tables. That way you can link to the same target tables from multiple fields on one model as well as from multiple different models in one join. Arguments : source_model (source Model) : model with relation defined relation_name (str) : name of the relation to define reverse_name (Optional[str]) : name of related_name fo given relation for m2m relations Returns : (None) : none","title":"add_relation_type"},{"location":"api/relations/alias-manager/#add_alias","text":"1 | add_alias ( alias_key : str ) -> str Adds alias to the dictionary of aliases under given key. Arguments : alias_key (str) : key of relation to generate alias for Returns : (str) : generated alias","title":"add_alias"},{"location":"api/relations/alias-manager/#resolve_relation_alias","text":"1 | resolve_relation_alias ( from_model : Type [ \"Model\" ], relation_name : str ) -> str Given model and relation name returns the alias for this relation. Arguments : from_model (source Model) : model with relation defined relation_name (str) : name of the relation field Returns : (str) : alias of the relation","title":"resolve_relation_alias"},{"location":"api/relations/queryset-proxy/","text":"relations.querysetproxy QuerysetProxy Objects 1 class QuerysetProxy ( ormar . QuerySetProtocol ) Exposes QuerySet methods on relations, but also handles creating and removing of through Models for m2m relations. queryset 1 2 | @property | queryset () -> \"QuerySet\" Returns queryset if it's set, AttributeError otherwise. Returns : (QuerySet) : QuerySet queryset 1 2 | @queryset . setter | queryset ( value : \"QuerySet\" ) -> None Set's the queryset. Initialized in RelationProxy. Arguments : value (QuerySet) : QuerySet _assign_child_to_parent 1 | _assign_child_to_parent ( child : Optional [ \"T\" ]) -> None Registers child in parents RelationManager. Arguments : child (Model) : child to register on parent side. _register_related 1 | _register_related ( child : Union [ \"T\" , Sequence [ Optional [ \"T\" ]]]) -> None Registers child/ children in parents RelationManager. Arguments : child (Union[Model,List[Model]]) : child or list of children models to register. _clean_items_on_load 1 | _clean_items_on_load () -> None Cleans the current list of the related models. create_through_instance 1 | async create_through_instance ( child : \"T\" ) -> None Crete a through model instance in the database for m2m relations. Arguments : child (Model) : child model instance delete_through_instance 1 | async delete_through_instance ( child : \"T\" ) -> None Removes through model instance from the database for m2m relations. Arguments : child (Model) : child model instance exists 1 | async exists () -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude if set). Actual call delegated to QuerySet. Returns : (bool) : result of the check count 1 | async count () -> int Returns number of rows matching the given criteria (applied with filter and exclude if set before). Actual call delegated to QuerySet. Returns : (int) : number of rows clear 1 | async clear ( keep_reversed : bool = True ) -> int Removes all related models from given relation. Removes all through models for m2m relation. For reverse FK relations keep_reversed flag marks if the reversed models should be kept or deleted from the database too (False means that models will be deleted, and not only removed from relation). Arguments : keep_reversed (bool) : flag if reverse models in reverse FK should be deleted or not, keep_reversed=False deletes them from database. Returns : (int) : number of deleted models first 1 | async first ( ** kwargs : Any ) -> \"Model\" Gets the first row from the db ordered by primary key column ascending. Actual call delegated to QuerySet. List of related models is cleared before the call. Arguments : kwargs () : Returns : (_asyncio.Future) : get 1 | async get ( ** kwargs : Any ) -> \"Model\" Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the last row in db sorted by pk. Passing a criteria is actually calling filter(**kwargs) method described below. Actual call delegated to QuerySet. List of related models is cleared before the call. Raises : NoMatch : if no rows are returned MultipleMatches : if more than 1 row is returned. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : returned model all 1 | async all ( ** kwargs : Any ) -> Sequence [ Optional [ \"Model\" ]] Returns all rows from a database for given model for set filter options. Passing kwargs is a shortcut and equals to calling filter(**kwrags).all() . If there are no rows meeting the criteria an empty list is returned. Actual call delegated to QuerySet. List of related models is cleared before the call. Arguments : kwargs (Any) : fields names and proper value types Returns : (List[Model]) : list of returned models create 1 | async create ( ** kwargs : Any ) -> \"Model\" Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set). The allowed kwargs are Model fields names and proper value types. For m2m relation the through model is created automatically. Actual call delegated to QuerySet. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : created model get_or_create 1 | async get_or_create ( ** kwargs : Any ) -> \"Model\" Combination of create and get methods. Tries to get a row meeting the criteria fro kwargs and if NoMatch exception is raised it creates a new one with given kwargs. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : returned or created Model update_or_create 1 | async update_or_create ( ** kwargs : Any ) -> \"Model\" Updates the model, or in case there is no match in database creates a new one. Actual call delegated to QuerySet. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : updated or created model filter 1 | filter ( ** kwargs : Any ) -> \"QuerysetProxy\" Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. You can use special filter suffix to change the filter operands: exact - like album__name__exact='Malibu' (exact match) iexact - like album__name__iexact='malibu' (exact match case insensitive) contains - like album__name__contains='Mal' (sql like) icontains - like album__name__icontains='mal' (sql like case insensitive) in - like album__name__in=['Malibu', 'Barclay'] (sql in) gt - like position__gt=3 (sql >) gte - like position__gte=3 (sql >=) lt - like position__lt=3 (sql <) lte - like position__lte=3 (sql <=) startswith - like album__name__startswith='Mal' (exact start match) istartswith - like album__name__istartswith='mal' (case insensitive) endswith - like album__name__endswith='ibu' (exact end match) iendswith - like album__name__iendswith='IBU' (case insensitive) Actual call delegated to QuerySet. Arguments : kwargs (Any) : fields names and proper value types Returns : (QuerysetProxy) : filtered QuerysetProxy exclude 1 | exclude ( ** kwargs : Any ) -> \"QuerysetProxy\" Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. So if you use filter(name='John') which is where name = 'John' in SQL, the exclude(name='John') equals to where name <> 'John' Note that all conditions are joined so if you pass multiple values it becomes a union of conditions. exclude(name='John', age>=35) will become where not (name='John' and age>=35) Actual call delegated to QuerySet. Arguments : kwargs (Any) : fields names and proper value types Returns : (QuerysetProxy) : filtered QuerysetProxy select_related 1 | select_related ( related : Union [ List , str ]) -> \"QuerysetProxy\" Allows to prefetch related models during the same query. With select_related always only one query is run against the database , meaning that one (sometimes complicated) join is generated and later nested models are processed in python. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Actual call delegated to QuerySet. Arguments : related (Union[List, str]) : list of relation field names, can be linked by '__' to nest Returns : (QuerysetProxy) : QuerysetProxy prefetch_related 1 | prefetch_related ( related : Union [ List , str ]) -> \"QuerysetProxy\" Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database , meaning that you will have multiple queries executed one after another. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Actual call delegated to QuerySet. Arguments : related (Union[List, str]) : list of relation field names, can be linked by '__' to nest Returns : (QuerysetProxy) : QuerysetProxy paginate 1 | paginate ( page : int , page_size : int = 20 ) -> \"QuerysetProxy\" You can paginate the result which is a combination of offset and limit clauses. Limit is set to page size and offset is set to (page-1) * page_size. Actual call delegated to QuerySet. Arguments : page_size (int) : numbers of items per page page (int) : page number Returns : (QuerySet) : QuerySet limit 1 | limit ( limit_count : int ) -> \"QuerysetProxy\" You can limit the results to desired number of parent models. Actual call delegated to QuerySet. Arguments : limit_count (int) : number of models to limit Returns : (QuerysetProxy) : QuerysetProxy offset 1 | offset ( offset : int ) -> \"QuerysetProxy\" You can also offset the results by desired number of main models. Actual call delegated to QuerySet. Arguments : offset (int) : numbers of models to offset Returns : (QuerysetProxy) : QuerysetProxy fields 1 | fields ( columns : Union [ List , str , Set , Dict ]) -> \"QuerysetProxy\" With fields() you can select subset of model columns to limit the data load. Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). You can select specified fields by passing a str, List[str], Set[str] or dict with nested definition. To include related models use notation {related_name}__{column}[__{optional_next} etc.] . fields() can be called several times, building up the columns to select. If you include related models into select_related() call but you won't specify columns for those models in fields - implies a list of all fields for those nested models. Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Pk column cannot be excluded - it's always auto added even if not explicitly included. You can also pass fields to include as dictionary or set. To mark a field as included in a dictionary use it's name as key and ellipsis as value. To traverse nested models use nested dictionaries. To include fields at last level instead of nested dictionary a set can be used. To include whole nested model specify model related field name and ellipsis. Actual call delegated to QuerySet. Arguments : columns (Union[List, str, Set, Dict]) : columns to include Returns : (QuerysetProxy) : QuerysetProxy exclude_fields 1 | exclude_fields ( columns : Union [ List , str , Set , Dict ]) -> \"QuerysetProxy\" With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. It's the opposite of fields() method so check documentation above to see what options are available. Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy. Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Pk column cannot be excluded - it's always auto added even if explicitly excluded. Actual call delegated to QuerySet. Arguments : columns (Union[List, str, Set, Dict]) : columns to exclude Returns : (QuerysetProxy) : QuerysetProxy order_by 1 | order_by ( columns : Union [ List , str ]) -> \"QuerysetProxy\" With order_by() you can order the results from database based on your choice of fields. You can provide a string with field name or list of strings with fields names. Ordering in sql will be applied in order of names you provide in order_by. By default if you do not provide ordering ormar explicitly orders by all primary keys If you are sorting by nested models that causes that the result rows are unsorted by the main model ormar will combine those children rows into one main model. The main model will never duplicate in the result To order by main model field just provide a field name To sort on nested models separate field names with dunder '__'. You can sort this way across all relation types -> ForeignKey , reverse virtual FK and ManyToMany fields. To sort in descending order provide a hyphen in front of the field name Actual call delegated to QuerySet. Arguments : columns (Union[List, str]) : columns by which models should be sorted Returns : (QuerysetProxy) : QuerysetProxy","title":"Queryset Proxy"},{"location":"api/relations/queryset-proxy/#relationsquerysetproxy","text":"","title":"relations.querysetproxy"},{"location":"api/relations/queryset-proxy/#querysetproxy-objects","text":"1 class QuerysetProxy ( ormar . QuerySetProtocol ) Exposes QuerySet methods on relations, but also handles creating and removing of through Models for m2m relations.","title":"QuerysetProxy Objects"},{"location":"api/relations/queryset-proxy/#queryset","text":"1 2 | @property | queryset () -> \"QuerySet\" Returns queryset if it's set, AttributeError otherwise. Returns : (QuerySet) : QuerySet","title":"queryset"},{"location":"api/relations/queryset-proxy/#queryset_1","text":"1 2 | @queryset . setter | queryset ( value : \"QuerySet\" ) -> None Set's the queryset. Initialized in RelationProxy. Arguments : value (QuerySet) : QuerySet","title":"queryset"},{"location":"api/relations/queryset-proxy/#_assign_child_to_parent","text":"1 | _assign_child_to_parent ( child : Optional [ \"T\" ]) -> None Registers child in parents RelationManager. Arguments : child (Model) : child to register on parent side.","title":"_assign_child_to_parent"},{"location":"api/relations/queryset-proxy/#_register_related","text":"1 | _register_related ( child : Union [ \"T\" , Sequence [ Optional [ \"T\" ]]]) -> None Registers child/ children in parents RelationManager. Arguments : child (Union[Model,List[Model]]) : child or list of children models to register.","title":"_register_related"},{"location":"api/relations/queryset-proxy/#_clean_items_on_load","text":"1 | _clean_items_on_load () -> None Cleans the current list of the related models.","title":"_clean_items_on_load"},{"location":"api/relations/queryset-proxy/#create_through_instance","text":"1 | async create_through_instance ( child : \"T\" ) -> None Crete a through model instance in the database for m2m relations. Arguments : child (Model) : child model instance","title":"create_through_instance"},{"location":"api/relations/queryset-proxy/#delete_through_instance","text":"1 | async delete_through_instance ( child : \"T\" ) -> None Removes through model instance from the database for m2m relations. Arguments : child (Model) : child model instance","title":"delete_through_instance"},{"location":"api/relations/queryset-proxy/#exists","text":"1 | async exists () -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude if set). Actual call delegated to QuerySet. Returns : (bool) : result of the check","title":"exists"},{"location":"api/relations/queryset-proxy/#count","text":"1 | async count () -> int Returns number of rows matching the given criteria (applied with filter and exclude if set before). Actual call delegated to QuerySet. Returns : (int) : number of rows","title":"count"},{"location":"api/relations/queryset-proxy/#clear","text":"1 | async clear ( keep_reversed : bool = True ) -> int Removes all related models from given relation. Removes all through models for m2m relation. For reverse FK relations keep_reversed flag marks if the reversed models should be kept or deleted from the database too (False means that models will be deleted, and not only removed from relation). Arguments : keep_reversed (bool) : flag if reverse models in reverse FK should be deleted or not, keep_reversed=False deletes them from database. Returns : (int) : number of deleted models","title":"clear"},{"location":"api/relations/queryset-proxy/#first","text":"1 | async first ( ** kwargs : Any ) -> \"Model\" Gets the first row from the db ordered by primary key column ascending. Actual call delegated to QuerySet. List of related models is cleared before the call. Arguments : kwargs () : Returns : (_asyncio.Future) :","title":"first"},{"location":"api/relations/queryset-proxy/#get","text":"1 | async get ( ** kwargs : Any ) -> \"Model\" Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the last row in db sorted by pk. Passing a criteria is actually calling filter(**kwargs) method described below. Actual call delegated to QuerySet. List of related models is cleared before the call. Raises : NoMatch : if no rows are returned MultipleMatches : if more than 1 row is returned. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : returned model","title":"get"},{"location":"api/relations/queryset-proxy/#all","text":"1 | async all ( ** kwargs : Any ) -> Sequence [ Optional [ \"Model\" ]] Returns all rows from a database for given model for set filter options. Passing kwargs is a shortcut and equals to calling filter(**kwrags).all() . If there are no rows meeting the criteria an empty list is returned. Actual call delegated to QuerySet. List of related models is cleared before the call. Arguments : kwargs (Any) : fields names and proper value types Returns : (List[Model]) : list of returned models","title":"all"},{"location":"api/relations/queryset-proxy/#create","text":"1 | async create ( ** kwargs : Any ) -> \"Model\" Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set). The allowed kwargs are Model fields names and proper value types. For m2m relation the through model is created automatically. Actual call delegated to QuerySet. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : created model","title":"create"},{"location":"api/relations/queryset-proxy/#get_or_create","text":"1 | async get_or_create ( ** kwargs : Any ) -> \"Model\" Combination of create and get methods. Tries to get a row meeting the criteria fro kwargs and if NoMatch exception is raised it creates a new one with given kwargs. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : returned or created Model","title":"get_or_create"},{"location":"api/relations/queryset-proxy/#update_or_create","text":"1 | async update_or_create ( ** kwargs : Any ) -> \"Model\" Updates the model, or in case there is no match in database creates a new one. Actual call delegated to QuerySet. Arguments : kwargs (Any) : fields names and proper value types Returns : (Model) : updated or created model","title":"update_or_create"},{"location":"api/relations/queryset-proxy/#filter","text":"1 | filter ( ** kwargs : Any ) -> \"QuerysetProxy\" Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. You can use special filter suffix to change the filter operands: exact - like album__name__exact='Malibu' (exact match) iexact - like album__name__iexact='malibu' (exact match case insensitive) contains - like album__name__contains='Mal' (sql like) icontains - like album__name__icontains='mal' (sql like case insensitive) in - like album__name__in=['Malibu', 'Barclay'] (sql in) gt - like position__gt=3 (sql >) gte - like position__gte=3 (sql >=) lt - like position__lt=3 (sql <) lte - like position__lte=3 (sql <=) startswith - like album__name__startswith='Mal' (exact start match) istartswith - like album__name__istartswith='mal' (case insensitive) endswith - like album__name__endswith='ibu' (exact end match) iendswith - like album__name__iendswith='IBU' (case insensitive) Actual call delegated to QuerySet. Arguments : kwargs (Any) : fields names and proper value types Returns : (QuerysetProxy) : filtered QuerysetProxy","title":"filter"},{"location":"api/relations/queryset-proxy/#exclude","text":"1 | exclude ( ** kwargs : Any ) -> \"QuerysetProxy\" Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. So if you use filter(name='John') which is where name = 'John' in SQL, the exclude(name='John') equals to where name <> 'John' Note that all conditions are joined so if you pass multiple values it becomes a union of conditions. exclude(name='John', age>=35) will become where not (name='John' and age>=35) Actual call delegated to QuerySet. Arguments : kwargs (Any) : fields names and proper value types Returns : (QuerysetProxy) : filtered QuerysetProxy","title":"exclude"},{"location":"api/relations/queryset-proxy/#select_related","text":"1 | select_related ( related : Union [ List , str ]) -> \"QuerysetProxy\" Allows to prefetch related models during the same query. With select_related always only one query is run against the database , meaning that one (sometimes complicated) join is generated and later nested models are processed in python. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Actual call delegated to QuerySet. Arguments : related (Union[List, str]) : list of relation field names, can be linked by '__' to nest Returns : (QuerysetProxy) : QuerysetProxy","title":"select_related"},{"location":"api/relations/queryset-proxy/#prefetch_related","text":"1 | prefetch_related ( related : Union [ List , str ]) -> \"QuerysetProxy\" Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database , meaning that you will have multiple queries executed one after another. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Actual call delegated to QuerySet. Arguments : related (Union[List, str]) : list of relation field names, can be linked by '__' to nest Returns : (QuerysetProxy) : QuerysetProxy","title":"prefetch_related"},{"location":"api/relations/queryset-proxy/#paginate","text":"1 | paginate ( page : int , page_size : int = 20 ) -> \"QuerysetProxy\" You can paginate the result which is a combination of offset and limit clauses. Limit is set to page size and offset is set to (page-1) * page_size. Actual call delegated to QuerySet. Arguments : page_size (int) : numbers of items per page page (int) : page number Returns : (QuerySet) : QuerySet","title":"paginate"},{"location":"api/relations/queryset-proxy/#limit","text":"1 | limit ( limit_count : int ) -> \"QuerysetProxy\" You can limit the results to desired number of parent models. Actual call delegated to QuerySet. Arguments : limit_count (int) : number of models to limit Returns : (QuerysetProxy) : QuerysetProxy","title":"limit"},{"location":"api/relations/queryset-proxy/#offset","text":"1 | offset ( offset : int ) -> \"QuerysetProxy\" You can also offset the results by desired number of main models. Actual call delegated to QuerySet. Arguments : offset (int) : numbers of models to offset Returns : (QuerysetProxy) : QuerysetProxy","title":"offset"},{"location":"api/relations/queryset-proxy/#fields","text":"1 | fields ( columns : Union [ List , str , Set , Dict ]) -> \"QuerysetProxy\" With fields() you can select subset of model columns to limit the data load. Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). You can select specified fields by passing a str, List[str], Set[str] or dict with nested definition. To include related models use notation {related_name}__{column}[__{optional_next} etc.] . fields() can be called several times, building up the columns to select. If you include related models into select_related() call but you won't specify columns for those models in fields - implies a list of all fields for those nested models. Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Pk column cannot be excluded - it's always auto added even if not explicitly included. You can also pass fields to include as dictionary or set. To mark a field as included in a dictionary use it's name as key and ellipsis as value. To traverse nested models use nested dictionaries. To include fields at last level instead of nested dictionary a set can be used. To include whole nested model specify model related field name and ellipsis. Actual call delegated to QuerySet. Arguments : columns (Union[List, str, Set, Dict]) : columns to include Returns : (QuerysetProxy) : QuerysetProxy","title":"fields"},{"location":"api/relations/queryset-proxy/#exclude_fields","text":"1 | exclude_fields ( columns : Union [ List , str , Set , Dict ]) -> \"QuerysetProxy\" With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. It's the opposite of fields() method so check documentation above to see what options are available. Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy. Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Pk column cannot be excluded - it's always auto added even if explicitly excluded. Actual call delegated to QuerySet. Arguments : columns (Union[List, str, Set, Dict]) : columns to exclude Returns : (QuerysetProxy) : QuerysetProxy","title":"exclude_fields"},{"location":"api/relations/queryset-proxy/#order_by","text":"1 | order_by ( columns : Union [ List , str ]) -> \"QuerysetProxy\" With order_by() you can order the results from database based on your choice of fields. You can provide a string with field name or list of strings with fields names. Ordering in sql will be applied in order of names you provide in order_by. By default if you do not provide ordering ormar explicitly orders by all primary keys If you are sorting by nested models that causes that the result rows are unsorted by the main model ormar will combine those children rows into one main model. The main model will never duplicate in the result To order by main model field just provide a field name To sort on nested models separate field names with dunder '__'. You can sort this way across all relation types -> ForeignKey , reverse virtual FK and ManyToMany fields. To sort in descending order provide a hyphen in front of the field name Actual call delegated to QuerySet. Arguments : columns (Union[List, str]) : columns by which models should be sorted Returns : (QuerysetProxy) : QuerysetProxy","title":"order_by"},{"location":"api/relations/relation-manager/","text":"relations.relation_manager RelationsManager Objects 1 class RelationsManager () Manages relations on a Model, each Model has it's own instance. _get_relation_type 1 | _get_relation_type ( field : Type [ BaseField ]) -> RelationType Returns type of the relation declared on a field. Arguments : field (Type[BaseField]) : field with relation declaration Returns : (RelationType) : type of the relation defined on field _add_relation 1 | _add_relation ( field : Type [ BaseField ]) -> None Registers relation in the manager. Adds Relation instance under field.name. Arguments : field (Type[BaseField]) : field with relation declaration __contains__ 1 | __contains__ ( item : str ) -> bool Checks if relation with given name is already registered. Arguments : item (str) : name of attribute Returns : (bool) : result of the check get 1 | get ( name : str ) -> Optional [ Union [ \"T\" , Sequence [ \"T\" ]]] Returns the related model/models if relation is set. Actual call is delegated to Relation instance registered under relation name. Arguments : name (str) : name of the relation Returns : (Optional[Union[Model, List[Model]]) : related model or list of related models if set _get 1 | _get ( name : str ) -> Optional [ Relation ] Returns the actual relation and not the related model(s). Arguments : name (str) : name of the relation Returns : (ormar.relations.relation.Relation) : Relation instance add 1 2 | @staticmethod | add ( parent : \"Model\" , child : \"Model\" , field : Type [ \"ForeignKeyField\" ]) -> None Adds relation on both sides -> meaning on both child and parent models. One side of the relation is always weakref proxy to avoid circular refs. Based on the side from which relation is added and relation name actual names of parent and child relations are established. The related models are registered on both ends. Arguments : parent (Model) : parent model on which relation should be registered child (Model) : child model to register field (ForeignKeyField) : field with relation definition remove 1 | remove ( name : str , child : Union [ \"NewBaseModel\" , Type [ \"NewBaseModel\" ]]) -> None Removes given child from relation with given name. Since you can have many relations between two models you need to pass a name of relation from which you want to remove the child. Arguments : name (str) : name of the relation child (Union[Model, Type[Model]]) : child to remove from relation remove_parent 1 2 | @staticmethod | remove_parent ( item : Union [ \"NewBaseModel\" , Type [ \"NewBaseModel\" ]], parent : \"Model\" , name : str ) -> None Removes given parent from relation with given name. Since you can have many relations between two models you need to pass a name of relation from which you want to remove the parent. Arguments : item (Union[Model, Type[Model]]) : model with parent registered parent (Model) : parent Model name (str) : name of the relation","title":"Relation Manager"},{"location":"api/relations/relation-manager/#relationsrelation_manager","text":"","title":"relations.relation_manager"},{"location":"api/relations/relation-manager/#relationsmanager-objects","text":"1 class RelationsManager () Manages relations on a Model, each Model has it's own instance.","title":"RelationsManager Objects"},{"location":"api/relations/relation-manager/#_get_relation_type","text":"1 | _get_relation_type ( field : Type [ BaseField ]) -> RelationType Returns type of the relation declared on a field. Arguments : field (Type[BaseField]) : field with relation declaration Returns : (RelationType) : type of the relation defined on field","title":"_get_relation_type"},{"location":"api/relations/relation-manager/#_add_relation","text":"1 | _add_relation ( field : Type [ BaseField ]) -> None Registers relation in the manager. Adds Relation instance under field.name. Arguments : field (Type[BaseField]) : field with relation declaration","title":"_add_relation"},{"location":"api/relations/relation-manager/#__contains__","text":"1 | __contains__ ( item : str ) -> bool Checks if relation with given name is already registered. Arguments : item (str) : name of attribute Returns : (bool) : result of the check","title":"__contains__"},{"location":"api/relations/relation-manager/#get","text":"1 | get ( name : str ) -> Optional [ Union [ \"T\" , Sequence [ \"T\" ]]] Returns the related model/models if relation is set. Actual call is delegated to Relation instance registered under relation name. Arguments : name (str) : name of the relation Returns : (Optional[Union[Model, List[Model]]) : related model or list of related models if set","title":"get"},{"location":"api/relations/relation-manager/#_get","text":"1 | _get ( name : str ) -> Optional [ Relation ] Returns the actual relation and not the related model(s). Arguments : name (str) : name of the relation Returns : (ormar.relations.relation.Relation) : Relation instance","title":"_get"},{"location":"api/relations/relation-manager/#add","text":"1 2 | @staticmethod | add ( parent : \"Model\" , child : \"Model\" , field : Type [ \"ForeignKeyField\" ]) -> None Adds relation on both sides -> meaning on both child and parent models. One side of the relation is always weakref proxy to avoid circular refs. Based on the side from which relation is added and relation name actual names of parent and child relations are established. The related models are registered on both ends. Arguments : parent (Model) : parent model on which relation should be registered child (Model) : child model to register field (ForeignKeyField) : field with relation definition","title":"add"},{"location":"api/relations/relation-manager/#remove","text":"1 | remove ( name : str , child : Union [ \"NewBaseModel\" , Type [ \"NewBaseModel\" ]]) -> None Removes given child from relation with given name. Since you can have many relations between two models you need to pass a name of relation from which you want to remove the child. Arguments : name (str) : name of the relation child (Union[Model, Type[Model]]) : child to remove from relation","title":"remove"},{"location":"api/relations/relation-manager/#remove_parent","text":"1 2 | @staticmethod | remove_parent ( item : Union [ \"NewBaseModel\" , Type [ \"NewBaseModel\" ]], parent : \"Model\" , name : str ) -> None Removes given parent from relation with given name. Since you can have many relations between two models you need to pass a name of relation from which you want to remove the parent. Arguments : item (Union[Model, Type[Model]]) : model with parent registered parent (Model) : parent Model name (str) : name of the relation","title":"remove_parent"},{"location":"api/relations/relation-proxy/","text":"relations.relation_proxy RelationProxy Objects 1 class RelationProxy ( list ) Proxy of the Relation that is a list with special methods. related_field_name 1 2 | @property | related_field_name () -> str On first access calculates the name of the related field, later stored in _related_field_name property. Returns : (str) : name of the related field __getattribute__ 1 | __getattribute__ ( item : str ) -> Any Since some QuerySetProxy methods overwrite builtin list methods we catch calls to them and delegate it to QuerySetProxy instead. Arguments : item (str) : name of attribute Returns : (Any) : value of attribute __getattr__ 1 | __getattr__ ( item : str ) -> Any Delegates calls for non existing attributes to QuerySetProxy. Arguments : item (str) : name of attribute/method Returns : (method) : method from QuerySetProxy if exists _initialize_queryset 1 | _initialize_queryset () -> None Initializes the QuerySetProxy if not yet initialized. _check_if_queryset_is_initialized 1 | _check_if_queryset_is_initialized () -> bool Checks if the QuerySetProxy is already set and ready. Returns : (bool) : result of the check _check_if_model_saved 1 | _check_if_model_saved () -> None Verifies if the parent model of the relation has been already saved. Otherwise QuerySetProxy cannot filter by parent primary key. _set_queryset 1 | _set_queryset () -> \"QuerySet\" Creates new QuerySet with relation model and pre filters it with currents parent model primary key, so all queries by definition are already related to the parent model only, without need for user to filter them. Returns : (QuerySet) : initialized QuerySet remove 1 | async remove ( item : \"Model\" , keep_reversed : bool = True ) -> None Removes the related from relation with parent. Through models are automatically deleted for m2m relations. For reverse FK relations keep_reversed flag marks if the reversed models should be kept or deleted from the database too (False means that models will be deleted, and not only removed from relation). Arguments : item (Model) : child to remove from relation keep_reversed (bool) : flag if the reversed model should be kept or deleted too add 1 | async add ( item : \"Model\" ) -> None Adds child model to relation. For ManyToMany relations through instance is automatically created. Arguments : item (Model) : child to add to relation","title":"Relation Proxy"},{"location":"api/relations/relation-proxy/#relationsrelation_proxy","text":"","title":"relations.relation_proxy"},{"location":"api/relations/relation-proxy/#relationproxy-objects","text":"1 class RelationProxy ( list ) Proxy of the Relation that is a list with special methods.","title":"RelationProxy Objects"},{"location":"api/relations/relation-proxy/#related_field_name","text":"1 2 | @property | related_field_name () -> str On first access calculates the name of the related field, later stored in _related_field_name property. Returns : (str) : name of the related field","title":"related_field_name"},{"location":"api/relations/relation-proxy/#__getattribute__","text":"1 | __getattribute__ ( item : str ) -> Any Since some QuerySetProxy methods overwrite builtin list methods we catch calls to them and delegate it to QuerySetProxy instead. Arguments : item (str) : name of attribute Returns : (Any) : value of attribute","title":"__getattribute__"},{"location":"api/relations/relation-proxy/#__getattr__","text":"1 | __getattr__ ( item : str ) -> Any Delegates calls for non existing attributes to QuerySetProxy. Arguments : item (str) : name of attribute/method Returns : (method) : method from QuerySetProxy if exists","title":"__getattr__"},{"location":"api/relations/relation-proxy/#_initialize_queryset","text":"1 | _initialize_queryset () -> None Initializes the QuerySetProxy if not yet initialized.","title":"_initialize_queryset"},{"location":"api/relations/relation-proxy/#_check_if_queryset_is_initialized","text":"1 | _check_if_queryset_is_initialized () -> bool Checks if the QuerySetProxy is already set and ready. Returns : (bool) : result of the check","title":"_check_if_queryset_is_initialized"},{"location":"api/relations/relation-proxy/#_check_if_model_saved","text":"1 | _check_if_model_saved () -> None Verifies if the parent model of the relation has been already saved. Otherwise QuerySetProxy cannot filter by parent primary key.","title":"_check_if_model_saved"},{"location":"api/relations/relation-proxy/#_set_queryset","text":"1 | _set_queryset () -> \"QuerySet\" Creates new QuerySet with relation model and pre filters it with currents parent model primary key, so all queries by definition are already related to the parent model only, without need for user to filter them. Returns : (QuerySet) : initialized QuerySet","title":"_set_queryset"},{"location":"api/relations/relation-proxy/#remove","text":"1 | async remove ( item : \"Model\" , keep_reversed : bool = True ) -> None Removes the related from relation with parent. Through models are automatically deleted for m2m relations. For reverse FK relations keep_reversed flag marks if the reversed models should be kept or deleted from the database too (False means that models will be deleted, and not only removed from relation). Arguments : item (Model) : child to remove from relation keep_reversed (bool) : flag if the reversed model should be kept or deleted too","title":"remove"},{"location":"api/relations/relation-proxy/#add","text":"1 | async add ( item : \"Model\" ) -> None Adds child model to relation. For ManyToMany relations through instance is automatically created. Arguments : item (Model) : child to add to relation","title":"add"},{"location":"api/relations/relation/","text":"relations.relation RelationType Objects 1 class RelationType ( Enum ) Different types of relations supported by ormar: ForeignKey = PRIMARY reverse ForeignKey = REVERSE ManyToMany = MULTIPLE Relation Objects 1 class Relation () Keeps related Models and handles adding/removing of the children. __init__ 1 | __init__ ( manager : \"RelationsManager\" , type_ : RelationType , field_name : str , to : Type [ \"T\" ], through : Type [ \"T\" ] = None ) -> None Initialize the Relation and keep the related models either as instances of passed Model, or as a RelationProxy which is basically a list of models with some special behavior, as it exposes QuerySetProxy and allows querying the related models already pre filtered by parent model. Arguments : manager (RelationsManager) : reference to relation manager type_ (RelationType) : type of the relation field_name (str) : name of the relation field to (Type[Model]) : model to which relation leads to through (Type[Model]) : model through which relation goes for m2m relations _clean_related 1 | _clean_related () -> None Removes dead weakrefs from RelationProxy. _find_existing 1 | _find_existing ( child : Union [ \"NewBaseModel\" , Type [ \"NewBaseModel\" ]]) -> Optional [ int ] Find child model in RelationProxy if exists. Arguments : child (Model) : child model to find Returns : (Optional[ind]) : index of child in RelationProxy add 1 | add ( child : \"T\" ) -> None Adds child Model to relation, either sets child as related model or adds it to the list in RelationProxy depending on relation type. Arguments : child (Model) : model to add to relation remove 1 | remove ( child : Union [ \"NewBaseModel\" , Type [ \"NewBaseModel\" ]]) -> None Removes child Model from relation, either sets None as related model or removes it from the list in RelationProxy depending on relation type. Arguments : child (Model) : model to remove from relation get 1 | get () -> Optional [ Union [ List [ \"T\" ], \"T\" ]] Return the related model or models from RelationProxy. Returns : (Optional[Union[List[Model], Model]]) : related model/models if set","title":"Relation"},{"location":"api/relations/relation/#relationsrelation","text":"","title":"relations.relation"},{"location":"api/relations/relation/#relationtype-objects","text":"1 class RelationType ( Enum ) Different types of relations supported by ormar: ForeignKey = PRIMARY reverse ForeignKey = REVERSE ManyToMany = MULTIPLE","title":"RelationType Objects"},{"location":"api/relations/relation/#relation-objects","text":"1 class Relation () Keeps related Models and handles adding/removing of the children.","title":"Relation Objects"},{"location":"api/relations/relation/#__init__","text":"1 | __init__ ( manager : \"RelationsManager\" , type_ : RelationType , field_name : str , to : Type [ \"T\" ], through : Type [ \"T\" ] = None ) -> None Initialize the Relation and keep the related models either as instances of passed Model, or as a RelationProxy which is basically a list of models with some special behavior, as it exposes QuerySetProxy and allows querying the related models already pre filtered by parent model. Arguments : manager (RelationsManager) : reference to relation manager type_ (RelationType) : type of the relation field_name (str) : name of the relation field to (Type[Model]) : model to which relation leads to through (Type[Model]) : model through which relation goes for m2m relations","title":"__init__"},{"location":"api/relations/relation/#_clean_related","text":"1 | _clean_related () -> None Removes dead weakrefs from RelationProxy.","title":"_clean_related"},{"location":"api/relations/relation/#_find_existing","text":"1 | _find_existing ( child : Union [ \"NewBaseModel\" , Type [ \"NewBaseModel\" ]]) -> Optional [ int ] Find child model in RelationProxy if exists. Arguments : child (Model) : child model to find Returns : (Optional[ind]) : index of child in RelationProxy","title":"_find_existing"},{"location":"api/relations/relation/#add","text":"1 | add ( child : \"T\" ) -> None Adds child Model to relation, either sets child as related model or adds it to the list in RelationProxy depending on relation type. Arguments : child (Model) : model to add to relation","title":"add"},{"location":"api/relations/relation/#remove","text":"1 | remove ( child : Union [ \"NewBaseModel\" , Type [ \"NewBaseModel\" ]]) -> None Removes child Model from relation, either sets None as related model or removes it from the list in RelationProxy depending on relation type. Arguments : child (Model) : model to remove from relation","title":"remove"},{"location":"api/relations/relation/#get","text":"1 | get () -> Optional [ Union [ List [ \"T\" ], \"T\" ]] Return the related model or models from RelationProxy. Returns : (Optional[Union[List[Model], Model]]) : related model/models if set","title":"get"},{"location":"api/relations/utils/","text":"relations.utils get_relations_sides_and_names 1 get_relations_sides_and_names ( to_field : Type [ ForeignKeyField ], parent : \"Model\" , child : \"Model\" ) -> Tuple [ \"Model\" , \"Model\" , str , str ] Determines the names of child and parent relations names, as well as changes one of the sides of the relation into weakref.proxy to model. Arguments : to_field (ForeignKeyField) : field with relation definition parent (Model) : parent model child (Model) : child model Returns : (Tuple[\"Model\", \"Model\", str, str]) : parent, child, child_name, to_name","title":"Utils"},{"location":"api/relations/utils/#relationsutils","text":"","title":"relations.utils"},{"location":"api/relations/utils/#get_relations_sides_and_names","text":"1 get_relations_sides_and_names ( to_field : Type [ ForeignKeyField ], parent : \"Model\" , child : \"Model\" ) -> Tuple [ \"Model\" , \"Model\" , str , str ] Determines the names of child and parent relations names, as well as changes one of the sides of the relation into weakref.proxy to model. Arguments : to_field (ForeignKeyField) : field with relation definition parent (Model) : parent model child (Model) : child model Returns : (Tuple[\"Model\", \"Model\", str, str]) : parent, child, child_name, to_name","title":"get_relations_sides_and_names"},{"location":"api/signals/decorators/","text":"decorators.signals receiver 1 receiver ( signal : str , senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for given signal name. Arguments : signal (str) : name of the signal to register to senders (Union[Type[\"Model\"], List[Type[\"Model\"]]]) : one or a list of \"Model\" classes that should have the signal receiver registered Returns : (Callable) : returns the original function untouched post_save 1 post_save ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for post_save signal. Arguments : senders (Union[Type[\"Model\"], List[Type[\"Model\"]]]) : one or a list of \"Model\" classes that should have the signal receiver registered Returns : (Callable) : returns the original function untouched post_update 1 post_update ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for post_update signal. Arguments : senders (Union[Type[\"Model\"], List[Type[\"Model\"]]]) : one or a list of \"Model\" classes that should have the signal receiver registered Returns : (Callable) : returns the original function untouched post_delete 1 post_delete ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for post_delete signal. Arguments : senders (Union[Type[\"Model\"], List[Type[\"Model\"]]]) : one or a list of \"Model\" classes that should have the signal receiver registered Returns : (Callable) : returns the original function untouched pre_save 1 pre_save ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for pre_save signal. Arguments : senders (Union[Type[\"Model\"], List[Type[\"Model\"]]]) : one or a list of \"Model\" classes that should have the signal receiver registered Returns : (Callable) : returns the original function untouched pre_update 1 pre_update ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for pre_update signal. Arguments : senders (Union[Type[\"Model\"], List[Type[\"Model\"]]]) : one or a list of \"Model\" classes that should have the signal receiver registered Returns : (Callable) : returns the original function untouched pre_delete 1 pre_delete ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for pre_delete signal. Arguments : senders (Union[Type[\"Model\"], List[Type[\"Model\"]]]) : one or a list of \"Model\" classes that should have the signal receiver registered Returns : (Callable) : returns the original function untouched","title":"Decorators"},{"location":"api/signals/decorators/#decoratorssignals","text":"","title":"decorators.signals"},{"location":"api/signals/decorators/#receiver","text":"1 receiver ( signal : str , senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for given signal name. Arguments : signal (str) : name of the signal to register to senders (Union[Type[\"Model\"], List[Type[\"Model\"]]]) : one or a list of \"Model\" classes that should have the signal receiver registered Returns : (Callable) : returns the original function untouched","title":"receiver"},{"location":"api/signals/decorators/#post_save","text":"1 post_save ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for post_save signal. Arguments : senders (Union[Type[\"Model\"], List[Type[\"Model\"]]]) : one or a list of \"Model\" classes that should have the signal receiver registered Returns : (Callable) : returns the original function untouched","title":"post_save"},{"location":"api/signals/decorators/#post_update","text":"1 post_update ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for post_update signal. Arguments : senders (Union[Type[\"Model\"], List[Type[\"Model\"]]]) : one or a list of \"Model\" classes that should have the signal receiver registered Returns : (Callable) : returns the original function untouched","title":"post_update"},{"location":"api/signals/decorators/#post_delete","text":"1 post_delete ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for post_delete signal. Arguments : senders (Union[Type[\"Model\"], List[Type[\"Model\"]]]) : one or a list of \"Model\" classes that should have the signal receiver registered Returns : (Callable) : returns the original function untouched","title":"post_delete"},{"location":"api/signals/decorators/#pre_save","text":"1 pre_save ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for pre_save signal. Arguments : senders (Union[Type[\"Model\"], List[Type[\"Model\"]]]) : one or a list of \"Model\" classes that should have the signal receiver registered Returns : (Callable) : returns the original function untouched","title":"pre_save"},{"location":"api/signals/decorators/#pre_update","text":"1 pre_update ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for pre_update signal. Arguments : senders (Union[Type[\"Model\"], List[Type[\"Model\"]]]) : one or a list of \"Model\" classes that should have the signal receiver registered Returns : (Callable) : returns the original function untouched","title":"pre_update"},{"location":"api/signals/decorators/#pre_delete","text":"1 pre_delete ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for pre_delete signal. Arguments : senders (Union[Type[\"Model\"], List[Type[\"Model\"]]]) : one or a list of \"Model\" classes that should have the signal receiver registered Returns : (Callable) : returns the original function untouched","title":"pre_delete"},{"location":"api/signals/signal/","text":"signals.signal callable_accepts_kwargs 1 callable_accepts_kwargs ( func : Callable ) -> bool Checks if function accepts **kwargs. Arguments : func (function) : function which signature needs to be checked Returns : (bool) : result of the check make_id 1 make_id ( target : Any ) -> Union [ int , Tuple [ int , int ]] Creates id of a function or method to be used as key to store signal Arguments : target (Any) : target which id we want Returns : (int) : id of the target Signal Objects 1 class Signal () Signal that notifies all receiver functions. In ormar used by models to send pre_save, post_save etc. signals. connect 1 | connect ( receiver : Callable ) -> None Connects given receiver function to the signal. Raises : SignalDefinitionError : if receiver is not callable or not accept **kwargs Arguments : receiver (Callable) : receiver function disconnect 1 | disconnect ( receiver : Callable ) -> bool Removes the receiver function from the signal. Arguments : receiver (Callable) : receiver function Returns : (bool) : flag if receiver was removed send 1 | async send ( sender : Type [ \"Model\" ], ** kwargs : Any ) -> None Notifies all receiver functions with given kwargs Arguments : sender (Type[\"Model\"]) : model that sends the signal kwargs (Any) : arguments passed to receivers SignalEmitter Objects 1 class SignalEmitter () Emitter that registers the signals in internal dictionary. If signal with given name does not exist it's auto added on access.","title":"Signal"},{"location":"api/signals/signal/#signalssignal","text":"","title":"signals.signal"},{"location":"api/signals/signal/#callable_accepts_kwargs","text":"1 callable_accepts_kwargs ( func : Callable ) -> bool Checks if function accepts **kwargs. Arguments : func (function) : function which signature needs to be checked Returns : (bool) : result of the check","title":"callable_accepts_kwargs"},{"location":"api/signals/signal/#make_id","text":"1 make_id ( target : Any ) -> Union [ int , Tuple [ int , int ]] Creates id of a function or method to be used as key to store signal Arguments : target (Any) : target which id we want Returns : (int) : id of the target","title":"make_id"},{"location":"api/signals/signal/#signal-objects","text":"1 class Signal () Signal that notifies all receiver functions. In ormar used by models to send pre_save, post_save etc. signals.","title":"Signal Objects"},{"location":"api/signals/signal/#connect","text":"1 | connect ( receiver : Callable ) -> None Connects given receiver function to the signal. Raises : SignalDefinitionError : if receiver is not callable or not accept **kwargs Arguments : receiver (Callable) : receiver function","title":"connect"},{"location":"api/signals/signal/#disconnect","text":"1 | disconnect ( receiver : Callable ) -> bool Removes the receiver function from the signal. Arguments : receiver (Callable) : receiver function Returns : (bool) : flag if receiver was removed","title":"disconnect"},{"location":"api/signals/signal/#send","text":"1 | async send ( sender : Type [ \"Model\" ], ** kwargs : Any ) -> None Notifies all receiver functions with given kwargs Arguments : sender (Type[\"Model\"]) : model that sends the signal kwargs (Any) : arguments passed to receivers","title":"send"},{"location":"api/signals/signal/#signalemitter-objects","text":"1 class SignalEmitter () Emitter that registers the signals in internal dictionary. If signal with given name does not exist it's auto added on access.","title":"SignalEmitter Objects"},{"location":"fields/common-parameters/","text":"Common Parameters All Field types have a set of common parameters. primary_key primary_key : bool = False -> by default False. Sets the primary key column on a table, foreign keys always refer to the pk of the Model . Used in sql only. autoincrement autoincrement : bool = primary_key and type == int -> defaults to True if column is a primary key and of type Integer, otherwise False. Can be only used with int/bigint fields. If a field has autoincrement it becomes optional. Used both in sql and pydantic (changes pk field to optional for autoincrement). nullable nullable : bool = not primary_key -> defaults to False for primary key column, and True for all other. Specifies if field is optional or required, used both with sql and pydantic. Note By default all ForeignKeys are also nullable, meaning the related Model is not required. If you change the ForeignKey column to nullable=False , it becomes required. Info If you want to know more about how you can preload related models during queries and how the relations work read the queries and relations sections. default default : Any = None -> defaults to None. A default value used if no other value is passed. In sql invoked on an insert, used during pydantic model definition. If the field has a default value it becomes optional. You can pass a static value or a Callable (function etc.) Used both in sql and pydantic. server default server_default : Any = None -> defaults to None. A default value used if no other value is passed. In sql invoked on the server side so you can pass i.e. sql function (like now() or query/value wrapped in sqlalchemy text() clause). If the field has a server_default value it becomes optional. You can pass a static value or a Callable (function etc.) Used in sql only. Sample usage: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from datetime import datetime import databases import sqlalchemy from sqlalchemy import func , text import ormar database = databases . Database ( \"sqlite:///test.db\" ) metadata = sqlalchemy . MetaData () class Product ( ormar . Model ): class Meta : tablename = \"product\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) company : str = ormar . String ( max_length = 200 , server_default = \"Acme\" ) sort_order : int = ormar . Integer ( server_default = text ( \"10\" )) created : datetime = ormar . DateTime ( server_default = func . now ()) Warning server_default accepts str , sqlalchemy.sql.elements.ClauseElement or sqlalchemy.sql.elements.TextClause so if you want to set i.e. Integer value you need to wrap it in sqlalchemy.text() function like above Tip You can pass also valid sql (dialect specific) wrapped in sqlalchemy.text() For example func.now() above could be exchanged for text('(CURRENT_TIMESTAMP)') for sqlite backend Info server_default is passed straight to sqlalchemy table definition so you can read more in server default sqlalchemy documentation index index : bool = False -> by default False, Sets the index on a table's column. Used in sql only. unique unique : bool = False Sets the unique constraint on a table's column. Used in sql only. pydantic_only pydantic_only : bool = False Prevents creation of a sql column for given field. Used for data related to given model but not to be stored in the database. Used in pydantic only. choices choices : Sequence = [] A set of choices allowed to be used for given field. Used for data validation on pydantic side. Prevents insertion of value not present in the choices list. Used in pydantic only.","title":"Common parameters"},{"location":"fields/common-parameters/#common-parameters","text":"All Field types have a set of common parameters.","title":"Common Parameters"},{"location":"fields/common-parameters/#primary_key","text":"primary_key : bool = False -> by default False. Sets the primary key column on a table, foreign keys always refer to the pk of the Model . Used in sql only.","title":"primary_key"},{"location":"fields/common-parameters/#autoincrement","text":"autoincrement : bool = primary_key and type == int -> defaults to True if column is a primary key and of type Integer, otherwise False. Can be only used with int/bigint fields. If a field has autoincrement it becomes optional. Used both in sql and pydantic (changes pk field to optional for autoincrement).","title":"autoincrement"},{"location":"fields/common-parameters/#nullable","text":"nullable : bool = not primary_key -> defaults to False for primary key column, and True for all other. Specifies if field is optional or required, used both with sql and pydantic. Note By default all ForeignKeys are also nullable, meaning the related Model is not required. If you change the ForeignKey column to nullable=False , it becomes required. Info If you want to know more about how you can preload related models during queries and how the relations work read the queries and relations sections.","title":"nullable"},{"location":"fields/common-parameters/#default","text":"default : Any = None -> defaults to None. A default value used if no other value is passed. In sql invoked on an insert, used during pydantic model definition. If the field has a default value it becomes optional. You can pass a static value or a Callable (function etc.) Used both in sql and pydantic.","title":"default"},{"location":"fields/common-parameters/#server-default","text":"server_default : Any = None -> defaults to None. A default value used if no other value is passed. In sql invoked on the server side so you can pass i.e. sql function (like now() or query/value wrapped in sqlalchemy text() clause). If the field has a server_default value it becomes optional. You can pass a static value or a Callable (function etc.) Used in sql only. Sample usage: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from datetime import datetime import databases import sqlalchemy from sqlalchemy import func , text import ormar database = databases . Database ( \"sqlite:///test.db\" ) metadata = sqlalchemy . MetaData () class Product ( ormar . Model ): class Meta : tablename = \"product\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) company : str = ormar . String ( max_length = 200 , server_default = \"Acme\" ) sort_order : int = ormar . Integer ( server_default = text ( \"10\" )) created : datetime = ormar . DateTime ( server_default = func . now ()) Warning server_default accepts str , sqlalchemy.sql.elements.ClauseElement or sqlalchemy.sql.elements.TextClause so if you want to set i.e. Integer value you need to wrap it in sqlalchemy.text() function like above Tip You can pass also valid sql (dialect specific) wrapped in sqlalchemy.text() For example func.now() above could be exchanged for text('(CURRENT_TIMESTAMP)') for sqlite backend Info server_default is passed straight to sqlalchemy table definition so you can read more in server default sqlalchemy documentation","title":"server default"},{"location":"fields/common-parameters/#index","text":"index : bool = False -> by default False, Sets the index on a table's column. Used in sql only.","title":"index"},{"location":"fields/common-parameters/#unique","text":"unique : bool = False Sets the unique constraint on a table's column. Used in sql only.","title":"unique"},{"location":"fields/common-parameters/#pydantic_only","text":"pydantic_only : bool = False Prevents creation of a sql column for given field. Used for data related to given model but not to be stored in the database. Used in pydantic only.","title":"pydantic_only"},{"location":"fields/common-parameters/#choices","text":"choices : Sequence = [] A set of choices allowed to be used for given field. Used for data validation on pydantic side. Prevents insertion of value not present in the choices list. Used in pydantic only.","title":"choices"},{"location":"fields/field-types/","text":"Fields There are 12 basic model field types and a special ForeignKey and Many2Many fields to establish relationships between models. Tip For explanation of ForeignKey and Many2Many fields check relations . Each of the Fields has assigned both sqlalchemy column class and python type that is used to create pydantic model. Fields Types String String(max_length, allow_blank: bool = True, strip_whitespace: bool = False, min_length: int = None, max_length: int = None, curtail_length: int = None, regex: str = None,) has a required max_length parameter. Sqlalchemy column: sqlalchemy.String Type (used for pydantic): str Tip For explanation of other parameters check pydantic documentation. Text Text(allow_blank: bool = True, strip_whitespace: bool = False) has no required parameters. Sqlalchemy column: sqlalchemy.Text Type (used for pydantic): str Tip For explanation of other parameters check pydantic documentation. Boolean Boolean() has no required parameters. Sqlalchemy column: sqlalchemy.Boolean Type (used for pydantic): bool Integer Integer(minimum: int = None, maximum: int = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.Integer Type (used for pydantic): int Tip For explanation of other parameters check pydantic documentation. BigInteger BigInteger(minimum: int = None, maximum: int = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.BigInteger Type (used for pydantic): int Tip For explanation of other parameters check pydantic documentation. Float Float(minimum: float = None, maximum: float = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.Float Type (used for pydantic): float Tip For explanation of other parameters check pydantic documentation. Decimal Decimal(minimum: float = None, maximum: float = None, multiple_of: int = None, precision: int = None, scale: int = None, max_digits: int = None, decimal_places: int = None) has no required parameters You can use either length and precision parameters or max_digits and decimal_places . Sqlalchemy column: sqlalchemy.DECIMAL Type (used for pydantic): decimal.Decimal Tip For explanation of other parameters check pydantic documentation. Date Date() has no required parameters. Sqlalchemy column: sqlalchemy.Date Type (used for pydantic): datetime.date Time Time() has no required parameters. Sqlalchemy column: sqlalchemy.Time Type (used for pydantic): datetime.time DateTime DateTime() has no required parameters. Sqlalchemy column: sqlalchemy.DateTime Type (used for pydantic): datetime.datetime JSON JSON() has no required parameters. Sqlalchemy column: sqlalchemy.JSON Type (used for pydantic): pydantic.Json UUID UUID(uuid_format: str = 'hex') has no required parameters. Sqlalchemy column: ormar.UUID based on sqlalchemy.CHAR(36) or sqlalchemy.CHAR(32) field (for string or hex format respectively) Type (used for pydantic): uuid.UUID uuid_format parameters allow 'hex'(default) or 'string' values. Depending on the format either 32 or 36 char is used in the database. Sample: 'hex' format value = c616ab438cce49dbbf4380d109251dce (CHAR(32)) 'string' value = c616ab43-8cce-49db-bf43-80d109251dce (CHAR(36)) When loaded it's always python UUID so you can compare it and compare two formats values between each other.","title":"Fields types"},{"location":"fields/field-types/#fields","text":"There are 12 basic model field types and a special ForeignKey and Many2Many fields to establish relationships between models. Tip For explanation of ForeignKey and Many2Many fields check relations . Each of the Fields has assigned both sqlalchemy column class and python type that is used to create pydantic model.","title":"Fields"},{"location":"fields/field-types/#fields-types","text":"","title":"Fields Types"},{"location":"fields/field-types/#string","text":"String(max_length, allow_blank: bool = True, strip_whitespace: bool = False, min_length: int = None, max_length: int = None, curtail_length: int = None, regex: str = None,) has a required max_length parameter. Sqlalchemy column: sqlalchemy.String Type (used for pydantic): str Tip For explanation of other parameters check pydantic documentation.","title":"String"},{"location":"fields/field-types/#text","text":"Text(allow_blank: bool = True, strip_whitespace: bool = False) has no required parameters. Sqlalchemy column: sqlalchemy.Text Type (used for pydantic): str Tip For explanation of other parameters check pydantic documentation.","title":"Text"},{"location":"fields/field-types/#boolean","text":"Boolean() has no required parameters. Sqlalchemy column: sqlalchemy.Boolean Type (used for pydantic): bool","title":"Boolean"},{"location":"fields/field-types/#integer","text":"Integer(minimum: int = None, maximum: int = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.Integer Type (used for pydantic): int Tip For explanation of other parameters check pydantic documentation.","title":"Integer"},{"location":"fields/field-types/#biginteger","text":"BigInteger(minimum: int = None, maximum: int = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.BigInteger Type (used for pydantic): int Tip For explanation of other parameters check pydantic documentation.","title":"BigInteger"},{"location":"fields/field-types/#float","text":"Float(minimum: float = None, maximum: float = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.Float Type (used for pydantic): float Tip For explanation of other parameters check pydantic documentation.","title":"Float"},{"location":"fields/field-types/#decimal","text":"Decimal(minimum: float = None, maximum: float = None, multiple_of: int = None, precision: int = None, scale: int = None, max_digits: int = None, decimal_places: int = None) has no required parameters You can use either length and precision parameters or max_digits and decimal_places . Sqlalchemy column: sqlalchemy.DECIMAL Type (used for pydantic): decimal.Decimal Tip For explanation of other parameters check pydantic documentation.","title":"Decimal"},{"location":"fields/field-types/#date","text":"Date() has no required parameters. Sqlalchemy column: sqlalchemy.Date Type (used for pydantic): datetime.date","title":"Date"},{"location":"fields/field-types/#time","text":"Time() has no required parameters. Sqlalchemy column: sqlalchemy.Time Type (used for pydantic): datetime.time","title":"Time"},{"location":"fields/field-types/#datetime","text":"DateTime() has no required parameters. Sqlalchemy column: sqlalchemy.DateTime Type (used for pydantic): datetime.datetime","title":"DateTime"},{"location":"fields/field-types/#json","text":"JSON() has no required parameters. Sqlalchemy column: sqlalchemy.JSON Type (used for pydantic): pydantic.Json","title":"JSON"},{"location":"fields/field-types/#uuid","text":"UUID(uuid_format: str = 'hex') has no required parameters. Sqlalchemy column: ormar.UUID based on sqlalchemy.CHAR(36) or sqlalchemy.CHAR(32) field (for string or hex format respectively) Type (used for pydantic): uuid.UUID uuid_format parameters allow 'hex'(default) or 'string' values. Depending on the format either 32 or 36 char is used in the database. Sample: 'hex' format value = c616ab438cce49dbbf4380d109251dce (CHAR(32)) 'string' value = c616ab43-8cce-49db-bf43-80d109251dce (CHAR(36)) When loaded it's always python UUID so you can compare it and compare two formats values between each other.","title":"UUID"},{"location":"models/","text":"Models Defining models By defining an ormar Model you get corresponding Pydantic model as well as Sqlalchemy table for free. They are being managed in the background and you do not have to create them on your own. Model Class To build an ormar model you simply need to inherit a ormar.Model class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Defining Fields Next assign one or more of the Fields as a class level variables. Basic Field Types Each table has to have a primary key column, which you specify by setting primary_key=True on selected field. Only one primary key column is allowed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Warning Not assigning primary_key column or assigning more than one column per Model will raise ModelDefinitionError exception. By default if you assign primary key to Integer field, the autoincrement option is set to true. You can disable by passing autoincremant=False . 1 id : int = ormar . Integer ( primary_key = True , autoincrement = False ) Non Database Fields Note that if you need a normal pydantic field in your model (used to store value on model or pass around some value) you can define a field with parameter pydantic_only=True . Fields created like this are added to the pydantic model fields -> so are subject to validation according to Field type, also appear in dict() and json() result. The difference is that those fields are not saved in the database . So they won't be included in underlying sqlalchemy columns , or table variables (check Internals section below to see how you can access those if you need). Subsequently pydantic_only fields won't be included in migrations or any database operation (like save , update etc.) Fields like those can be passed around into payload in fastapi request and will be returned in fastapi response (of course only if you set their value somewhere in your code as the value is not fetched from the db. If you pass a value in fastapi request and return the same instance that fastapi constructs for you in request_model you should get back exactly same value in response .). Warning pydantic_only=True fields are always Optional and it cannot be changed (otherwise db load validation would fail) Tip pydantic_only=True fields are a good solution if you need to pass additional information from outside of your API (i.e. frontend). They are not stored in db but you can access them in your APIRoute code and they also have pydantic validation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) non_db_field : str = ormar . String ( max_length = 100 , pydantic_only = True ) If you combine pydantic_only=True field with default parameter and do not pass actual value in request you will always get default value. Since it can be a function you can set default=datetime.datetime.now and get current timestamp each time you call an endpoint etc. Note Note that both pydantic_only and property_field decorated field can be included/excluded in both dict() and fastapi response with include / exclude and response_model_include / response_model_exclude accordingly. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # <==related of code removed for clarity==> class User ( ormar . Model ): class Meta : tablename : str = \"users2\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) email : str = ormar . String ( max_length = 255 , nullable = False ) password : str = ormar . String ( max_length = 255 ) first_name : str = ormar . String ( max_length = 255 ) last_name : str = ormar . String ( max_length = 255 ) category : str = ormar . String ( max_length = 255 , nullable = True ) timestamp : datetime . datetime = ormar . DateTime ( pydantic_only = True , default = datetime . datetime . now ) # <==related of code removed for clarity==> app = FastAPI () @app . post ( \"/users/\" ) async def create_user ( user : User ): return await user . save () # <==related of code removed for clarity==> def test_excluding_fields_in_endpoints (): client = TestClient ( app ) with client as client : timestamp = datetime . datetime . now () user = { \"email\" : \"test@domain.com\" , \"password\" : \"^*^%A*DA*IAAA\" , \"first_name\" : \"John\" , \"last_name\" : \"Doe\" , \"timestamp\" : str ( timestamp ), } response = client . post ( \"/users/\" , json = user ) assert list ( response . json () . keys ()) == [ \"id\" , \"email\" , \"first_name\" , \"last_name\" , \"category\" , \"timestamp\" , ] # returned is the same timestamp assert response . json () . get ( \"timestamp\" ) == str ( timestamp ) . replace ( \" \" , \"T\" ) # <==related of code removed for clarity==> Property fields Sometimes it's desirable to do some kind of calculation on the model instance. One of the most common examples can be concatenating two or more fields. Imagine you have first_name and last_name fields on your model, but would like to have full_name in the result of the fastapi query. You can create a new pydantic model with a method that accepts only self (so like default python @property ) and populate it in your code. But it's so common that ormar has you covered. You can \"materialize\" a property_field on you Model . Warning property_field fields are always Optional and it cannot be changed (otherwise db load validation would fail) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import databases import sqlalchemy import ormar from ormar import property_field database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) @property_field def prefixed_name ( self ): return 'custom_prefix__' + self . name Warning The decorated function has to accept only one parameter, and that parameter have to be self . If you try to decorate a function with more parameters ormar will raise ModelDefinitionError . Sample: 1 2 3 4 5 6 7 8 9 10 # will raise ModelDefinitionError @property_field def prefixed_name ( self , prefix = \"prefix_\" ): return 'custom_prefix__' + self . name # will raise ModelDefinitionError # (calling first param something else than 'self' is a bad practice anyway) @property_field def prefixed_name ( instance ): return 'custom_prefix__' + self . name Note that property_field decorated methods do not go through verification (but that might change in future) and are only available in the response from fastapi and dict() and json() methods. You cannot pass a value for this field in the request (or rather you can but it will be discarded by ormar so really no point but no Exception will be raised). Note Note that both pydantic_only and property_field decorated field can be included/excluded in both dict() and fastapi response with include / exclude and response_model_include / response_model_exclude accordingly. Tip Note that @property_field decorator is designed to replace the python @property decorator, you do not have to combine them. In theory you can cause ormar have a failsafe mechanism, but note that i.e. mypy will complain about re-decorating a property. 1 2 3 4 5 # valid and working but unnecessary and mypy will complain @property_field @property def prefixed_name ( self ): return 'custom_prefix__' + self . name 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # <==related of code removed for clarity==> def gen_pass (): # note: NOT production ready choices = string . ascii_letters + string . digits + \"!@#$%^&*()\" return \"\" . join ( random . choice ( choices ) for _ in range ( 20 )) class RandomModel ( ormar . Model ): class Meta : tablename : str = \"random_users\" metadata = metadata database = database include_props_in_dict = True id : int = ormar . Integer ( primary_key = True ) password : str = ormar . String ( max_length = 255 , default = gen_pass ) first_name : str = ormar . String ( max_length = 255 , default = \"John\" ) last_name : str = ormar . String ( max_length = 255 ) created_date : datetime . datetime = ormar . DateTime ( server_default = sqlalchemy . func . now () ) @property_field def full_name ( self ) -> str : return \" \" . join ([ self . first_name , self . last_name ]) # <==related of code removed for clarity==> app = FastAPI () # explicitly exclude property_field in this endpoint @app . post ( \"/random/\" , response_model = RandomModel , response_model_exclude = { \"full_name\" }) async def create_user ( user : RandomModel ): return await user . save () # <==related of code removed for clarity==> def test_excluding_property_field_in_endpoints2 (): client = TestClient ( app ) with client as client : RandomModel . Meta . include_props_in_dict = True user3 = { \"last_name\" : \"Test\" } response = client . post ( \"/random3/\" , json = user3 ) assert list ( response . json () . keys ()) == [ \"id\" , \"password\" , \"first_name\" , \"last_name\" , \"created_date\" , ] # despite being decorated with property_field if you explictly exclude it it will be gone assert response . json () . get ( \"full_name\" ) is None # <==related of code removed for clarity==> Fields names vs Column names By default names of the fields will be used for both the underlying pydantic model and sqlalchemy table. If for whatever reason you prefer to change the name in the database but keep the name in the model you can do this with specifying name parameter during Field declaration Here you have a sample model with changed names 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class Child ( ormar . Model ): class Meta : tablename = \"children\" metadata = metadata database = database id : int = ormar . Integer ( name = \"child_id\" , primary_key = True ) first_name : str = ormar . String ( name = \"fname\" , max_length = 100 ) last_name : str = ormar . String ( name = \"lname\" , max_length = 100 ) born_year : int = ormar . Integer ( name = \"year_born\" , nullable = True ) Note that you can also change the ForeignKey column name 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from typing import Optional import databases import sqlalchemy import ormar from .docs010 import Artist # previous example database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"music_albums\" metadata = metadata database = database id : int = ormar . Integer ( name = \"album_id\" , primary_key = True ) name : str = ormar . String ( name = \"album_name\" , max_length = 100 ) artist : Optional [ Artist ] = ormar . ForeignKey ( Artist , name = \"artist_id\" ) But for now you cannot change the ManyToMany column names as they go through other Model anyway. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import databases import sqlalchemy import ormar from .docs008 import Child database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class ArtistChildren ( ormar . Model ): class Meta : tablename = \"children_x_artists\" metadata = metadata database = database class Artist ( ormar . Model ): class Meta : tablename = \"artists\" metadata = metadata database = database id : int = ormar . Integer ( name = \"artist_id\" , primary_key = True ) first_name : str = ormar . String ( name = \"fname\" , max_length = 100 ) last_name : str = ormar . String ( name = \"lname\" , max_length = 100 ) born_year : int = ormar . Integer ( name = \"year\" ) children = ormar . ManyToMany ( Child , through = ArtistChildren ) Type Hints & Legacy Before version 0.4.0 ormar supported only one way of defining Fields on a Model using python type hints as pydantic. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : ormar . Integer ( primary_key = True ) name : ormar . String ( max_length = 100 ) completed : ormar . Boolean ( default = False ) c1 = Course () But that didn't play well with static type checkers like mypy and pydantic PyCharm plugin. Therefore from version >=0.4.0 ormar switched to new notation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Note that type hints are optional so perfectly valid ormar code can look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 100 ) completed = ormar . Boolean ( default = False ) Warning Even if you use type hints ormar does not use them to construct pydantic fields! Type hints are there only to support static checkers and linting, ormar construct annotations used by pydantic from own fields. Dependencies Since ormar depends on databases and sqlalchemy-core for database connection and table creation you need to assign each Model with two special parameters. Databases One is Database instance created with your database url in sqlalchemy connection string format. Created instance needs to be passed to every Model with Meta class database parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Tip You need to create the Database instance only once and use it for all models. You can create several ones if you want to use multiple databases. Sqlalchemy Second dependency is sqlalchemy MetaData instance. Created instance needs to be passed to every Model with Meta class metadata parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Tip You need to create the MetaData instance only once and use it for all models. You can create several ones if you want to use multiple databases. Best practice Only thing that ormar expects is a class with name Meta and two class variables: metadata and databases . So instead of providing the same parameters over and over again for all models you should creata a class and subclass it in all models. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () # note that you do not have to subclass ModelMeta, # it's useful for type hints and code completion class MainMeta ( ormar . ModelMeta ): metadata = metadata database = database class Artist ( ormar . Model ): class Meta ( MainMeta ): # note that tablename is optional # if not provided ormar will user class.__name__.lower()+'s' # -> artists in this example pass id : int = ormar . Integer ( primary_key = True ) first_name : str = ormar . String ( max_length = 100 ) last_name : str = ormar . String ( max_length = 100 ) born_year : int = ormar . Integer ( name = \"year\" ) class Album ( ormar . Model ): class Meta ( MainMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) artist : Optional [ Artist ] = ormar . ForeignKey ( Artist ) Warning You need to subclass your MainMeta class in each Model class as those classes store configuration variables that otherwise would be overwritten by each Model . Table Names By default table name is created from Model class name as lowercase name plus 's'. You can overwrite this parameter by providing Meta class tablename argument. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : # if you omit this parameter it will be created automatically # as class.__name__.lower()+'s' -> \"courses\" in this example tablename = \"my_courses\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Constraints On a model level you can also set model-wise constraints on sql columns. Right now only UniqueColumns constraint is present. Tip To read more about columns constraints like primary_key , unique , ForeignKey etc. visit fields . You can set this parameter by providing Meta class constraints argument. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata # define your constraints in Meta class of the model # it's a list that can contain multiple constraints # hera a combination of name and column will have to be unique in db constraints = [ ormar . UniqueColumns ( \"name\" , \"completed\" )] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Model Initialization There are two ways to create and persist the Model instance in the database. Tip Use ipython to try this from the console, since it supports await . If you plan to modify the instance in the later execution of your program you can initiate your Model as a normal class and later await a save() call. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) course = Course ( name = \"Painting for dummies\" , completed = False ) await course . save () await Course . objects . create ( name = \"Painting for dummies\" , completed = False ) If you want to initiate your Model and at the same time save in in the database use a QuerySet's method create() . For creating multiple objects at once a bulk_create() QuerySet's method is available. Each model has a QuerySet initialised as objects parameter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) course = Course ( name = \"Painting for dummies\" , completed = False ) await course . save () await Course . objects . create ( name = \"Painting for dummies\" , completed = False ) Info To read more about QuerySets (including bulk operations) and available methods visit queries Model save status Each model instance is a separate python object and they do not know anything about each other. 1 2 3 4 5 6 7 8 track1 = await Track . objects . get ( name = 'The Bird' ) track2 = await Track . objects . get ( name = 'The Bird' ) assert track1 == track2 # True track1 . name = 'The Bird2' await track1 . save () assert track1 . name == track2 . name # False # track2 does not update and knows nothing about track1 The objects itself have a saved status, which is set as following: Model is saved after save/update/load/upsert method on model Model is saved after create/get/first/all/get_or_create/update_or_create method Model is saved when passed to bulk_update and bulk_create Model is saved after adding/removing ManyToMany related objects (through model instance auto saved/deleted) Model is not saved after change of any own field (including pk as Model.pk alias) Model is not saved after adding/removing ForeignKey related object (fk column not saved) Model is not saved after instantiation with __init__ (w/o QuerySet.create or before calling save ) You can check if model is saved with ModelInstance.saved property","title":"Definition"},{"location":"models/#models","text":"","title":"Models"},{"location":"models/#defining-models","text":"By defining an ormar Model you get corresponding Pydantic model as well as Sqlalchemy table for free. They are being managed in the background and you do not have to create them on your own.","title":"Defining models"},{"location":"models/#model-class","text":"To build an ormar model you simply need to inherit a ormar.Model class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False )","title":"Model Class"},{"location":"models/#defining-fields","text":"Next assign one or more of the Fields as a class level variables.","title":"Defining Fields"},{"location":"models/#basic-field-types","text":"Each table has to have a primary key column, which you specify by setting primary_key=True on selected field. Only one primary key column is allowed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Warning Not assigning primary_key column or assigning more than one column per Model will raise ModelDefinitionError exception. By default if you assign primary key to Integer field, the autoincrement option is set to true. You can disable by passing autoincremant=False . 1 id : int = ormar . Integer ( primary_key = True , autoincrement = False )","title":"Basic Field Types"},{"location":"models/#non-database-fields","text":"Note that if you need a normal pydantic field in your model (used to store value on model or pass around some value) you can define a field with parameter pydantic_only=True . Fields created like this are added to the pydantic model fields -> so are subject to validation according to Field type, also appear in dict() and json() result. The difference is that those fields are not saved in the database . So they won't be included in underlying sqlalchemy columns , or table variables (check Internals section below to see how you can access those if you need). Subsequently pydantic_only fields won't be included in migrations or any database operation (like save , update etc.) Fields like those can be passed around into payload in fastapi request and will be returned in fastapi response (of course only if you set their value somewhere in your code as the value is not fetched from the db. If you pass a value in fastapi request and return the same instance that fastapi constructs for you in request_model you should get back exactly same value in response .). Warning pydantic_only=True fields are always Optional and it cannot be changed (otherwise db load validation would fail) Tip pydantic_only=True fields are a good solution if you need to pass additional information from outside of your API (i.e. frontend). They are not stored in db but you can access them in your APIRoute code and they also have pydantic validation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) non_db_field : str = ormar . String ( max_length = 100 , pydantic_only = True ) If you combine pydantic_only=True field with default parameter and do not pass actual value in request you will always get default value. Since it can be a function you can set default=datetime.datetime.now and get current timestamp each time you call an endpoint etc. Note Note that both pydantic_only and property_field decorated field can be included/excluded in both dict() and fastapi response with include / exclude and response_model_include / response_model_exclude accordingly. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # <==related of code removed for clarity==> class User ( ormar . Model ): class Meta : tablename : str = \"users2\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) email : str = ormar . String ( max_length = 255 , nullable = False ) password : str = ormar . String ( max_length = 255 ) first_name : str = ormar . String ( max_length = 255 ) last_name : str = ormar . String ( max_length = 255 ) category : str = ormar . String ( max_length = 255 , nullable = True ) timestamp : datetime . datetime = ormar . DateTime ( pydantic_only = True , default = datetime . datetime . now ) # <==related of code removed for clarity==> app = FastAPI () @app . post ( \"/users/\" ) async def create_user ( user : User ): return await user . save () # <==related of code removed for clarity==> def test_excluding_fields_in_endpoints (): client = TestClient ( app ) with client as client : timestamp = datetime . datetime . now () user = { \"email\" : \"test@domain.com\" , \"password\" : \"^*^%A*DA*IAAA\" , \"first_name\" : \"John\" , \"last_name\" : \"Doe\" , \"timestamp\" : str ( timestamp ), } response = client . post ( \"/users/\" , json = user ) assert list ( response . json () . keys ()) == [ \"id\" , \"email\" , \"first_name\" , \"last_name\" , \"category\" , \"timestamp\" , ] # returned is the same timestamp assert response . json () . get ( \"timestamp\" ) == str ( timestamp ) . replace ( \" \" , \"T\" ) # <==related of code removed for clarity==>","title":"Non Database Fields"},{"location":"models/#property-fields","text":"Sometimes it's desirable to do some kind of calculation on the model instance. One of the most common examples can be concatenating two or more fields. Imagine you have first_name and last_name fields on your model, but would like to have full_name in the result of the fastapi query. You can create a new pydantic model with a method that accepts only self (so like default python @property ) and populate it in your code. But it's so common that ormar has you covered. You can \"materialize\" a property_field on you Model . Warning property_field fields are always Optional and it cannot be changed (otherwise db load validation would fail) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import databases import sqlalchemy import ormar from ormar import property_field database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) @property_field def prefixed_name ( self ): return 'custom_prefix__' + self . name Warning The decorated function has to accept only one parameter, and that parameter have to be self . If you try to decorate a function with more parameters ormar will raise ModelDefinitionError . Sample: 1 2 3 4 5 6 7 8 9 10 # will raise ModelDefinitionError @property_field def prefixed_name ( self , prefix = \"prefix_\" ): return 'custom_prefix__' + self . name # will raise ModelDefinitionError # (calling first param something else than 'self' is a bad practice anyway) @property_field def prefixed_name ( instance ): return 'custom_prefix__' + self . name Note that property_field decorated methods do not go through verification (but that might change in future) and are only available in the response from fastapi and dict() and json() methods. You cannot pass a value for this field in the request (or rather you can but it will be discarded by ormar so really no point but no Exception will be raised). Note Note that both pydantic_only and property_field decorated field can be included/excluded in both dict() and fastapi response with include / exclude and response_model_include / response_model_exclude accordingly. Tip Note that @property_field decorator is designed to replace the python @property decorator, you do not have to combine them. In theory you can cause ormar have a failsafe mechanism, but note that i.e. mypy will complain about re-decorating a property. 1 2 3 4 5 # valid and working but unnecessary and mypy will complain @property_field @property def prefixed_name ( self ): return 'custom_prefix__' + self . name 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # <==related of code removed for clarity==> def gen_pass (): # note: NOT production ready choices = string . ascii_letters + string . digits + \"!@#$%^&*()\" return \"\" . join ( random . choice ( choices ) for _ in range ( 20 )) class RandomModel ( ormar . Model ): class Meta : tablename : str = \"random_users\" metadata = metadata database = database include_props_in_dict = True id : int = ormar . Integer ( primary_key = True ) password : str = ormar . String ( max_length = 255 , default = gen_pass ) first_name : str = ormar . String ( max_length = 255 , default = \"John\" ) last_name : str = ormar . String ( max_length = 255 ) created_date : datetime . datetime = ormar . DateTime ( server_default = sqlalchemy . func . now () ) @property_field def full_name ( self ) -> str : return \" \" . join ([ self . first_name , self . last_name ]) # <==related of code removed for clarity==> app = FastAPI () # explicitly exclude property_field in this endpoint @app . post ( \"/random/\" , response_model = RandomModel , response_model_exclude = { \"full_name\" }) async def create_user ( user : RandomModel ): return await user . save () # <==related of code removed for clarity==> def test_excluding_property_field_in_endpoints2 (): client = TestClient ( app ) with client as client : RandomModel . Meta . include_props_in_dict = True user3 = { \"last_name\" : \"Test\" } response = client . post ( \"/random3/\" , json = user3 ) assert list ( response . json () . keys ()) == [ \"id\" , \"password\" , \"first_name\" , \"last_name\" , \"created_date\" , ] # despite being decorated with property_field if you explictly exclude it it will be gone assert response . json () . get ( \"full_name\" ) is None # <==related of code removed for clarity==>","title":"Property fields"},{"location":"models/#fields-names-vs-column-names","text":"By default names of the fields will be used for both the underlying pydantic model and sqlalchemy table. If for whatever reason you prefer to change the name in the database but keep the name in the model you can do this with specifying name parameter during Field declaration Here you have a sample model with changed names 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class Child ( ormar . Model ): class Meta : tablename = \"children\" metadata = metadata database = database id : int = ormar . Integer ( name = \"child_id\" , primary_key = True ) first_name : str = ormar . String ( name = \"fname\" , max_length = 100 ) last_name : str = ormar . String ( name = \"lname\" , max_length = 100 ) born_year : int = ormar . Integer ( name = \"year_born\" , nullable = True ) Note that you can also change the ForeignKey column name 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from typing import Optional import databases import sqlalchemy import ormar from .docs010 import Artist # previous example database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"music_albums\" metadata = metadata database = database id : int = ormar . Integer ( name = \"album_id\" , primary_key = True ) name : str = ormar . String ( name = \"album_name\" , max_length = 100 ) artist : Optional [ Artist ] = ormar . ForeignKey ( Artist , name = \"artist_id\" ) But for now you cannot change the ManyToMany column names as they go through other Model anyway. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import databases import sqlalchemy import ormar from .docs008 import Child database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class ArtistChildren ( ormar . Model ): class Meta : tablename = \"children_x_artists\" metadata = metadata database = database class Artist ( ormar . Model ): class Meta : tablename = \"artists\" metadata = metadata database = database id : int = ormar . Integer ( name = \"artist_id\" , primary_key = True ) first_name : str = ormar . String ( name = \"fname\" , max_length = 100 ) last_name : str = ormar . String ( name = \"lname\" , max_length = 100 ) born_year : int = ormar . Integer ( name = \"year\" ) children = ormar . ManyToMany ( Child , through = ArtistChildren )","title":"Fields names vs Column names"},{"location":"models/#type-hints-legacy","text":"Before version 0.4.0 ormar supported only one way of defining Fields on a Model using python type hints as pydantic. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : ormar . Integer ( primary_key = True ) name : ormar . String ( max_length = 100 ) completed : ormar . Boolean ( default = False ) c1 = Course () But that didn't play well with static type checkers like mypy and pydantic PyCharm plugin. Therefore from version >=0.4.0 ormar switched to new notation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Note that type hints are optional so perfectly valid ormar code can look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 100 ) completed = ormar . Boolean ( default = False ) Warning Even if you use type hints ormar does not use them to construct pydantic fields! Type hints are there only to support static checkers and linting, ormar construct annotations used by pydantic from own fields.","title":"Type Hints &amp; Legacy"},{"location":"models/#dependencies","text":"Since ormar depends on databases and sqlalchemy-core for database connection and table creation you need to assign each Model with two special parameters.","title":"Dependencies"},{"location":"models/#databases","text":"One is Database instance created with your database url in sqlalchemy connection string format. Created instance needs to be passed to every Model with Meta class database parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Tip You need to create the Database instance only once and use it for all models. You can create several ones if you want to use multiple databases.","title":"Databases"},{"location":"models/#sqlalchemy","text":"Second dependency is sqlalchemy MetaData instance. Created instance needs to be passed to every Model with Meta class metadata parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Tip You need to create the MetaData instance only once and use it for all models. You can create several ones if you want to use multiple databases.","title":"Sqlalchemy"},{"location":"models/#best-practice","text":"Only thing that ormar expects is a class with name Meta and two class variables: metadata and databases . So instead of providing the same parameters over and over again for all models you should creata a class and subclass it in all models. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () # note that you do not have to subclass ModelMeta, # it's useful for type hints and code completion class MainMeta ( ormar . ModelMeta ): metadata = metadata database = database class Artist ( ormar . Model ): class Meta ( MainMeta ): # note that tablename is optional # if not provided ormar will user class.__name__.lower()+'s' # -> artists in this example pass id : int = ormar . Integer ( primary_key = True ) first_name : str = ormar . String ( max_length = 100 ) last_name : str = ormar . String ( max_length = 100 ) born_year : int = ormar . Integer ( name = \"year\" ) class Album ( ormar . Model ): class Meta ( MainMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) artist : Optional [ Artist ] = ormar . ForeignKey ( Artist ) Warning You need to subclass your MainMeta class in each Model class as those classes store configuration variables that otherwise would be overwritten by each Model .","title":"Best practice"},{"location":"models/#table-names","text":"By default table name is created from Model class name as lowercase name plus 's'. You can overwrite this parameter by providing Meta class tablename argument. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : # if you omit this parameter it will be created automatically # as class.__name__.lower()+'s' -> \"courses\" in this example tablename = \"my_courses\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False )","title":"Table Names"},{"location":"models/#constraints","text":"On a model level you can also set model-wise constraints on sql columns. Right now only UniqueColumns constraint is present. Tip To read more about columns constraints like primary_key , unique , ForeignKey etc. visit fields . You can set this parameter by providing Meta class constraints argument. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata # define your constraints in Meta class of the model # it's a list that can contain multiple constraints # hera a combination of name and column will have to be unique in db constraints = [ ormar . UniqueColumns ( \"name\" , \"completed\" )] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False )","title":"Constraints"},{"location":"models/#model-initialization","text":"There are two ways to create and persist the Model instance in the database. Tip Use ipython to try this from the console, since it supports await . If you plan to modify the instance in the later execution of your program you can initiate your Model as a normal class and later await a save() call. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) course = Course ( name = \"Painting for dummies\" , completed = False ) await course . save () await Course . objects . create ( name = \"Painting for dummies\" , completed = False ) If you want to initiate your Model and at the same time save in in the database use a QuerySet's method create() . For creating multiple objects at once a bulk_create() QuerySet's method is available. Each model has a QuerySet initialised as objects parameter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) course = Course ( name = \"Painting for dummies\" , completed = False ) await course . save () await Course . objects . create ( name = \"Painting for dummies\" , completed = False ) Info To read more about QuerySets (including bulk operations) and available methods visit queries","title":"Model Initialization"},{"location":"models/#model-save-status","text":"Each model instance is a separate python object and they do not know anything about each other. 1 2 3 4 5 6 7 8 track1 = await Track . objects . get ( name = 'The Bird' ) track2 = await Track . objects . get ( name = 'The Bird' ) assert track1 == track2 # True track1 . name = 'The Bird2' await track1 . save () assert track1 . name == track2 . name # False # track2 does not update and knows nothing about track1 The objects itself have a saved status, which is set as following: Model is saved after save/update/load/upsert method on model Model is saved after create/get/first/all/get_or_create/update_or_create method Model is saved when passed to bulk_update and bulk_create Model is saved after adding/removing ManyToMany related objects (through model instance auto saved/deleted) Model is not saved after change of any own field (including pk as Model.pk alias) Model is not saved after adding/removing ForeignKey related object (fk column not saved) Model is not saved after instantiation with __init__ (w/o QuerySet.create or before calling save ) You can check if model is saved with ModelInstance.saved property","title":"Model save status"},{"location":"models/inheritance/","text":"Inheritance Out of various types of ORM models inheritance ormar currently supports two of them: Mixins Concrete table inheritance (with parents set to abstract=True ) Types of inheritance The short summary of different types of inheritance is: Mixins [SUPPORTED] - don't subclass ormar.Model , just define fields that are later used on different models (like created_date and updated_date on each model), only actual models create tables, but those fields from mixins are added Concrete table inheritance [SUPPORTED] - means that parent is marked as abstract and each child has its own table with columns from a parent and own child columns, kind of similar to Mixins but parent also is a Model Single table inheritance [NOT SUPPORTED] - means that only one table is created with fields that are combination/sum of the parent and all children models but child models use only subset of column in db (all parent and own ones, skipping the other children ones) Multi/ Joined table inheritance [NOT SUPPORTED] - means that part of the columns is saved on parent model and part is saved on child model that are connected to each other by kind of one to one relation and under the hood you operate on two models at once Proxy models [NOT SUPPORTED] - means that only parent has an actual table, children just add methods, modify settings etc. Mixins To use Mixins just define a class that is not inheriting from an ormar.Model but is defining ormar.Fields as class variables. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # a mixin defines the fields but is a normal python class class AuditMixin : created_by : str = ormar . String ( max_length = 100 ) updated_by : str = ormar . String ( max_length = 100 , default = \"Sam\" ) class DateFieldsMixins : created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) updated_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) # a models can inherit from one or more mixins class Category ( ormar . Model , DateFieldsMixins , AuditMixin ): class Meta ( ormar . ModelMeta ): tablename = \"categories\" metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 , unique = True , index = True ) code : int = ormar . Integer () Tip Note that Mixins are not models, so you still need to inherit from ormar.Model as well as define Meta class in the final model. A Category class above will have four additional fields: created_date , updated_date , created_by and updated_by . There will be only one table created for model Category ( categories ), with Category class fields combined with all Mixins fields. Note that Mixin in class name is optional but is a good python practice. Concrete table inheritance In concept concrete table inheritance is very similar to Mixins, but uses actual ormar.Models as base classes. Warning Note that base classes have abstract=True set in Meta class, if you try to inherit from non abstract marked class ModelDefinitionError will be raised. Since this abstract Model will never be initialized you can skip metadata and database in it's Meta definition. But if you provide it - it will be inherited, that way you do not have to provide metadata and databases in the final/concrete class Note that you can always overwrite it in child/concrete class if you need to. More over at least one of the classes in inheritance chain have to provide both database and metadata - otherwise an error will be raised. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # note that base classes have abstract=True # since this model will never be initialized you can skip metadata and database class AuditModel ( ormar . Model ): class Meta : abstract = True created_by : str = ormar . String ( max_length = 100 ) updated_by : str = ormar . String ( max_length = 100 , default = \"Sam\" ) # but if you provide it it will be inherited - DRY (Don't Repeat Yourself) in action class DateFieldsModel ( ormar . Model ): class Meta : abstract = True metadata = metadata database = db created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) updated_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) # that way you do not have to provide metadata and databases in concrete class class Category ( DateFieldsModel , AuditModel ): class Meta ( ormar . ModelMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 , unique = True , index = True ) code : int = ormar . Integer () The list of inherited options/settings is as follows: metadata , database and constraints . Also methods decorated with @property_field decorator will be inherited/recognized. Of course apart from that all fields from base classes are combined and created in the concrete table of the final Model. Tip Note how you don't have to provide abstarct=False in the final class - it's the default setting that is not inherited. Redefining fields in subclasses Note that you can redefine previously created fields like in normal python class inheritance. Whenever you define a field with same name and new definition it will completely replace the previously defined one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # base class class DateFieldsModel ( ormar . Model ): class Meta : abstract = True metadata = metadata database = db # note that UniqueColumns need sqlalchemy db columns names not the ormar ones constraints = [ ormar . UniqueColumns ( \"creation_date\" , \"modification_date\" )] created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now , name = \"creation_date\" ) updated_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now , name = \"modification_date\" ) class RedefinedField ( DateFieldsModel ): class Meta ( ormar . ModelMeta ): tablename = \"redefines\" metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) # here the created_date is replaced by the String field created_date : str = ormar . String ( max_length = 200 , name = \"creation_date\" ) # you can verify that the final field is correctly declared and created changed_field = RedefinedField . Meta . model_fields [ \"created_date\" ] assert changed_field . default is None assert changed_field . alias == \"creation_date\" assert any ( x . name == \"creation_date\" for x in RedefinedField . Meta . table . columns ) assert isinstance ( RedefinedField . Meta . table . columns [ \"creation_date\" ] . type , sqlalchemy . sql . sqltypes . String , ) Warning If you declare UniqueColumns constraint with column names, the final model has to have a column with the same name declared. Otherwise, the ModelDefinitionError will be raised. So in example above if you do not provide name for created_date in RedefinedField model ormar will complain. created_date: str = ormar.String(max_length=200) # exception created_date: str = ormar.String(max_length=200, name=\"creation_date2\") # exception Relations in inheritance You can declare relations in every step of inheritance, so both in parent and child classes. When you define a relation on a child model level it's either overwriting the relation defined in parent model (if the same field name is used), or is accessible only to this child if you define a new relation. When inheriting relations, you always need to be aware of related_name parameter, that has to be unique across a related model, when you define multiple child classes that inherit the same relation. If you do not provide related_name parameter ormar calculates it for you. This works with inheritance as all child models have to have different class names, which are used to calculate the default related_name (class.name.lower()+'s'). But, if you provide a related_name this name cannot be reused in all child models as they would overwrite each other on the related model side. Therefore, you have two options: redefine relation field in child models and manually provide different related_name parameters let this for ormar to handle -> auto adjusted related_name are: original related_name + \"_\" + child model table name That might sound complicated but let's look at the following example: ForeignKey relations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # normal model used in relation class Person ( ormar . Model ): class Meta : metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # parent model - needs to be abstract class Car ( ormar . Model ): class Meta : abstract = True metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 ) owner : Person = ormar . ForeignKey ( Person ) # note that we refer to the Person model again so we **have to** provide related_name co_owner : Person = ormar . ForeignKey ( Person , related_name = \"coowned\" ) created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) class Truck ( Car ): class Meta : pass max_capacity : int = ormar . Integer () class Bus ( Car ): class Meta : # default naming is name.lower()+'s' so it's ugly for buss ;) tablename = \"buses\" max_persons : int = ormar . Integer () Now when you will inspect the fields on Person model you will get: 1 2 3 4 5 6 7 8 9 Person . Meta . model_fields \"\"\" {'id': <class 'ormar.fields.model_fields.Integer'>, 'name': <class 'ormar.fields.model_fields.String'>, 'trucks': <class 'ormar.fields.foreign_key.ForeignKey'>, 'coowned_trucks': <class 'ormar.fields.foreign_key.ForeignKey'>, 'buss': <class 'ormar.fields.foreign_key.ForeignKey'>, 'coowned_buses': <class 'ormar.fields.foreign_key.ForeignKey'>} \"\"\" Note how you have trucks and buss fields that leads to Truck and Bus class that this Person owns. There were no related_name parameter so default names were used. At the same time the co-owned cars need to be referenced by coowned_trucks and coowned_buses . Ormar appended _trucks and _buses suffixes taken from child model table names. Seems fine, but the default name for owned trucks is ok ( trucks ) but the buss is ugly, so how can we change it? The solution is pretty simple - just redefine the field in Bus class and provide different related_name parameter. 1 2 3 4 5 6 7 8 # rest of the above example remains the same class Bus ( Car ): class Meta : tablename = \"buses\" # new field that changes the related_name owner : Person = ormar . ForeignKey ( Person , related_name = \"buses\" ) max_persons : int = ormar . Integer () Now the columns looks much better. 1 2 3 4 5 6 7 8 9 Person . Meta . model_fields \"\"\" {'id': <class 'ormar.fields.model_fields.Integer'>, 'name': <class 'ormar.fields.model_fields.String'>, 'trucks': <class 'ormar.fields.foreign_key.ForeignKey'>, 'coowned_trucks': <class 'ormar.fields.foreign_key.ForeignKey'>, 'buses': <class 'ormar.fields.foreign_key.ForeignKey'>, 'coowned_buses': <class 'ormar.fields.foreign_key.ForeignKey'>} \"\"\" Note You could also provide related_name for the owner field, that way the proper suffixes would be added. owner: Person = ormar.ForeignKey(Person, related_name=\"owned\") and model fields for Person owned cars would become owned_trucks and owned_buses . ManyToMany relations Similarly, you can inherit from Models that have ManyToMany relations declared but there is one, but substantial difference - the Through model. Since in the future the Through model will be able to hold additional fields and now it links only two Tables ( from and to ones), each child that inherits the m2m relation field has to have separate Through model. Of course, you can overwrite the relation in each Child model, but that requires additional code and undermines the point of the whole inheritance. Ormar will handle this for you if you agree with default naming convention, which you can always manually overwrite in children if needed. Again, let's look at the example to easier grasp the concepts. We will modify the previous example described above to use m2m relation for co_owners. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 # person remain the same as above class Person ( ormar . Model ): class Meta : metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # new through model between Person and Car2 class PersonsCar ( ormar . Model ): class Meta : tablename = \"cars_x_persons\" metadata = metadata database = db # note how co_owners is now ManyToMany relation class Car2 ( ormar . Model ): class Meta : # parent class needs to be marked abstract abstract = True metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 ) # note the related_name - needs to be unique across Person # model, regardless of how many different models leads to Person owner : Person = ormar . ForeignKey ( Person , related_name = \"owned\" ) co_owners : List [ Person ] = ormar . ManyToMany ( Person , through = PersonsCar , related_name = \"coowned\" ) created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) # child models define only additional Fields class Truck2 ( Car2 ): class Meta : # note how you don't have to provide inherited Meta params tablename = \"trucks2\" max_capacity : int = ormar . Integer () class Bus2 ( Car2 ): class Meta : tablename = \"buses2\" max_persons : int = ormar . Integer () Ormar automatically modifies related_name of the fields to include the table name of the children models. The dafault name is original related_name + '_' + child table name. That way for class Truck2 the relation defined in owner: Person = ormar.ForeignKey(Person, related_name=\"owned\") becomes owned_trucks2 You can verify the names by inspecting the list of fields present on Person model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Person . Meta . model_fields { # note how all relation fields need to be unique on Person # regardless if autogenerated or manually overwritten 'id' : < class ' ormar . fields . model_fields . Integer '>, 'name' : < class ' ormar . fields . model_fields . String '>, # note that we expanded on previous example so all 'old' fields are here 'trucks' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'coowned_trucks' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'buses' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'coowned_buses' : < class ' ormar . fields . foreign_key . ForeignKey '>, # newly defined related fields 'owned_trucks2' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'coowned_trucks2' : < class ' abc . ManyToMany '>, 'owned_buses2' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'coowned_buses2' : < class ' abc . ManyToMany '> } But that's not all. It's kind of internal to ormar but affects the data structure in the database, so let's examine the through models for both Bus2 and Truck2 models. 1 2 3 4 5 6 7 8 9 Bus2 . Meta . model_fields [ 'co_owners' ] . through < class ' abc . PersonsCarBus2 '> Bus2 . Meta . model_fields [ 'co_owners' ] . through . Meta . tablename 'cars_x_persons_buses2' Truck2 . Meta . model_fields [ 'co_owners' ] . through < class ' abc . PersonsCarTruck2 '> Truck2 . Meta . model_fields [ 'co_owners' ] . through . Meta . tablename 'cars_x_persons_trucks2' As you can see above ormar cloned the Through model for each of the Child classes and added Child class name at the end, while changing the table names of the cloned fields the name of the table from the child is used. Note that original model is not only not used, the table for this model is removed from metadata: 1 2 3 Bus2 . Meta . metadata . tables . keys () dict_keys ([ 'test_date_models' , 'categories' , 'subjects' , 'persons' , 'trucks' , 'buses' , 'cars_x_persons_trucks2' , 'trucks2' , 'cars_x_persons_buses2' , 'buses2' ]) So be aware that if you introduce inheritance along the way and convert a model into abstract parent model you may lose your data on through table if not careful. Note Note that original table name and model name of the Through model is never used. Only the cloned models tables are created and used. Warning Note that each subclass of the Model that has ManyToMany relation defined generates a new Through model, meaning also new database table . That means that each time you define a Child model you need to either manually create the table in the database, or run a migration (with alembic).","title":"Inheritance"},{"location":"models/inheritance/#inheritance","text":"Out of various types of ORM models inheritance ormar currently supports two of them: Mixins Concrete table inheritance (with parents set to abstract=True )","title":"Inheritance"},{"location":"models/inheritance/#types-of-inheritance","text":"The short summary of different types of inheritance is: Mixins [SUPPORTED] - don't subclass ormar.Model , just define fields that are later used on different models (like created_date and updated_date on each model), only actual models create tables, but those fields from mixins are added Concrete table inheritance [SUPPORTED] - means that parent is marked as abstract and each child has its own table with columns from a parent and own child columns, kind of similar to Mixins but parent also is a Model Single table inheritance [NOT SUPPORTED] - means that only one table is created with fields that are combination/sum of the parent and all children models but child models use only subset of column in db (all parent and own ones, skipping the other children ones) Multi/ Joined table inheritance [NOT SUPPORTED] - means that part of the columns is saved on parent model and part is saved on child model that are connected to each other by kind of one to one relation and under the hood you operate on two models at once Proxy models [NOT SUPPORTED] - means that only parent has an actual table, children just add methods, modify settings etc.","title":"Types of inheritance"},{"location":"models/inheritance/#mixins","text":"To use Mixins just define a class that is not inheriting from an ormar.Model but is defining ormar.Fields as class variables. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # a mixin defines the fields but is a normal python class class AuditMixin : created_by : str = ormar . String ( max_length = 100 ) updated_by : str = ormar . String ( max_length = 100 , default = \"Sam\" ) class DateFieldsMixins : created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) updated_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) # a models can inherit from one or more mixins class Category ( ormar . Model , DateFieldsMixins , AuditMixin ): class Meta ( ormar . ModelMeta ): tablename = \"categories\" metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 , unique = True , index = True ) code : int = ormar . Integer () Tip Note that Mixins are not models, so you still need to inherit from ormar.Model as well as define Meta class in the final model. A Category class above will have four additional fields: created_date , updated_date , created_by and updated_by . There will be only one table created for model Category ( categories ), with Category class fields combined with all Mixins fields. Note that Mixin in class name is optional but is a good python practice.","title":"Mixins"},{"location":"models/inheritance/#concrete-table-inheritance","text":"In concept concrete table inheritance is very similar to Mixins, but uses actual ormar.Models as base classes. Warning Note that base classes have abstract=True set in Meta class, if you try to inherit from non abstract marked class ModelDefinitionError will be raised. Since this abstract Model will never be initialized you can skip metadata and database in it's Meta definition. But if you provide it - it will be inherited, that way you do not have to provide metadata and databases in the final/concrete class Note that you can always overwrite it in child/concrete class if you need to. More over at least one of the classes in inheritance chain have to provide both database and metadata - otherwise an error will be raised. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # note that base classes have abstract=True # since this model will never be initialized you can skip metadata and database class AuditModel ( ormar . Model ): class Meta : abstract = True created_by : str = ormar . String ( max_length = 100 ) updated_by : str = ormar . String ( max_length = 100 , default = \"Sam\" ) # but if you provide it it will be inherited - DRY (Don't Repeat Yourself) in action class DateFieldsModel ( ormar . Model ): class Meta : abstract = True metadata = metadata database = db created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) updated_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) # that way you do not have to provide metadata and databases in concrete class class Category ( DateFieldsModel , AuditModel ): class Meta ( ormar . ModelMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 , unique = True , index = True ) code : int = ormar . Integer () The list of inherited options/settings is as follows: metadata , database and constraints . Also methods decorated with @property_field decorator will be inherited/recognized. Of course apart from that all fields from base classes are combined and created in the concrete table of the final Model. Tip Note how you don't have to provide abstarct=False in the final class - it's the default setting that is not inherited.","title":"Concrete table inheritance"},{"location":"models/inheritance/#redefining-fields-in-subclasses","text":"Note that you can redefine previously created fields like in normal python class inheritance. Whenever you define a field with same name and new definition it will completely replace the previously defined one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # base class class DateFieldsModel ( ormar . Model ): class Meta : abstract = True metadata = metadata database = db # note that UniqueColumns need sqlalchemy db columns names not the ormar ones constraints = [ ormar . UniqueColumns ( \"creation_date\" , \"modification_date\" )] created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now , name = \"creation_date\" ) updated_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now , name = \"modification_date\" ) class RedefinedField ( DateFieldsModel ): class Meta ( ormar . ModelMeta ): tablename = \"redefines\" metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) # here the created_date is replaced by the String field created_date : str = ormar . String ( max_length = 200 , name = \"creation_date\" ) # you can verify that the final field is correctly declared and created changed_field = RedefinedField . Meta . model_fields [ \"created_date\" ] assert changed_field . default is None assert changed_field . alias == \"creation_date\" assert any ( x . name == \"creation_date\" for x in RedefinedField . Meta . table . columns ) assert isinstance ( RedefinedField . Meta . table . columns [ \"creation_date\" ] . type , sqlalchemy . sql . sqltypes . String , ) Warning If you declare UniqueColumns constraint with column names, the final model has to have a column with the same name declared. Otherwise, the ModelDefinitionError will be raised. So in example above if you do not provide name for created_date in RedefinedField model ormar will complain. created_date: str = ormar.String(max_length=200) # exception created_date: str = ormar.String(max_length=200, name=\"creation_date2\") # exception","title":"Redefining fields in subclasses"},{"location":"models/inheritance/#relations-in-inheritance","text":"You can declare relations in every step of inheritance, so both in parent and child classes. When you define a relation on a child model level it's either overwriting the relation defined in parent model (if the same field name is used), or is accessible only to this child if you define a new relation. When inheriting relations, you always need to be aware of related_name parameter, that has to be unique across a related model, when you define multiple child classes that inherit the same relation. If you do not provide related_name parameter ormar calculates it for you. This works with inheritance as all child models have to have different class names, which are used to calculate the default related_name (class.name.lower()+'s'). But, if you provide a related_name this name cannot be reused in all child models as they would overwrite each other on the related model side. Therefore, you have two options: redefine relation field in child models and manually provide different related_name parameters let this for ormar to handle -> auto adjusted related_name are: original related_name + \"_\" + child model table name That might sound complicated but let's look at the following example:","title":"Relations in inheritance"},{"location":"models/inheritance/#foreignkey-relations","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # normal model used in relation class Person ( ormar . Model ): class Meta : metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # parent model - needs to be abstract class Car ( ormar . Model ): class Meta : abstract = True metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 ) owner : Person = ormar . ForeignKey ( Person ) # note that we refer to the Person model again so we **have to** provide related_name co_owner : Person = ormar . ForeignKey ( Person , related_name = \"coowned\" ) created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) class Truck ( Car ): class Meta : pass max_capacity : int = ormar . Integer () class Bus ( Car ): class Meta : # default naming is name.lower()+'s' so it's ugly for buss ;) tablename = \"buses\" max_persons : int = ormar . Integer () Now when you will inspect the fields on Person model you will get: 1 2 3 4 5 6 7 8 9 Person . Meta . model_fields \"\"\" {'id': <class 'ormar.fields.model_fields.Integer'>, 'name': <class 'ormar.fields.model_fields.String'>, 'trucks': <class 'ormar.fields.foreign_key.ForeignKey'>, 'coowned_trucks': <class 'ormar.fields.foreign_key.ForeignKey'>, 'buss': <class 'ormar.fields.foreign_key.ForeignKey'>, 'coowned_buses': <class 'ormar.fields.foreign_key.ForeignKey'>} \"\"\" Note how you have trucks and buss fields that leads to Truck and Bus class that this Person owns. There were no related_name parameter so default names were used. At the same time the co-owned cars need to be referenced by coowned_trucks and coowned_buses . Ormar appended _trucks and _buses suffixes taken from child model table names. Seems fine, but the default name for owned trucks is ok ( trucks ) but the buss is ugly, so how can we change it? The solution is pretty simple - just redefine the field in Bus class and provide different related_name parameter. 1 2 3 4 5 6 7 8 # rest of the above example remains the same class Bus ( Car ): class Meta : tablename = \"buses\" # new field that changes the related_name owner : Person = ormar . ForeignKey ( Person , related_name = \"buses\" ) max_persons : int = ormar . Integer () Now the columns looks much better. 1 2 3 4 5 6 7 8 9 Person . Meta . model_fields \"\"\" {'id': <class 'ormar.fields.model_fields.Integer'>, 'name': <class 'ormar.fields.model_fields.String'>, 'trucks': <class 'ormar.fields.foreign_key.ForeignKey'>, 'coowned_trucks': <class 'ormar.fields.foreign_key.ForeignKey'>, 'buses': <class 'ormar.fields.foreign_key.ForeignKey'>, 'coowned_buses': <class 'ormar.fields.foreign_key.ForeignKey'>} \"\"\" Note You could also provide related_name for the owner field, that way the proper suffixes would be added. owner: Person = ormar.ForeignKey(Person, related_name=\"owned\") and model fields for Person owned cars would become owned_trucks and owned_buses .","title":"ForeignKey relations"},{"location":"models/inheritance/#manytomany-relations","text":"Similarly, you can inherit from Models that have ManyToMany relations declared but there is one, but substantial difference - the Through model. Since in the future the Through model will be able to hold additional fields and now it links only two Tables ( from and to ones), each child that inherits the m2m relation field has to have separate Through model. Of course, you can overwrite the relation in each Child model, but that requires additional code and undermines the point of the whole inheritance. Ormar will handle this for you if you agree with default naming convention, which you can always manually overwrite in children if needed. Again, let's look at the example to easier grasp the concepts. We will modify the previous example described above to use m2m relation for co_owners. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 # person remain the same as above class Person ( ormar . Model ): class Meta : metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # new through model between Person and Car2 class PersonsCar ( ormar . Model ): class Meta : tablename = \"cars_x_persons\" metadata = metadata database = db # note how co_owners is now ManyToMany relation class Car2 ( ormar . Model ): class Meta : # parent class needs to be marked abstract abstract = True metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 ) # note the related_name - needs to be unique across Person # model, regardless of how many different models leads to Person owner : Person = ormar . ForeignKey ( Person , related_name = \"owned\" ) co_owners : List [ Person ] = ormar . ManyToMany ( Person , through = PersonsCar , related_name = \"coowned\" ) created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) # child models define only additional Fields class Truck2 ( Car2 ): class Meta : # note how you don't have to provide inherited Meta params tablename = \"trucks2\" max_capacity : int = ormar . Integer () class Bus2 ( Car2 ): class Meta : tablename = \"buses2\" max_persons : int = ormar . Integer () Ormar automatically modifies related_name of the fields to include the table name of the children models. The dafault name is original related_name + '_' + child table name. That way for class Truck2 the relation defined in owner: Person = ormar.ForeignKey(Person, related_name=\"owned\") becomes owned_trucks2 You can verify the names by inspecting the list of fields present on Person model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Person . Meta . model_fields { # note how all relation fields need to be unique on Person # regardless if autogenerated or manually overwritten 'id' : < class ' ormar . fields . model_fields . Integer '>, 'name' : < class ' ormar . fields . model_fields . String '>, # note that we expanded on previous example so all 'old' fields are here 'trucks' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'coowned_trucks' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'buses' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'coowned_buses' : < class ' ormar . fields . foreign_key . ForeignKey '>, # newly defined related fields 'owned_trucks2' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'coowned_trucks2' : < class ' abc . ManyToMany '>, 'owned_buses2' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'coowned_buses2' : < class ' abc . ManyToMany '> } But that's not all. It's kind of internal to ormar but affects the data structure in the database, so let's examine the through models for both Bus2 and Truck2 models. 1 2 3 4 5 6 7 8 9 Bus2 . Meta . model_fields [ 'co_owners' ] . through < class ' abc . PersonsCarBus2 '> Bus2 . Meta . model_fields [ 'co_owners' ] . through . Meta . tablename 'cars_x_persons_buses2' Truck2 . Meta . model_fields [ 'co_owners' ] . through < class ' abc . PersonsCarTruck2 '> Truck2 . Meta . model_fields [ 'co_owners' ] . through . Meta . tablename 'cars_x_persons_trucks2' As you can see above ormar cloned the Through model for each of the Child classes and added Child class name at the end, while changing the table names of the cloned fields the name of the table from the child is used. Note that original model is not only not used, the table for this model is removed from metadata: 1 2 3 Bus2 . Meta . metadata . tables . keys () dict_keys ([ 'test_date_models' , 'categories' , 'subjects' , 'persons' , 'trucks' , 'buses' , 'cars_x_persons_trucks2' , 'trucks2' , 'cars_x_persons_buses2' , 'buses2' ]) So be aware that if you introduce inheritance along the way and convert a model into abstract parent model you may lose your data on through table if not careful. Note Note that original table name and model name of the Through model is never used. Only the cloned models tables are created and used. Warning Note that each subclass of the Model that has ManyToMany relation defined generates a new Through model, meaning also new database table . That means that each time you define a Child model you need to either manually create the table in the database, or run a migration (with alembic).","title":"ManyToMany relations"},{"location":"models/internals/","text":"Internals Apart from special parameters defined in the Model during definition (tablename, metadata etc.) the Model provides you with useful internals. Pydantic Model All Model classes inherit from pydantic.BaseModel so you can access all normal attributes of pydantic models. For example to list pydantic model fields you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ( Course . __fields__ ) \"\"\" Will produce: {'id': ModelField(name='id', type=Optional[int], required=False, default=None), 'name': ModelField(name='name', type=Optional[str], required=False, default=None), 'completed': ModelField(name='completed', type=bool, required=False, default=False)} \"\"\" Tip Note how the primary key id field is optional as Integer primary key by default has autoincrement set to True . Info For more options visit official pydantic documentation. Sqlalchemy Table To access auto created sqlalchemy table you can use Model.Meta.table parameter For example to list table columns you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta ( ormar . ModelMeta ): # note you don't have to subclass - but it's recommended for ide completion and mypy database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ( Course . Meta . table . columns ) \"\"\" Will produce: ['courses.id', 'courses.name', 'courses.completed'] \"\"\" Tip You can access table primary key name by Course.Meta.pkname Info For more options visit official sqlalchemy-metadata documentation. Fields Definition To access ormar Fields you can use Model.Meta.model_fields parameter For example to list table model fields you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta ( ormar . ModelMeta ): database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ({ x : v . __dict__ for x , v in Course . Meta . model_fields . items ()}) \"\"\" Will produce: {'completed': mappingproxy({'autoincrement': False, 'choices': set(), 'column_type': Boolean(), 'default': False, 'index': False, 'name': 'completed', 'nullable': True, 'primary_key': False, 'pydantic_only': False, 'server_default': None, 'unique': False}), 'id': mappingproxy({'autoincrement': True, 'choices': set(), 'column_type': Integer(), 'default': None, 'ge': None, 'index': False, 'le': None, 'maximum': None, 'minimum': None, 'multiple_of': None, 'name': 'id', 'nullable': False, 'primary_key': True, 'pydantic_only': False, 'server_default': None, 'unique': False}), 'name': mappingproxy({'allow_blank': False, 'autoincrement': False, 'choices': set(), 'column_type': String(max_length=100), 'curtail_length': None, 'default': None, 'index': False, 'max_length': 100, 'min_length': None, 'name': 'name', 'nullable': False, 'primary_key': False, 'pydantic_only': False, 'regex': None, 'server_default': None, 'strip_whitespace': False, 'unique': False})} \"\"\" Info Note that fields stored on a model are classes not instances . So if you print just model fields you will get: {'id': <class 'ormar.fields.model_fields.Integer'>, 'name': <class 'ormar.fields.model_fields.String'>, 'completed': <class 'ormar.fields.model_fields.Boolean'>}","title":"Internals"},{"location":"models/internals/#internals","text":"Apart from special parameters defined in the Model during definition (tablename, metadata etc.) the Model provides you with useful internals.","title":"Internals"},{"location":"models/internals/#pydantic-model","text":"All Model classes inherit from pydantic.BaseModel so you can access all normal attributes of pydantic models. For example to list pydantic model fields you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ( Course . __fields__ ) \"\"\" Will produce: {'id': ModelField(name='id', type=Optional[int], required=False, default=None), 'name': ModelField(name='name', type=Optional[str], required=False, default=None), 'completed': ModelField(name='completed', type=bool, required=False, default=False)} \"\"\" Tip Note how the primary key id field is optional as Integer primary key by default has autoincrement set to True . Info For more options visit official pydantic documentation.","title":"Pydantic Model"},{"location":"models/internals/#sqlalchemy-table","text":"To access auto created sqlalchemy table you can use Model.Meta.table parameter For example to list table columns you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta ( ormar . ModelMeta ): # note you don't have to subclass - but it's recommended for ide completion and mypy database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ( Course . Meta . table . columns ) \"\"\" Will produce: ['courses.id', 'courses.name', 'courses.completed'] \"\"\" Tip You can access table primary key name by Course.Meta.pkname Info For more options visit official sqlalchemy-metadata documentation.","title":"Sqlalchemy Table"},{"location":"models/internals/#fields-definition","text":"To access ormar Fields you can use Model.Meta.model_fields parameter For example to list table model fields you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta ( ormar . ModelMeta ): database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ({ x : v . __dict__ for x , v in Course . Meta . model_fields . items ()}) \"\"\" Will produce: {'completed': mappingproxy({'autoincrement': False, 'choices': set(), 'column_type': Boolean(), 'default': False, 'index': False, 'name': 'completed', 'nullable': True, 'primary_key': False, 'pydantic_only': False, 'server_default': None, 'unique': False}), 'id': mappingproxy({'autoincrement': True, 'choices': set(), 'column_type': Integer(), 'default': None, 'ge': None, 'index': False, 'le': None, 'maximum': None, 'minimum': None, 'multiple_of': None, 'name': 'id', 'nullable': False, 'primary_key': True, 'pydantic_only': False, 'server_default': None, 'unique': False}), 'name': mappingproxy({'allow_blank': False, 'autoincrement': False, 'choices': set(), 'column_type': String(max_length=100), 'curtail_length': None, 'default': None, 'index': False, 'max_length': 100, 'min_length': None, 'name': 'name', 'nullable': False, 'primary_key': False, 'pydantic_only': False, 'regex': None, 'server_default': None, 'strip_whitespace': False, 'unique': False})} \"\"\" Info Note that fields stored on a model are classes not instances . So if you print just model fields you will get: {'id': <class 'ormar.fields.model_fields.Integer'>, 'name': <class 'ormar.fields.model_fields.String'>, 'completed': <class 'ormar.fields.model_fields.Boolean'>}","title":"Fields Definition"},{"location":"models/methods/","text":"Model methods Tip Main interaction with the databases is exposed through a QuerySet object exposed on each model as Model.objects similar to the django orm. To read more about quering, joining tables, excluding fields etc. visit queries section. Each model instance have a set of methods to save , update or load itself. Available methods are described below. load By default when you query a table without prefetching related models, the ormar will still construct your related models, but populate them only with the pk value. You can load the related model by calling load() method. load() can also be used to refresh the model from the database (if it was changed by some other process). 1 2 3 4 5 6 7 track = await Track . objects . get ( name = 'The Bird' ) track . album . pk # will return malibu album pk (1) track . album . name # will return None # you need to actually load the data first await track . album . load () track . album . name # will return 'Malibu' save save() -> self You can create new models by using QuerySet.create() method or by initializing your model as a normal pydantic model and later calling save() method. save() can also be used to persist changes that you made to the model, but only if the primary key is not set or the model does not exist in database. The save() method does not check if the model exists in db, so if it does you will get a integrity error from your selected db backend if trying to save model with already existing primary key. 1 2 3 4 5 track = Track ( name = 'The Bird' ) await track . save () # will persist the model in database track = await Track . objects . get ( name = 'The Bird' ) await track . save () # will raise integrity error as pk is populated update update(**kwargs) -> self You can update models by using QuerySet.update() method or by updating your model attributes (fields) and calling update() method. If you try to update a model without a primary key set a ModelPersistenceError exception will be thrown. To persist a newly created model use save() or upsert(**kwargs) methods. 1 2 track = await Track . objects . get ( name = 'The Bird' ) await track . update ( name = 'The Bird Strikes Again' ) upsert upsert(**kwargs) -> self It's a proxy to either save() or update(**kwargs) methods described above. If the primary key is set -> the update method will be called. If the pk is not set the save() method will be called. 1 2 3 4 5 track = Track ( name = 'The Bird' ) await track . upsert () # will call save as the pk is empty track = await Track . objects . get ( name = 'The Bird' ) await track . upsert ( name = 'The Bird Strikes Again' ) # will call update as pk is already populated delete You can delete models by using QuerySet.delete() method or by using your model and calling delete() method. 1 2 track = await Track . objects . get ( name = 'The Bird' ) await track . delete () # will delete the model from database Tip Note that that track object stays the same, only record in the database is removed. save_related save_related(follow: bool = False) -> None Method goes through all relations of the Model on which the method is called, and calls upsert() method on each model that is not saved. To understand when a model is saved check save status section above. By default the save_related method saved only models that are directly related (one step away) to the model on which the method is called. But you can specify the follow=True parameter to traverse through nested models and save all of them in the relation tree. Warning To avoid circular updates with follow=True set, save_related keeps a set of already visited Models, and won't perform nested save_related on Models that were already visited. So if you have a diamond or circular relations types you need to perform the updates in a manual way. 1 2 # in example like this the second Street (coming from City) won't be save_related, so ZipCode won't be updated Street -> District -> City -> Street -> ZipCode","title":"Methods"},{"location":"models/methods/#model-methods","text":"Tip Main interaction with the databases is exposed through a QuerySet object exposed on each model as Model.objects similar to the django orm. To read more about quering, joining tables, excluding fields etc. visit queries section. Each model instance have a set of methods to save , update or load itself. Available methods are described below.","title":"Model methods"},{"location":"models/methods/#load","text":"By default when you query a table without prefetching related models, the ormar will still construct your related models, but populate them only with the pk value. You can load the related model by calling load() method. load() can also be used to refresh the model from the database (if it was changed by some other process). 1 2 3 4 5 6 7 track = await Track . objects . get ( name = 'The Bird' ) track . album . pk # will return malibu album pk (1) track . album . name # will return None # you need to actually load the data first await track . album . load () track . album . name # will return 'Malibu'","title":"load"},{"location":"models/methods/#save","text":"save() -> self You can create new models by using QuerySet.create() method or by initializing your model as a normal pydantic model and later calling save() method. save() can also be used to persist changes that you made to the model, but only if the primary key is not set or the model does not exist in database. The save() method does not check if the model exists in db, so if it does you will get a integrity error from your selected db backend if trying to save model with already existing primary key. 1 2 3 4 5 track = Track ( name = 'The Bird' ) await track . save () # will persist the model in database track = await Track . objects . get ( name = 'The Bird' ) await track . save () # will raise integrity error as pk is populated","title":"save"},{"location":"models/methods/#update","text":"update(**kwargs) -> self You can update models by using QuerySet.update() method or by updating your model attributes (fields) and calling update() method. If you try to update a model without a primary key set a ModelPersistenceError exception will be thrown. To persist a newly created model use save() or upsert(**kwargs) methods. 1 2 track = await Track . objects . get ( name = 'The Bird' ) await track . update ( name = 'The Bird Strikes Again' )","title":"update"},{"location":"models/methods/#upsert","text":"upsert(**kwargs) -> self It's a proxy to either save() or update(**kwargs) methods described above. If the primary key is set -> the update method will be called. If the pk is not set the save() method will be called. 1 2 3 4 5 track = Track ( name = 'The Bird' ) await track . upsert () # will call save as the pk is empty track = await Track . objects . get ( name = 'The Bird' ) await track . upsert ( name = 'The Bird Strikes Again' ) # will call update as pk is already populated","title":"upsert"},{"location":"models/methods/#delete","text":"You can delete models by using QuerySet.delete() method or by using your model and calling delete() method. 1 2 track = await Track . objects . get ( name = 'The Bird' ) await track . delete () # will delete the model from database Tip Note that that track object stays the same, only record in the database is removed.","title":"delete"},{"location":"models/methods/#save_related","text":"save_related(follow: bool = False) -> None Method goes through all relations of the Model on which the method is called, and calls upsert() method on each model that is not saved. To understand when a model is saved check save status section above. By default the save_related method saved only models that are directly related (one step away) to the model on which the method is called. But you can specify the follow=True parameter to traverse through nested models and save all of them in the relation tree. Warning To avoid circular updates with follow=True set, save_related keeps a set of already visited Models, and won't perform nested save_related on Models that were already visited. So if you have a diamond or circular relations types you need to perform the updates in a manual way. 1 2 # in example like this the second Street (coming from City) won't be save_related, so ZipCode won't be updated Street -> District -> City -> Street -> ZipCode","title":"save_related"},{"location":"models/migrations/","text":"Migrations Database Initialization Note that all examples assume that you already have a database. If that is not the case and you need to create your tables, that's super easy as ormar is using sqlalchemy for underlying table construction. All you have to do is call create_all() like in the example below. 1 2 3 4 5 import sqlalchemy # get your database url in sqlalchemy format - same as used with databases instance used in Model definition engine = sqlalchemy . create_engine ( \"sqlite:///test.db\" ) # note that this has to be the same metadata that is used in ormar Models definition metadata . create_all ( engine ) You can also create single tables, sqlalchemy tables are exposed in ormar.Meta class. 1 2 3 4 5 import sqlalchemy # get your database url in sqlalchemy format - same as used with databases instance used in Model definition engine = sqlalchemy . create_engine ( \"sqlite:///test.db\" ) # Artist is an ormar model from previous examples Artist . Meta . table . create ( engine ) Warning You need to create the tables only once, so use a python console for that or remove the script from your production code after first use. Alembic usage Likewise as with tables, since we base tables on sqlalchemy for migrations please use alembic . Initialization Use command line to reproduce this minimalistic example. 1 2 3 alembic init alembic alembic revision -- autogenerate - m \"made some changes\" alembic upgrade head Sample env.py file A quick example of alembic migrations should be something similar to: When you have application structure like: 1 2 3 4 5 -> app -> alembic (initialized folder - so run alembic init alembic inside app folder) -> models (here are the models) -> __init__.py -> my_models.py Your env.py file (in alembic folder) can look something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 from logging.config import fileConfig from sqlalchemy import create_engine from alembic import context import sys , os # add app folder to system path (alternative is running it from parent folder with python -m ...) myPath = os . path . dirname ( os . path . abspath ( __file__ )) sys . path . insert ( 0 , myPath + '/../../' ) # this is the Alembic Config object, which provides # access to the values within the .ini file in use. config = context . config # Interpret the config file for Python logging. # This line sets up loggers basically. fileConfig ( config . config_file_name ) # add your model's MetaData object here (the one used in ormar) # for 'autogenerate' support from app.models.my_models import metadata target_metadata = metadata # set your url here or import from settings # note that by default url is in saved sqlachemy.url variable in alembic.ini file URL = \"sqlite:///test.db\" def run_migrations_offline (): \"\"\"Run migrations in 'offline' mode. This configures the context with just a URL and not an Engine, though an Engine is acceptable here as well. By skipping the Engine creation we don't even need a DBAPI to be available. Calls to context.execute() here emit the given string to the script output. \"\"\" context . configure ( url = URL , target_metadata = target_metadata , literal_binds = True , dialect_opts = { \"paramstyle\" : \"named\" }, # if you use UUID field set also this param # the prefix has to match sqlalchemy import name in alembic # that can be set by sqlalchemy_module_prefix option (default 'sa.') user_module_prefix = 'sa.' ) with context . begin_transaction (): context . run_migrations () def run_migrations_online (): \"\"\"Run migrations in 'online' mode. In this scenario we need to create an Engine and associate a connection with the context. \"\"\" connectable = create_engine ( URL ) with connectable . connect () as connection : context . configure ( connection = connection , target_metadata = target_metadata , # if you use UUID field set also this param # the prefix has to match sqlalchemy import name in alembic # that can be set by sqlalchemy_module_prefix option (default 'sa.') user_module_prefix = 'sa.' ) with context . begin_transaction (): context . run_migrations () if context . is_offline_mode (): run_migrations_offline () else : run_migrations_online () Excluding tables You can also include/exclude specific tables with include_object parameter passed to context.configure . That should be a function returning True/False for given objects. A sample function excluding tables starting with data_ in name unless it's 'data_jobs': 1 2 3 4 5 def include_object ( object , name , type_ , reflected , compare_to ): if name and name . startswith ( 'data_' ) and name not in [ 'data_jobs' ]: return False return True Note Function parameters for include_objects (you can change the name) are required and defined in alembic to check what they do check the alembic documentation And you pass it into context like (both in online and offline): 1 2 3 4 5 6 7 8 context . configure ( url = URL , target_metadata = target_metadata , literal_binds = True , dialect_opts = { \"paramstyle\" : \"named\" }, user_module_prefix = 'sa.' , include_object = include_object ) Info You can read more about table creation, altering and migrations in sqlalchemy table creation documentation.","title":"Migrations"},{"location":"models/migrations/#migrations","text":"","title":"Migrations"},{"location":"models/migrations/#database-initialization","text":"Note that all examples assume that you already have a database. If that is not the case and you need to create your tables, that's super easy as ormar is using sqlalchemy for underlying table construction. All you have to do is call create_all() like in the example below. 1 2 3 4 5 import sqlalchemy # get your database url in sqlalchemy format - same as used with databases instance used in Model definition engine = sqlalchemy . create_engine ( \"sqlite:///test.db\" ) # note that this has to be the same metadata that is used in ormar Models definition metadata . create_all ( engine ) You can also create single tables, sqlalchemy tables are exposed in ormar.Meta class. 1 2 3 4 5 import sqlalchemy # get your database url in sqlalchemy format - same as used with databases instance used in Model definition engine = sqlalchemy . create_engine ( \"sqlite:///test.db\" ) # Artist is an ormar model from previous examples Artist . Meta . table . create ( engine ) Warning You need to create the tables only once, so use a python console for that or remove the script from your production code after first use.","title":"Database Initialization"},{"location":"models/migrations/#alembic-usage","text":"Likewise as with tables, since we base tables on sqlalchemy for migrations please use alembic .","title":"Alembic usage"},{"location":"models/migrations/#initialization","text":"Use command line to reproduce this minimalistic example. 1 2 3 alembic init alembic alembic revision -- autogenerate - m \"made some changes\" alembic upgrade head","title":"Initialization"},{"location":"models/migrations/#sample-envpy-file","text":"A quick example of alembic migrations should be something similar to: When you have application structure like: 1 2 3 4 5 -> app -> alembic (initialized folder - so run alembic init alembic inside app folder) -> models (here are the models) -> __init__.py -> my_models.py Your env.py file (in alembic folder) can look something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 from logging.config import fileConfig from sqlalchemy import create_engine from alembic import context import sys , os # add app folder to system path (alternative is running it from parent folder with python -m ...) myPath = os . path . dirname ( os . path . abspath ( __file__ )) sys . path . insert ( 0 , myPath + '/../../' ) # this is the Alembic Config object, which provides # access to the values within the .ini file in use. config = context . config # Interpret the config file for Python logging. # This line sets up loggers basically. fileConfig ( config . config_file_name ) # add your model's MetaData object here (the one used in ormar) # for 'autogenerate' support from app.models.my_models import metadata target_metadata = metadata # set your url here or import from settings # note that by default url is in saved sqlachemy.url variable in alembic.ini file URL = \"sqlite:///test.db\" def run_migrations_offline (): \"\"\"Run migrations in 'offline' mode. This configures the context with just a URL and not an Engine, though an Engine is acceptable here as well. By skipping the Engine creation we don't even need a DBAPI to be available. Calls to context.execute() here emit the given string to the script output. \"\"\" context . configure ( url = URL , target_metadata = target_metadata , literal_binds = True , dialect_opts = { \"paramstyle\" : \"named\" }, # if you use UUID field set also this param # the prefix has to match sqlalchemy import name in alembic # that can be set by sqlalchemy_module_prefix option (default 'sa.') user_module_prefix = 'sa.' ) with context . begin_transaction (): context . run_migrations () def run_migrations_online (): \"\"\"Run migrations in 'online' mode. In this scenario we need to create an Engine and associate a connection with the context. \"\"\" connectable = create_engine ( URL ) with connectable . connect () as connection : context . configure ( connection = connection , target_metadata = target_metadata , # if you use UUID field set also this param # the prefix has to match sqlalchemy import name in alembic # that can be set by sqlalchemy_module_prefix option (default 'sa.') user_module_prefix = 'sa.' ) with context . begin_transaction (): context . run_migrations () if context . is_offline_mode (): run_migrations_offline () else : run_migrations_online ()","title":"Sample env.py file"},{"location":"models/migrations/#excluding-tables","text":"You can also include/exclude specific tables with include_object parameter passed to context.configure . That should be a function returning True/False for given objects. A sample function excluding tables starting with data_ in name unless it's 'data_jobs': 1 2 3 4 5 def include_object ( object , name , type_ , reflected , compare_to ): if name and name . startswith ( 'data_' ) and name not in [ 'data_jobs' ]: return False return True Note Function parameters for include_objects (you can change the name) are required and defined in alembic to check what they do check the alembic documentation And you pass it into context like (both in online and offline): 1 2 3 4 5 6 7 8 context . configure ( url = URL , target_metadata = target_metadata , literal_binds = True , dialect_opts = { \"paramstyle\" : \"named\" }, user_module_prefix = 'sa.' , include_object = include_object ) Info You can read more about table creation, altering and migrations in sqlalchemy table creation documentation.","title":"Excluding tables"},{"location":"queries/","text":"Querying database with ormar QuerySet Each Model is auto registered with a QuerySet that represents the underlying query, and it's options. Most of the methods are also available through many to many relations and on reverse foreign key relations through QuerysetProxy interface. Info To see which relations are supported and how to construct relations visit relations . For simplicity available methods to fetch and save the data into the database are divided into categories according to the function they fulfill. Note that some functions/methods are in multiple categories. For complicity also Models and relations methods are listed. To read more about any specific section or function please refer to the details subpage. Insert data into database create(**kwargs) -> Model get_or_create(**kwargs) -> Model update_or_create(**kwargs) -> Model bulk_create(objects: List[Model]) -> None Model Model.save() method Model.upsert() method Model.save_related() method QuerysetProxy QuerysetProxy.create(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.update_or_create(**kwargs) method Read data from database get(**kwargs) -> Model get_or_create(**kwargs) -> Model first() -> Model all(**kwargs) -> List[Optional[Model]] Model Model.load() method QuerysetProxy QuerysetProxy.get(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.first() method QuerysetProxy.all(**kwargs) method Update data in database update(each: bool = False, **kwargs) -> int update_or_create(**kwargs) -> Model bulk_update(objects: List[Model], columns: List[str] = None) -> None Model Model.update() method Model.upsert() method Model.save_related() method QuerysetProxy QuerysetProxy.update_or_create(**kwargs) method Delete data from database delete(each: bool = False, **kwargs) -> int Model Model.delete() method QuerysetProxy QuerysetProxy.remove() method QuerysetProxy.clear() method Joins and subqueries select_related(related: Union[List, str]) -> QuerySet prefetch_related(related: Union[List, str]) -> QuerySet Model Model.load() method QuerysetProxy QuerysetProxy.select_related(related: Union[List, str]) method QuerysetProxy.prefetch_related(related: Union[List, str]) method Filtering and sorting filter(**kwargs) -> QuerySet exclude(**kwargs) -> QuerySet order_by(columns:Union[List, str]) -> QuerySet get(**kwargs) -> Model get_or_create(**kwargs) -> Model all(**kwargs) -> List[Optional[Model]] QuerysetProxy QuerysetProxy.filter(**kwargs) method QuerysetProxy.exclude(**kwargs) method QuerysetProxy.order_by(columns:Union[List, str]) method QuerysetProxy.get(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.all(**kwargs) method Selecting columns fields(columns: Union[List, str, set, dict]) -> QuerySet exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet QuerysetProxy QuerysetProxy.fields(columns: Union[List, str, set, dict]) method QuerysetProxy.exclude_fields(columns: Union[List, str, set, dict]) method Pagination and rows number paginate(page: int) -> QuerySet limit(limit_count: int) -> QuerySet offset(offset: int) -> QuerySet get() -> Model first() -> Model QuerysetProxy QuerysetProxy.paginate(page: int) method QuerysetProxy.limit(limit_count: int) method QuerysetProxy.offset(offset: int) method Aggregated functions count() -> int exists() -> bool QuerysetProxy QuerysetProxy.count() method QuerysetProxy.exists() method","title":"Querying database with ormar"},{"location":"queries/#querying-database-with-ormar","text":"","title":"Querying database with ormar"},{"location":"queries/#queryset","text":"Each Model is auto registered with a QuerySet that represents the underlying query, and it's options. Most of the methods are also available through many to many relations and on reverse foreign key relations through QuerysetProxy interface. Info To see which relations are supported and how to construct relations visit relations . For simplicity available methods to fetch and save the data into the database are divided into categories according to the function they fulfill. Note that some functions/methods are in multiple categories. For complicity also Models and relations methods are listed. To read more about any specific section or function please refer to the details subpage.","title":"QuerySet"},{"location":"queries/#insert-data-into-database","text":"create(**kwargs) -> Model get_or_create(**kwargs) -> Model update_or_create(**kwargs) -> Model bulk_create(objects: List[Model]) -> None Model Model.save() method Model.upsert() method Model.save_related() method QuerysetProxy QuerysetProxy.create(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.update_or_create(**kwargs) method","title":"Insert data into database"},{"location":"queries/#read-data-from-database","text":"get(**kwargs) -> Model get_or_create(**kwargs) -> Model first() -> Model all(**kwargs) -> List[Optional[Model]] Model Model.load() method QuerysetProxy QuerysetProxy.get(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.first() method QuerysetProxy.all(**kwargs) method","title":"Read data from database"},{"location":"queries/#update-data-in-database","text":"update(each: bool = False, **kwargs) -> int update_or_create(**kwargs) -> Model bulk_update(objects: List[Model], columns: List[str] = None) -> None Model Model.update() method Model.upsert() method Model.save_related() method QuerysetProxy QuerysetProxy.update_or_create(**kwargs) method","title":"Update data in database"},{"location":"queries/#delete-data-from-database","text":"delete(each: bool = False, **kwargs) -> int Model Model.delete() method QuerysetProxy QuerysetProxy.remove() method QuerysetProxy.clear() method","title":"Delete data from database"},{"location":"queries/#joins-and-subqueries","text":"select_related(related: Union[List, str]) -> QuerySet prefetch_related(related: Union[List, str]) -> QuerySet Model Model.load() method QuerysetProxy QuerysetProxy.select_related(related: Union[List, str]) method QuerysetProxy.prefetch_related(related: Union[List, str]) method","title":"Joins and subqueries"},{"location":"queries/#filtering-and-sorting","text":"filter(**kwargs) -> QuerySet exclude(**kwargs) -> QuerySet order_by(columns:Union[List, str]) -> QuerySet get(**kwargs) -> Model get_or_create(**kwargs) -> Model all(**kwargs) -> List[Optional[Model]] QuerysetProxy QuerysetProxy.filter(**kwargs) method QuerysetProxy.exclude(**kwargs) method QuerysetProxy.order_by(columns:Union[List, str]) method QuerysetProxy.get(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.all(**kwargs) method","title":"Filtering and sorting"},{"location":"queries/#selecting-columns","text":"fields(columns: Union[List, str, set, dict]) -> QuerySet exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet QuerysetProxy QuerysetProxy.fields(columns: Union[List, str, set, dict]) method QuerysetProxy.exclude_fields(columns: Union[List, str, set, dict]) method","title":"Selecting columns"},{"location":"queries/#pagination-and-rows-number","text":"paginate(page: int) -> QuerySet limit(limit_count: int) -> QuerySet offset(offset: int) -> QuerySet get() -> Model first() -> Model QuerysetProxy QuerysetProxy.paginate(page: int) method QuerysetProxy.limit(limit_count: int) method QuerysetProxy.offset(offset: int) method","title":"Pagination and rows number"},{"location":"queries/#aggregated-functions","text":"count() -> int exists() -> bool QuerysetProxy QuerysetProxy.count() method QuerysetProxy.exists() method","title":"Aggregated functions"},{"location":"queries/aggregations/","text":"Aggregation functions Currently 2 aggregation functions are supported. count() -> int exists() -> bool QuerysetProxy QuerysetProxy.count() method QuerysetProxy.exists() method count count() -> int Returns number of rows matching the given criteria (i.e. applied with filter and exclude ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = \"Fiction\" , choices = [ \"Fiction\" , \"Adventure\" , \"Historic\" , \"Fantasy\" ], ) 1 2 # returns count of rows in db for Books model no_of_books = await Book . objects . count () exists exists() -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = \"Fiction\" , choices = [ \"Fiction\" , \"Adventure\" , \"Historic\" , \"Fantasy\" ], ) 1 2 # returns a boolean value if given row exists has_sample = await Book . objects . filter ( title = 'Sample' ) . exists () QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes a subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. count Works exactly the same as count function above but allows you to select columns from related objects from other side of the relation. Tip To read more about QuerysetProxy visit [querysetproxy][querysetproxy] section exists Works exactly the same as exists function above but allows you to select columns from related objects from other side of the relation. Tip To read more about QuerysetProxy visit [querysetproxy][querysetproxy] section","title":"Aggregation functions"},{"location":"queries/aggregations/#aggregation-functions","text":"Currently 2 aggregation functions are supported. count() -> int exists() -> bool QuerysetProxy QuerysetProxy.count() method QuerysetProxy.exists() method","title":"Aggregation functions"},{"location":"queries/aggregations/#count","text":"count() -> int Returns number of rows matching the given criteria (i.e. applied with filter and exclude ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = \"Fiction\" , choices = [ \"Fiction\" , \"Adventure\" , \"Historic\" , \"Fantasy\" ], ) 1 2 # returns count of rows in db for Books model no_of_books = await Book . objects . count ()","title":"count"},{"location":"queries/aggregations/#exists","text":"exists() -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = \"Fiction\" , choices = [ \"Fiction\" , \"Adventure\" , \"Historic\" , \"Fantasy\" ], ) 1 2 # returns a boolean value if given row exists has_sample = await Book . objects . filter ( title = 'Sample' ) . exists ()","title":"exists"},{"location":"queries/aggregations/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes a subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/aggregations/#count_1","text":"Works exactly the same as count function above but allows you to select columns from related objects from other side of the relation. Tip To read more about QuerysetProxy visit [querysetproxy][querysetproxy] section","title":"count"},{"location":"queries/aggregations/#exists_1","text":"Works exactly the same as exists function above but allows you to select columns from related objects from other side of the relation. Tip To read more about QuerysetProxy visit [querysetproxy][querysetproxy] section","title":"exists"},{"location":"queries/create/","text":"Insert data into database Following methods allow you to insert data into the database. create(**kwargs) -> Model get_or_create(**kwargs) -> Model update_or_create(**kwargs) -> Model bulk_create(objects: List[Model]) -> None Model Model.save() method Model.upsert() method Model.save_related() method QuerysetProxy QuerysetProxy.create(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.update_or_create(**kwargs) method create create(**kwargs): -> Model Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set). The allowed kwargs are Model fields names and proper value types. 1 2 3 4 5 6 7 8 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) 1 2 malibu = await Album . objects . create ( name = \"Malibu\" ) await Track . objects . create ( album = malibu , title = \"The Bird\" , position = 1 ) The alternative is a split creation and persistence of the Model . 1 2 malibu = Album ( name = \"Malibu\" ) await malibu . save () Tip Check other Model methods in models get_or_create get_or_create(**kwargs) -> Model Combination of create and get methods. Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. 1 2 3 4 5 6 7 8 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) 1 2 3 4 5 album = await Album . objects . get_or_create ( name = 'The Cat' ) # object is created as it does not exist album2 = await Album . objects . get_or_create ( name = 'The Cat' ) assert album == album2 # return True as the same db row is returned Warning Despite being a equivalent row from database the album and album2 in example above are 2 different python objects! Updating one of them will not refresh the second one until you excplicitly load() the fresh data from db. Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement update_or_create update_or_create(**kwargs) -> Model Updates the model, or in case there is no match in database creates a new one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) # if not exist the instance will be persisted in db vol2 = await Book . objects . update_or_create ( title = \"Volume II\" , author = 'Anonymous' , genre = 'Fiction' ) assert await Book . objects . count () == 1 # if pk or pkname passed in kwargs (like id here) the object will be updated assert await Book . objects . update_or_create ( id = vol2 . id , genre = 'Historic' ) assert await Book . objects . count () == 1 Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement bulk_create bulk_create(objects: List[\"Model\"]) -> None Allows you to create multiple objects at once. A valid list of Model objects needs to be passed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class ToDo ( ormar . Model ): class Meta : tablename = \"todos\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) text : str = ormar . String ( max_length = 500 ) completed = ormar . Boolean ( default = False ) # create multiple instances at once with bulk_create await ToDo . objects . bulk_create ( [ ToDo ( text = \"Buy the groceries.\" ), ToDo ( text = \"Call Mum.\" , completed = True ), ToDo ( text = \"Send invoices.\" , completed = True ), ] ) todoes = await ToDo . objects . all () assert len ( todoes ) == 3 Model methods Each model instance have a set of methods to save , update or load itself. save You can create new models by using QuerySet.create() method or by initializing your model as a normal pydantic model and later calling save() method. Tip Read more about save() method in models-save upsert It's a proxy to either save() or update(**kwargs) methods of a Model. If the pk is not set the save() method will be called. Tip Read more about upsert() method in models-upsert save_related Method goes through all relations of the Model on which the method is called, and calls upsert() method on each model that is not saved. Tip Read more about save_related() method in models-save-related QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. create Works exactly the same as create function above but allows you to create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section get_or_create Works exactly the same as get_or_create function above but allows you to query or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section update_or_create Works exactly the same as update_or_create function above but allows you to update or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"Insert data into database"},{"location":"queries/create/#insert-data-into-database","text":"Following methods allow you to insert data into the database. create(**kwargs) -> Model get_or_create(**kwargs) -> Model update_or_create(**kwargs) -> Model bulk_create(objects: List[Model]) -> None Model Model.save() method Model.upsert() method Model.save_related() method QuerysetProxy QuerysetProxy.create(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.update_or_create(**kwargs) method","title":"Insert data into database"},{"location":"queries/create/#create","text":"create(**kwargs): -> Model Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set). The allowed kwargs are Model fields names and proper value types. 1 2 3 4 5 6 7 8 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) 1 2 malibu = await Album . objects . create ( name = \"Malibu\" ) await Track . objects . create ( album = malibu , title = \"The Bird\" , position = 1 ) The alternative is a split creation and persistence of the Model . 1 2 malibu = Album ( name = \"Malibu\" ) await malibu . save () Tip Check other Model methods in models","title":"create"},{"location":"queries/create/#get_or_create","text":"get_or_create(**kwargs) -> Model Combination of create and get methods. Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. 1 2 3 4 5 6 7 8 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) 1 2 3 4 5 album = await Album . objects . get_or_create ( name = 'The Cat' ) # object is created as it does not exist album2 = await Album . objects . get_or_create ( name = 'The Cat' ) assert album == album2 # return True as the same db row is returned Warning Despite being a equivalent row from database the album and album2 in example above are 2 different python objects! Updating one of them will not refresh the second one until you excplicitly load() the fresh data from db. Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement","title":"get_or_create"},{"location":"queries/create/#update_or_create","text":"update_or_create(**kwargs) -> Model Updates the model, or in case there is no match in database creates a new one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) # if not exist the instance will be persisted in db vol2 = await Book . objects . update_or_create ( title = \"Volume II\" , author = 'Anonymous' , genre = 'Fiction' ) assert await Book . objects . count () == 1 # if pk or pkname passed in kwargs (like id here) the object will be updated assert await Book . objects . update_or_create ( id = vol2 . id , genre = 'Historic' ) assert await Book . objects . count () == 1 Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement","title":"update_or_create"},{"location":"queries/create/#bulk_create","text":"bulk_create(objects: List[\"Model\"]) -> None Allows you to create multiple objects at once. A valid list of Model objects needs to be passed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class ToDo ( ormar . Model ): class Meta : tablename = \"todos\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) text : str = ormar . String ( max_length = 500 ) completed = ormar . Boolean ( default = False ) # create multiple instances at once with bulk_create await ToDo . objects . bulk_create ( [ ToDo ( text = \"Buy the groceries.\" ), ToDo ( text = \"Call Mum.\" , completed = True ), ToDo ( text = \"Send invoices.\" , completed = True ), ] ) todoes = await ToDo . objects . all () assert len ( todoes ) == 3","title":"bulk_create"},{"location":"queries/create/#model-methods","text":"Each model instance have a set of methods to save , update or load itself.","title":"Model methods"},{"location":"queries/create/#save","text":"You can create new models by using QuerySet.create() method or by initializing your model as a normal pydantic model and later calling save() method. Tip Read more about save() method in models-save","title":"save"},{"location":"queries/create/#upsert","text":"It's a proxy to either save() or update(**kwargs) methods of a Model. If the pk is not set the save() method will be called. Tip Read more about upsert() method in models-upsert","title":"upsert"},{"location":"queries/create/#save_related","text":"Method goes through all relations of the Model on which the method is called, and calls upsert() method on each model that is not saved. Tip Read more about save_related() method in models-save-related","title":"save_related"},{"location":"queries/create/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/create/#create_1","text":"Works exactly the same as create function above but allows you to create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"create"},{"location":"queries/create/#get_or_create_1","text":"Works exactly the same as get_or_create function above but allows you to query or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"get_or_create"},{"location":"queries/create/#update_or_create_1","text":"Works exactly the same as update_or_create function above but allows you to update or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"update_or_create"},{"location":"queries/delete/","text":"Delete data from database Following methods allow you to delete data from the database. delete(each: bool = False, **kwargs) -> int Model Model.delete() method QuerysetProxy QuerysetProxy.remove() method QuerysetProxy.clear() method delete delete(each: bool = False, **kwargs) -> int QuerySet level delete is used to delete multiple records at once. You either have to filter the QuerySet first or provide a each=True flag to delete whole table. If you do not provide this flag or a filter a QueryDefinitionError will be raised. Return number of rows deleted. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace in Space' , author = \"Tolstoy, Leo\" , genre = 'Fantasy' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) # delete accepts kwargs that will be used in filter # acting in same way as queryset.filter(**kwargs).delete() await Book . objects . delete ( genre = 'Fantasy' ) # delete all fantasy books all_books = await Book . objects . all () assert len ( all_books ) == 2 Model methods Each model instance have a set of methods to save , update or load itself. delete You can delete model instance by calling delete() method on it. Tip Read more about delete() method in models methods QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. remove Removal of the related model one by one. Removes the relation in the database. If you specify the keep_reversed flag to False ormar will also delete the related model from the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 3 4 5 6 7 8 9 10 album = await Album ( name = \"Malibu\" ) . save () track1 = await Track ( album = album , title = \"The Bird\" , position = 1 , play_count = 30 , ) . save () # remove through proxy from reverse side of relation await album . tracks . remove ( track1 , keep_reversed = False ) # the track was also deleted tracks = await Track . objects . all () assert len ( tracks ) == 0 clear Removal of all related models in one call. Removes also the relation in the database. If you specify the keep_reversed flag to False ormar will also delete the related model from the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 album = await Album ( name = \"Malibu\" ) . save () track1 = await Track ( album = album , title = \"The Bird\" , position = 1 , play_count = 30 , ) . save () track2 = await Track ( album = album , title = \"Heart don't stand a chance\" , position = 2 , play_count = 20 , ) . save () # removes the relation only -> clears foreign keys on tracks await album . tracks . clear () # removes also the tracks await album . tracks . clear ( keep_reversed = False )","title":"Delete data from database"},{"location":"queries/delete/#delete-data-from-database","text":"Following methods allow you to delete data from the database. delete(each: bool = False, **kwargs) -> int Model Model.delete() method QuerysetProxy QuerysetProxy.remove() method QuerysetProxy.clear() method","title":"Delete data from database"},{"location":"queries/delete/#delete","text":"delete(each: bool = False, **kwargs) -> int QuerySet level delete is used to delete multiple records at once. You either have to filter the QuerySet first or provide a each=True flag to delete whole table. If you do not provide this flag or a filter a QueryDefinitionError will be raised. Return number of rows deleted. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace in Space' , author = \"Tolstoy, Leo\" , genre = 'Fantasy' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) # delete accepts kwargs that will be used in filter # acting in same way as queryset.filter(**kwargs).delete() await Book . objects . delete ( genre = 'Fantasy' ) # delete all fantasy books all_books = await Book . objects . all () assert len ( all_books ) == 2","title":"delete"},{"location":"queries/delete/#model-methods","text":"Each model instance have a set of methods to save , update or load itself.","title":"Model methods"},{"location":"queries/delete/#delete_1","text":"You can delete model instance by calling delete() method on it. Tip Read more about delete() method in models methods","title":"delete"},{"location":"queries/delete/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/delete/#remove","text":"Removal of the related model one by one. Removes the relation in the database. If you specify the keep_reversed flag to False ormar will also delete the related model from the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 3 4 5 6 7 8 9 10 album = await Album ( name = \"Malibu\" ) . save () track1 = await Track ( album = album , title = \"The Bird\" , position = 1 , play_count = 30 , ) . save () # remove through proxy from reverse side of relation await album . tracks . remove ( track1 , keep_reversed = False ) # the track was also deleted tracks = await Track . objects . all () assert len ( tracks ) == 0","title":"remove"},{"location":"queries/delete/#clear","text":"Removal of all related models in one call. Removes also the relation in the database. If you specify the keep_reversed flag to False ormar will also delete the related model from the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 album = await Album ( name = \"Malibu\" ) . save () track1 = await Track ( album = album , title = \"The Bird\" , position = 1 , play_count = 30 , ) . save () track2 = await Track ( album = album , title = \"Heart don't stand a chance\" , position = 2 , play_count = 20 , ) . save () # removes the relation only -> clears foreign keys on tracks await album . tracks . clear () # removes also the tracks await album . tracks . clear ( keep_reversed = False )","title":"clear"},{"location":"queries/filter-and-sort/","text":"Filtering and sorting data You can use following methods to filter the data (sql where clause). filter(**kwargs) -> QuerySet exclude(**kwargs) -> QuerySet get(**kwargs) -> Model get_or_create(**kwargs) -> Model all(**kwargs) -> List[Optional[Model]] QuerysetProxy QuerysetProxy.filter(**kwargs) method QuerysetProxy.exclude(**kwargs) method QuerysetProxy.get(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.all(**kwargs) method And following methods to sort the data (sql order by clause). order_by(columns:Union[List, str]) -> QuerySet QuerysetProxy QuerysetProxy.order_by(columns:Union[List, str]) method Filtering filter filter(**kwargs) -> QuerySet Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 3 4 5 track = Track . objects . filter ( name = \"The Bird\" ) . get () # will return a track with name equal to 'The Bird' tracks = Track . objects . filter ( album__name = \"Fantasies\" ) . all () # will return all tracks where the columns album name = 'Fantasies' You can use special filter suffix to change the filter operands: exact - like album__name__exact='Malibu' (exact match) iexact - like album__name__iexact='malibu' (exact match case insensitive) contains - like album__name__contains='Mal' (sql like) icontains - like album__name__icontains='mal' (sql like case insensitive) in - like album__name__in=['Malibu', 'Barclay'] (sql in) gt - like position__gt=3 (sql >) gte - like position__gte=3 (sql >=) lt - like position__lt=3 (sql <) lte - like position__lte=3 (sql <=) startswith - like album__name__startswith='Mal' (exact start match) istartswith - like album__name__istartswith='mal' (exact start match case insensitive) endswith - like album__name__endswith='ibu' (exact end match) iendswith - like album__name__iendswith='IBU' (exact end match case insensitive) Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() Warning Note that you do not have to specify the % wildcard in contains and other filters, it's added for you. If you include % in your search value it will be escaped and treated as literal percentage sign inside the text. exclude exclude(**kwargs) -> QuerySet Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. So if you use filter(name='John') which equals to where name = 'John' in SQL, the exclude(name='John') equals to where name <> 'John' Note that all conditions are joined so if you pass multiple values it becomes a union of conditions. exclude(name='John', age>=35) will become where not (name='John' and age>=35) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 notes = await Track . objects . exclude ( position_gt = 3 ) . all () # returns all tracks with position < 3 get get(**kwargs) -> Model Get's the first row from the db meeting the criteria set by kwargs. When any kwargs are passed it's a shortcut equivalent to calling filter(**kwargs).get() Tip To read more about filter go to filter . To read more about get go to read/get get_or_create get_or_create(**kwargs) -> Model Combination of create and get methods. When any kwargs are passed it's a shortcut equivalent to calling filter(**kwargs).get_or_create() Tip To read more about filter go to filter . To read more about get_or_create go to read/get_or_create Warning When given item does not exist you need to pass kwargs for all required fields of the model, including but not limited to primary_key column (unless it's autoincrement). all all(**kwargs) -> List[Optional[\"Model\"]] Returns all rows from a database for given model for set filter options. When any kwargs are passed it's a shortcut equivalent to calling filter(**kwargs).all() Tip To read more about filter go to filter . To read more about all go to read/all QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. filter Works exactly the same as filter function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section exclude Works exactly the same as exclude function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section get Works exactly the same as get function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section get_or_create Works exactly the same as get_or_create function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section all Works exactly the same as all function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section Sorting order_by order_by(columns: Union[List, str]) -> QuerySet With order_by() you can order the results from database based on your choice of fields. You can provide a string with field name or list of strings with different fields. Ordering in sql will be applied in order of names you provide in order_by. Tip By default if you do not provide ordering ormar explicitly orders by all primary keys Warning If you are sorting by nested models that causes that the result rows are unsorted by the main model ormar will combine those children rows into one main model. Sample raw database rows result (sort by child model desc): 1 2 3 MODEL: 1 - Child Model - 3 MODEL: 2 - Child Model - 2 MODEL: 1 - Child Model - 1 will result in 2 rows of result: 1 2 MODEL: 1 - Child Models: [3, 1] # encountered first in result, all children rows combined MODEL: 2 - Child Modles: [2] The main model will never duplicate in the result Given sample Models like following: 1 -- 8 < -- \"../../docs_src/queries/docs007.py\" To order by main model field just provide a field name 1 2 3 4 5 6 toys = await Toy . objects . select_related ( \"owner\" ) . order_by ( \"name\" ) . all () assert [ x . name . replace ( \"Toy \" , \"\" ) for x in toys ] == [ str ( x + 1 ) for x in range ( 6 ) ] assert toys [ 0 ] . owner == zeus assert toys [ 1 ] . owner == aphrodite To sort on nested models separate field names with dunder '__'. You can sort this way across all relation types -> ForeignKey , reverse virtual FK and ManyToMany fields. 1 2 3 4 toys = await Toy . objects . select_related ( \"owner\" ) . order_by ( \"owner__name\" ) . all () assert toys [ 0 ] . owner . name == toys [ 1 ] . owner . name == \"Aphrodite\" assert toys [ 2 ] . owner . name == toys [ 3 ] . owner . name == \"Hermes\" assert toys [ 4 ] . owner . name == toys [ 5 ] . owner . name == \"Zeus\" To sort in descending order provide a hyphen in front of the field name 1 2 3 4 5 6 7 8 owner = ( await Owner . objects . select_related ( \"toys\" ) . order_by ( \"-toys__name\" ) . filter ( name = \"Zeus\" ) . get () ) assert owner . toys [ 0 ] . name == \"Toy 4\" assert owner . toys [ 1 ] . name == \"Toy 1\" Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. order_by Works exactly the same as order_by function above but allows you to sort related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"Filtering and sorting data"},{"location":"queries/filter-and-sort/#filtering-and-sorting-data","text":"You can use following methods to filter the data (sql where clause). filter(**kwargs) -> QuerySet exclude(**kwargs) -> QuerySet get(**kwargs) -> Model get_or_create(**kwargs) -> Model all(**kwargs) -> List[Optional[Model]] QuerysetProxy QuerysetProxy.filter(**kwargs) method QuerysetProxy.exclude(**kwargs) method QuerysetProxy.get(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.all(**kwargs) method And following methods to sort the data (sql order by clause). order_by(columns:Union[List, str]) -> QuerySet QuerysetProxy QuerysetProxy.order_by(columns:Union[List, str]) method","title":"Filtering and sorting data"},{"location":"queries/filter-and-sort/#filtering","text":"","title":"Filtering"},{"location":"queries/filter-and-sort/#filter","text":"filter(**kwargs) -> QuerySet Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 3 4 5 track = Track . objects . filter ( name = \"The Bird\" ) . get () # will return a track with name equal to 'The Bird' tracks = Track . objects . filter ( album__name = \"Fantasies\" ) . all () # will return all tracks where the columns album name = 'Fantasies' You can use special filter suffix to change the filter operands: exact - like album__name__exact='Malibu' (exact match) iexact - like album__name__iexact='malibu' (exact match case insensitive) contains - like album__name__contains='Mal' (sql like) icontains - like album__name__icontains='mal' (sql like case insensitive) in - like album__name__in=['Malibu', 'Barclay'] (sql in) gt - like position__gt=3 (sql >) gte - like position__gte=3 (sql >=) lt - like position__lt=3 (sql <) lte - like position__lte=3 (sql <=) startswith - like album__name__startswith='Mal' (exact start match) istartswith - like album__name__istartswith='mal' (exact start match case insensitive) endswith - like album__name__endswith='ibu' (exact end match) iendswith - like album__name__iendswith='IBU' (exact end match case insensitive) Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() Warning Note that you do not have to specify the % wildcard in contains and other filters, it's added for you. If you include % in your search value it will be escaped and treated as literal percentage sign inside the text.","title":"filter"},{"location":"queries/filter-and-sort/#exclude","text":"exclude(**kwargs) -> QuerySet Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. So if you use filter(name='John') which equals to where name = 'John' in SQL, the exclude(name='John') equals to where name <> 'John' Note that all conditions are joined so if you pass multiple values it becomes a union of conditions. exclude(name='John', age>=35) will become where not (name='John' and age>=35) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 notes = await Track . objects . exclude ( position_gt = 3 ) . all () # returns all tracks with position < 3","title":"exclude"},{"location":"queries/filter-and-sort/#get","text":"get(**kwargs) -> Model Get's the first row from the db meeting the criteria set by kwargs. When any kwargs are passed it's a shortcut equivalent to calling filter(**kwargs).get() Tip To read more about filter go to filter . To read more about get go to read/get","title":"get"},{"location":"queries/filter-and-sort/#get_or_create","text":"get_or_create(**kwargs) -> Model Combination of create and get methods. When any kwargs are passed it's a shortcut equivalent to calling filter(**kwargs).get_or_create() Tip To read more about filter go to filter . To read more about get_or_create go to read/get_or_create Warning When given item does not exist you need to pass kwargs for all required fields of the model, including but not limited to primary_key column (unless it's autoincrement).","title":"get_or_create"},{"location":"queries/filter-and-sort/#all","text":"all(**kwargs) -> List[Optional[\"Model\"]] Returns all rows from a database for given model for set filter options. When any kwargs are passed it's a shortcut equivalent to calling filter(**kwargs).all() Tip To read more about filter go to filter . To read more about all go to read/all","title":"all"},{"location":"queries/filter-and-sort/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/filter-and-sort/#filter_1","text":"Works exactly the same as filter function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"filter"},{"location":"queries/filter-and-sort/#exclude_1","text":"Works exactly the same as exclude function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"exclude"},{"location":"queries/filter-and-sort/#get_1","text":"Works exactly the same as get function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"get"},{"location":"queries/filter-and-sort/#get_or_create_1","text":"Works exactly the same as get_or_create function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"get_or_create"},{"location":"queries/filter-and-sort/#all_1","text":"Works exactly the same as all function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"all"},{"location":"queries/filter-and-sort/#sorting","text":"","title":"Sorting"},{"location":"queries/filter-and-sort/#order_by","text":"order_by(columns: Union[List, str]) -> QuerySet With order_by() you can order the results from database based on your choice of fields. You can provide a string with field name or list of strings with different fields. Ordering in sql will be applied in order of names you provide in order_by. Tip By default if you do not provide ordering ormar explicitly orders by all primary keys Warning If you are sorting by nested models that causes that the result rows are unsorted by the main model ormar will combine those children rows into one main model. Sample raw database rows result (sort by child model desc): 1 2 3 MODEL: 1 - Child Model - 3 MODEL: 2 - Child Model - 2 MODEL: 1 - Child Model - 1 will result in 2 rows of result: 1 2 MODEL: 1 - Child Models: [3, 1] # encountered first in result, all children rows combined MODEL: 2 - Child Modles: [2] The main model will never duplicate in the result Given sample Models like following: 1 -- 8 < -- \"../../docs_src/queries/docs007.py\" To order by main model field just provide a field name 1 2 3 4 5 6 toys = await Toy . objects . select_related ( \"owner\" ) . order_by ( \"name\" ) . all () assert [ x . name . replace ( \"Toy \" , \"\" ) for x in toys ] == [ str ( x + 1 ) for x in range ( 6 ) ] assert toys [ 0 ] . owner == zeus assert toys [ 1 ] . owner == aphrodite To sort on nested models separate field names with dunder '__'. You can sort this way across all relation types -> ForeignKey , reverse virtual FK and ManyToMany fields. 1 2 3 4 toys = await Toy . objects . select_related ( \"owner\" ) . order_by ( \"owner__name\" ) . all () assert toys [ 0 ] . owner . name == toys [ 1 ] . owner . name == \"Aphrodite\" assert toys [ 2 ] . owner . name == toys [ 3 ] . owner . name == \"Hermes\" assert toys [ 4 ] . owner . name == toys [ 5 ] . owner . name == \"Zeus\" To sort in descending order provide a hyphen in front of the field name 1 2 3 4 5 6 7 8 owner = ( await Owner . objects . select_related ( \"toys\" ) . order_by ( \"-toys__name\" ) . filter ( name = \"Zeus\" ) . get () ) assert owner . toys [ 0 ] . name == \"Toy 4\" assert owner . toys [ 1 ] . name == \"Toy 1\" Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"order_by"},{"location":"queries/filter-and-sort/#querysetproxy-methods_1","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/filter-and-sort/#order_by_1","text":"Works exactly the same as order_by function above but allows you to sort related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"order_by"},{"location":"queries/joins-and-subqueries/","text":"Joins and subqueries To join one table to another, so load also related models you can use following methods. select_related(related: Union[List, str]) -> QuerySet prefetch_related(related: Union[List, str]) -> QuerySet Model Model.load() method QuerysetProxy QuerysetProxy.select_related(related: Union[List, str]) method QuerysetProxy.prefetch_related(related: Union[List, str]) method select_related select_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during the same query. With select_related always only one query is run against the database , meaning that one (sometimes complicated) join is generated and later nested models are processed in python. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Note If you are coming from django note that ormar select_related differs -> in django you can select_related only singe relation types, while in ormar you can select related across ForeignKey relation, reverse side of ForeignKey (so virtual auto generated keys) and ManyToMany fields (so all relations as of current version). Tip To control which model fields to select use fields() and exclude_fields() QuerySet methods. Tip To control order of models (both main or nested) use order_by() method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 album = await Album . objects . select_related ( \"tracks\" ) . all () # will return album will all columns tracks You can provide a string or a list of strings 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class SchoolClass ( ormar . Model ): class Meta : tablename = \"schoolclasses\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) department : Optional [ Department ] = ormar . ForeignKey ( Department , nullable = False ) class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Student ( ormar . Model ): class Meta : tablename = \"students\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) schoolclass : Optional [ SchoolClass ] = ormar . ForeignKey ( SchoolClass ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) class Teacher ( ormar . Model ): class Meta : tablename = \"teachers\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) schoolclass : Optional [ SchoolClass ] = ormar . ForeignKey ( SchoolClass ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) 1 2 3 4 classes = await SchoolClass . objects . select_related ( [ \"teachers__category\" , \"students\" ]) . all () # will return classes with teachers and teachers categories # as well as classes students Exactly the same behavior is for Many2Many fields, where you put the names of Many2Many fields and the final Models are fetched for you. Warning If you set ForeignKey field as not nullable (so required) during all queries the not nullable Models will be auto prefetched, even if you do not include them in select_related. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() prefetch_related prefetch_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database , meaning that you will have multiple queries executed one after another. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Tip To control which model fields to select use fields() and exclude_fields() QuerySet methods. Tip To control order of models (both main or nested) use order_by() method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 album = await Album . objects . prefetch_related ( \"tracks\" ) . all () # will return album will all columns tracks You can provide a string, or a list of strings 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class SchoolClass ( ormar . Model ): class Meta : tablename = \"schoolclasses\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) department : Optional [ Department ] = ormar . ForeignKey ( Department , nullable = False ) class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Student ( ormar . Model ): class Meta : tablename = \"students\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) schoolclass : Optional [ SchoolClass ] = ormar . ForeignKey ( SchoolClass ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) class Teacher ( ormar . Model ): class Meta : tablename = \"teachers\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) schoolclass : Optional [ SchoolClass ] = ormar . ForeignKey ( SchoolClass ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) 1 2 3 4 classes = await SchoolClass . objects . prefetch_related ( [ \"teachers__category\" , \"students\" ]) . all () # will return classes with teachers and teachers categories # as well as classes students Exactly the same behavior is for Many2Many fields, where you put the names of Many2Many fields and the final Models are fetched for you. Warning If you set ForeignKey field as not nullable (so required) during all queries the not nullable Models will be auto prefetched, even if you do not include them in select_related. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() select_related vs prefetch_related Which should you use -> select_related or prefetch_related ? Well, it really depends on your data. The best answer is try yourself and see which one performs faster/better in your system constraints. What to keep in mind: Performance Number of queries : select_related always executes one query against the database, while prefetch_related executes multiple queries. Usually the query (I/O) operation is the slowest one but it does not have to be. Number of rows : Imagine that you have 10 000 object in one table A and each of those objects have 3 children in table B, and subsequently each object in table B has 2 children in table C. Something like this: 1 2 3 4 5 6 7 8 9 10 11 Model C / Model B - Model C / Model A - Model B - Model C \\ \\ \\ Model C \\ Model B - Model C \\ Model C That means that select_related will always return 60 000 rows (10 000 * 3 * 2) later compacted to 10 000 models. How many rows will return prefetch_related ? Well, that depends, if each of models B and C is unique it will return 10 000 rows in first query, 30 000 rows (each of 3 children of A in table B are unique) in second query and 60 000 rows (each of 2 children of model B in table C are unique) in 3rd query. In this case select_related seems like a better choice, not only it will run one query comparing to 3 of prefetch_related but will also return 60 000 rows comparing to 100 000 of prefetch_related (10+30+60k). But what if each Model A has exactly the same 3 models B and each models C has exactly same models C? select_related will still return 60 000 rows, while prefetch_related will return 10 000 for model A, 3 rows for model B and 2 rows for Model C. So in total 10 006 rows. Now depending on the structure of models (i.e. if it has long Text() fields etc.) prefetch_related might be faster despite it needs to perform three separate queries instead of one. Memory ormar is a mini ORM meaning that it does not keep a registry of already loaded models. That means that in select_related example above you will always have 10 000 Models A, 30 000 Models B (even if the unique number of rows in db is 3 - processing of select_related spawns new child models for each parent model). And 60 000 Models C. If the same Model B is shared by rows 1, 10, 100 etc. and you update one of those, the rest of rows that share the same child will not be updated on the spot. If you persist your changes into the database the change will be available only after reload (either each child separately or the whole query again) . That means that select_related will use more memory as each child is instantiated as a new object - obviously using it's own space. Note This might change in future versions if we decide to introduce caching. Warning By default all children (or event the same models loaded 2+ times) are completely independent, distinct python objects, despite that they represent the same row in db. They will evaluate to True when compared, so in example above: 1 2 3 4 5 6 7 8 # will return True if child1 of both rows is the same child db row row1 . child1 == row100 . child1 # same here: model1 = await Model . get ( pk = 1 ) model2 = await Model . get ( pk = 1 ) # same pk = same row in db # will return `True` model1 == model2 but 1 2 3 4 5 # will return False (note that id is a python `builtin` function not ormar one). id ( row1 . child1 ) == ( ro100 . child1 ) # from above - will also return False id ( model1 ) == id ( model2 ) On the contrary - with prefetch_related each unique distinct child model is instantiated only once and the same child models is shared across all parent models. That means that in prefetch_related example above if there are 3 distinct models in table B and 2 in table C, there will be only 5 children nested models shared between all model A instances. That also means that if you update any attribute it will be updated on all parents as they share the same child object. Model methods Each model instance have a set of methods to save , update or load itself. load You can load the ForeignKey related model by calling load() method. load() can be used to refresh the model from the database (if it was changed by some other process). Tip Read more about load() method in models methods QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. select_related Works exactly the same as select_related function above but allows you to fetch related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section prefetch_related Works exactly the same as prefetch_related function above but allows you to fetch related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"Joins and subqueries"},{"location":"queries/joins-and-subqueries/#joins-and-subqueries","text":"To join one table to another, so load also related models you can use following methods. select_related(related: Union[List, str]) -> QuerySet prefetch_related(related: Union[List, str]) -> QuerySet Model Model.load() method QuerysetProxy QuerysetProxy.select_related(related: Union[List, str]) method QuerysetProxy.prefetch_related(related: Union[List, str]) method","title":"Joins and subqueries"},{"location":"queries/joins-and-subqueries/#select_related","text":"select_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during the same query. With select_related always only one query is run against the database , meaning that one (sometimes complicated) join is generated and later nested models are processed in python. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Note If you are coming from django note that ormar select_related differs -> in django you can select_related only singe relation types, while in ormar you can select related across ForeignKey relation, reverse side of ForeignKey (so virtual auto generated keys) and ManyToMany fields (so all relations as of current version). Tip To control which model fields to select use fields() and exclude_fields() QuerySet methods. Tip To control order of models (both main or nested) use order_by() method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 album = await Album . objects . select_related ( \"tracks\" ) . all () # will return album will all columns tracks You can provide a string or a list of strings 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class SchoolClass ( ormar . Model ): class Meta : tablename = \"schoolclasses\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) department : Optional [ Department ] = ormar . ForeignKey ( Department , nullable = False ) class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Student ( ormar . Model ): class Meta : tablename = \"students\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) schoolclass : Optional [ SchoolClass ] = ormar . ForeignKey ( SchoolClass ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) class Teacher ( ormar . Model ): class Meta : tablename = \"teachers\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) schoolclass : Optional [ SchoolClass ] = ormar . ForeignKey ( SchoolClass ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) 1 2 3 4 classes = await SchoolClass . objects . select_related ( [ \"teachers__category\" , \"students\" ]) . all () # will return classes with teachers and teachers categories # as well as classes students Exactly the same behavior is for Many2Many fields, where you put the names of Many2Many fields and the final Models are fetched for you. Warning If you set ForeignKey field as not nullable (so required) during all queries the not nullable Models will be auto prefetched, even if you do not include them in select_related. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"select_related"},{"location":"queries/joins-and-subqueries/#prefetch_related","text":"prefetch_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database , meaning that you will have multiple queries executed one after another. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Tip To control which model fields to select use fields() and exclude_fields() QuerySet methods. Tip To control order of models (both main or nested) use order_by() method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 album = await Album . objects . prefetch_related ( \"tracks\" ) . all () # will return album will all columns tracks You can provide a string, or a list of strings 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class SchoolClass ( ormar . Model ): class Meta : tablename = \"schoolclasses\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) department : Optional [ Department ] = ormar . ForeignKey ( Department , nullable = False ) class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Student ( ormar . Model ): class Meta : tablename = \"students\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) schoolclass : Optional [ SchoolClass ] = ormar . ForeignKey ( SchoolClass ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) class Teacher ( ormar . Model ): class Meta : tablename = \"teachers\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) schoolclass : Optional [ SchoolClass ] = ormar . ForeignKey ( SchoolClass ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) 1 2 3 4 classes = await SchoolClass . objects . prefetch_related ( [ \"teachers__category\" , \"students\" ]) . all () # will return classes with teachers and teachers categories # as well as classes students Exactly the same behavior is for Many2Many fields, where you put the names of Many2Many fields and the final Models are fetched for you. Warning If you set ForeignKey field as not nullable (so required) during all queries the not nullable Models will be auto prefetched, even if you do not include them in select_related. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"prefetch_related"},{"location":"queries/joins-and-subqueries/#select_related-vs-prefetch_related","text":"Which should you use -> select_related or prefetch_related ? Well, it really depends on your data. The best answer is try yourself and see which one performs faster/better in your system constraints. What to keep in mind:","title":"select_related vs prefetch_related"},{"location":"queries/joins-and-subqueries/#performance","text":"Number of queries : select_related always executes one query against the database, while prefetch_related executes multiple queries. Usually the query (I/O) operation is the slowest one but it does not have to be. Number of rows : Imagine that you have 10 000 object in one table A and each of those objects have 3 children in table B, and subsequently each object in table B has 2 children in table C. Something like this: 1 2 3 4 5 6 7 8 9 10 11 Model C / Model B - Model C / Model A - Model B - Model C \\ \\ \\ Model C \\ Model B - Model C \\ Model C That means that select_related will always return 60 000 rows (10 000 * 3 * 2) later compacted to 10 000 models. How many rows will return prefetch_related ? Well, that depends, if each of models B and C is unique it will return 10 000 rows in first query, 30 000 rows (each of 3 children of A in table B are unique) in second query and 60 000 rows (each of 2 children of model B in table C are unique) in 3rd query. In this case select_related seems like a better choice, not only it will run one query comparing to 3 of prefetch_related but will also return 60 000 rows comparing to 100 000 of prefetch_related (10+30+60k). But what if each Model A has exactly the same 3 models B and each models C has exactly same models C? select_related will still return 60 000 rows, while prefetch_related will return 10 000 for model A, 3 rows for model B and 2 rows for Model C. So in total 10 006 rows. Now depending on the structure of models (i.e. if it has long Text() fields etc.) prefetch_related might be faster despite it needs to perform three separate queries instead of one.","title":"Performance"},{"location":"queries/joins-and-subqueries/#memory","text":"ormar is a mini ORM meaning that it does not keep a registry of already loaded models. That means that in select_related example above you will always have 10 000 Models A, 30 000 Models B (even if the unique number of rows in db is 3 - processing of select_related spawns new child models for each parent model). And 60 000 Models C. If the same Model B is shared by rows 1, 10, 100 etc. and you update one of those, the rest of rows that share the same child will not be updated on the spot. If you persist your changes into the database the change will be available only after reload (either each child separately or the whole query again) . That means that select_related will use more memory as each child is instantiated as a new object - obviously using it's own space. Note This might change in future versions if we decide to introduce caching. Warning By default all children (or event the same models loaded 2+ times) are completely independent, distinct python objects, despite that they represent the same row in db. They will evaluate to True when compared, so in example above: 1 2 3 4 5 6 7 8 # will return True if child1 of both rows is the same child db row row1 . child1 == row100 . child1 # same here: model1 = await Model . get ( pk = 1 ) model2 = await Model . get ( pk = 1 ) # same pk = same row in db # will return `True` model1 == model2 but 1 2 3 4 5 # will return False (note that id is a python `builtin` function not ormar one). id ( row1 . child1 ) == ( ro100 . child1 ) # from above - will also return False id ( model1 ) == id ( model2 ) On the contrary - with prefetch_related each unique distinct child model is instantiated only once and the same child models is shared across all parent models. That means that in prefetch_related example above if there are 3 distinct models in table B and 2 in table C, there will be only 5 children nested models shared between all model A instances. That also means that if you update any attribute it will be updated on all parents as they share the same child object.","title":"Memory"},{"location":"queries/joins-and-subqueries/#model-methods","text":"Each model instance have a set of methods to save , update or load itself.","title":"Model methods"},{"location":"queries/joins-and-subqueries/#load","text":"You can load the ForeignKey related model by calling load() method. load() can be used to refresh the model from the database (if it was changed by some other process). Tip Read more about load() method in models methods","title":"load"},{"location":"queries/joins-and-subqueries/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/joins-and-subqueries/#select_related_1","text":"Works exactly the same as select_related function above but allows you to fetch related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"select_related"},{"location":"queries/joins-and-subqueries/#prefetch_related_1","text":"Works exactly the same as prefetch_related function above but allows you to fetch related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"prefetch_related"},{"location":"queries/pagination-and-rows-number/","text":"Pagination and rows number Following methods allow you to paginate and limit number of rows in queries. paginate(page: int) -> QuerySet limit(limit_count: int) -> QuerySet offset(offset: int) -> QuerySet get() -> Model first() -> Model QuerysetProxy QuerysetProxy.paginate(page: int) method QuerysetProxy.limit(limit_count: int) method QuerysetProxy.offset(offset: int) method paginate paginate(page: int, page_size: int = 20) -> QuerySet Combines the offset and limit methods based on page number and size 1 2 3 4 5 6 7 8 9 10 class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 3 tracks = await Track . objects . paginate ( 3 ) . all () # will return 20 tracks starting at row 41 # (with default page size of 20) Note that paginate(2) is equivalent to offset(20).limit(20) limit limit(limit_count: int, limit_raw_sql: bool = None) -> QuerySet You can limit the results to desired number of parent models. To limit the actual number of database query rows instead of number of main models use the limit_raw_sql parameter flag, and set it to True . 1 2 3 4 5 6 7 8 9 10 class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 tracks = await Track . objects . limit ( 1 ) . all () # will return just one Track Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() offset offset(offset: int, limit_raw_sql: bool = None) -> QuerySet You can also offset the results by desired number of main models. To offset the actual number of database query rows instead of number of main models use the limit_raw_sql parameter flag, and set it to True . 1 2 3 4 5 6 7 8 9 10 class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 tracks = await Track . objects . offset ( 1 ) . limit ( 1 ) . all () # will return just one Track, but this time the second one Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() get get(**kwargs) -> Model Get's the first row from the db meeting the criteria set by kwargs. If no criteria is set it will return the last row in db sorted by pk. (The criteria cannot be set also with filter/exclude). Tip To read more about get visit read/get first first() -> Model Gets the first row from the db ordered by primary key column ascending. Tip To read more about first visit read/first QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. paginate Works exactly the same as paginate function above but allows you to paginate related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section limit Works exactly the same as limit function above but allows you to paginate related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section offset Works exactly the same as offset function above but allows you to paginate related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"Pagination and rows number"},{"location":"queries/pagination-and-rows-number/#pagination-and-rows-number","text":"Following methods allow you to paginate and limit number of rows in queries. paginate(page: int) -> QuerySet limit(limit_count: int) -> QuerySet offset(offset: int) -> QuerySet get() -> Model first() -> Model QuerysetProxy QuerysetProxy.paginate(page: int) method QuerysetProxy.limit(limit_count: int) method QuerysetProxy.offset(offset: int) method","title":"Pagination and rows number"},{"location":"queries/pagination-and-rows-number/#paginate","text":"paginate(page: int, page_size: int = 20) -> QuerySet Combines the offset and limit methods based on page number and size 1 2 3 4 5 6 7 8 9 10 class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 3 tracks = await Track . objects . paginate ( 3 ) . all () # will return 20 tracks starting at row 41 # (with default page size of 20) Note that paginate(2) is equivalent to offset(20).limit(20)","title":"paginate"},{"location":"queries/pagination-and-rows-number/#limit","text":"limit(limit_count: int, limit_raw_sql: bool = None) -> QuerySet You can limit the results to desired number of parent models. To limit the actual number of database query rows instead of number of main models use the limit_raw_sql parameter flag, and set it to True . 1 2 3 4 5 6 7 8 9 10 class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 tracks = await Track . objects . limit ( 1 ) . all () # will return just one Track Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"limit"},{"location":"queries/pagination-and-rows-number/#offset","text":"offset(offset: int, limit_raw_sql: bool = None) -> QuerySet You can also offset the results by desired number of main models. To offset the actual number of database query rows instead of number of main models use the limit_raw_sql parameter flag, and set it to True . 1 2 3 4 5 6 7 8 9 10 class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 tracks = await Track . objects . offset ( 1 ) . limit ( 1 ) . all () # will return just one Track, but this time the second one Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"offset"},{"location":"queries/pagination-and-rows-number/#get","text":"get(**kwargs) -> Model Get's the first row from the db meeting the criteria set by kwargs. If no criteria is set it will return the last row in db sorted by pk. (The criteria cannot be set also with filter/exclude). Tip To read more about get visit read/get","title":"get"},{"location":"queries/pagination-and-rows-number/#first","text":"first() -> Model Gets the first row from the db ordered by primary key column ascending. Tip To read more about first visit read/first","title":"first"},{"location":"queries/pagination-and-rows-number/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/pagination-and-rows-number/#paginate_1","text":"Works exactly the same as paginate function above but allows you to paginate related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"paginate"},{"location":"queries/pagination-and-rows-number/#limit_1","text":"Works exactly the same as limit function above but allows you to paginate related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"limit"},{"location":"queries/pagination-and-rows-number/#offset_1","text":"Works exactly the same as offset function above but allows you to paginate related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"offset"},{"location":"queries/read/","text":"Read data from database Following methods allow you to load data from the database. get(**kwargs) -> Model get_or_create(**kwargs) -> Model first() -> Model all(**kwargs) -> List[Optional[Model]] Model Model.load() method QuerysetProxy QuerysetProxy.get(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.first() method QuerysetProxy.all(**kwargs) method get get(**kwargs) -> Model Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the last row in db sorted by pk column. Passing a criteria is actually calling filter(**kwargs) method described below. 1 2 3 4 5 6 7 8 9 10 class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 3 4 5 6 track = await Track . objects . get ( name = 'The Bird' ) # note that above is equivalent to await Track.objects.filter(name='The Bird').get() track2 = track = await Track . objects . get () track == track2 # True since it's the only row in db in our example # and get without arguments return first row by pk column desc Warning If no row meets the criteria NoMatch exception is raised. If there are multiple rows meeting the criteria the MultipleMatches exception is raised. get_or_create get_or_create(**kwargs) -> Model Combination of create and get methods. Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. 1 2 3 4 5 6 7 8 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) 1 2 3 4 5 album = await Album . objects . get_or_create ( name = 'The Cat' ) # object is created as it does not exist album2 = await Album . objects . get_or_create ( name = 'The Cat' ) assert album == album2 # return True as the same db row is returned Warning Despite being an equivalent row from database the album and album2 in example above are 2 different python objects! Updating one of them will not refresh the second one until you excplicitly load() the fresh data from db. Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement first first() -> Model Gets the first row from the db ordered by primary key column ascending. 1 2 3 4 5 6 7 8 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) 1 2 3 4 5 await Album . objects . create ( name = 'The Cat' ) await Album . objects . create ( name = 'The Dog' ) album = await Album . objects . first () # first row by primary_key column asc assert album . name == 'The Cat' all all(**kwargs) -> List[Optional[\"Model\"]] Returns all rows from a database for given model for set filter options. Passing kwargs is a shortcut and equals to calling filter(**kwrags).all() . If there are no rows meeting the criteria an empty list is returned. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 3 4 5 6 tracks = await Track . objects . select_related ( \"album\" ) . all ( album__title = 'Sample' ) # will return a list of all Tracks for album Sample # for more on joins visit joining and subqueries section tracks = await Track . objects . all () # will return a list of all Tracks in database Model methods Each model instance have a set of methods to save , update or load itself. load You can load the ForeignKey related model by calling load() method. load() can be used to refresh the model from the database (if it was changed by some other process). Tip Read more about load() method in models methods QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. get Works exactly the same as get function above but allows you to fetch related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section get_or_create Works exactly the same as get_or_create function above but allows you to query or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section first Works exactly the same as first function above but allows you to query related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section all Works exactly the same as all function above but allows you to query related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"Read data from database"},{"location":"queries/read/#read-data-from-database","text":"Following methods allow you to load data from the database. get(**kwargs) -> Model get_or_create(**kwargs) -> Model first() -> Model all(**kwargs) -> List[Optional[Model]] Model Model.load() method QuerysetProxy QuerysetProxy.get(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.first() method QuerysetProxy.all(**kwargs) method","title":"Read data from database"},{"location":"queries/read/#get","text":"get(**kwargs) -> Model Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the last row in db sorted by pk column. Passing a criteria is actually calling filter(**kwargs) method described below. 1 2 3 4 5 6 7 8 9 10 class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 3 4 5 6 track = await Track . objects . get ( name = 'The Bird' ) # note that above is equivalent to await Track.objects.filter(name='The Bird').get() track2 = track = await Track . objects . get () track == track2 # True since it's the only row in db in our example # and get without arguments return first row by pk column desc Warning If no row meets the criteria NoMatch exception is raised. If there are multiple rows meeting the criteria the MultipleMatches exception is raised.","title":"get"},{"location":"queries/read/#get_or_create","text":"get_or_create(**kwargs) -> Model Combination of create and get methods. Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. 1 2 3 4 5 6 7 8 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) 1 2 3 4 5 album = await Album . objects . get_or_create ( name = 'The Cat' ) # object is created as it does not exist album2 = await Album . objects . get_or_create ( name = 'The Cat' ) assert album == album2 # return True as the same db row is returned Warning Despite being an equivalent row from database the album and album2 in example above are 2 different python objects! Updating one of them will not refresh the second one until you excplicitly load() the fresh data from db. Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement","title":"get_or_create"},{"location":"queries/read/#first","text":"first() -> Model Gets the first row from the db ordered by primary key column ascending. 1 2 3 4 5 6 7 8 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) 1 2 3 4 5 await Album . objects . create ( name = 'The Cat' ) await Album . objects . create ( name = 'The Dog' ) album = await Album . objects . first () # first row by primary_key column asc assert album . name == 'The Cat'","title":"first"},{"location":"queries/read/#all","text":"all(**kwargs) -> List[Optional[\"Model\"]] Returns all rows from a database for given model for set filter options. Passing kwargs is a shortcut and equals to calling filter(**kwrags).all() . If there are no rows meeting the criteria an empty list is returned. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 3 4 5 6 tracks = await Track . objects . select_related ( \"album\" ) . all ( album__title = 'Sample' ) # will return a list of all Tracks for album Sample # for more on joins visit joining and subqueries section tracks = await Track . objects . all () # will return a list of all Tracks in database","title":"all"},{"location":"queries/read/#model-methods","text":"Each model instance have a set of methods to save , update or load itself.","title":"Model methods"},{"location":"queries/read/#load","text":"You can load the ForeignKey related model by calling load() method. load() can be used to refresh the model from the database (if it was changed by some other process). Tip Read more about load() method in models methods","title":"load"},{"location":"queries/read/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/read/#get_1","text":"Works exactly the same as get function above but allows you to fetch related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"get"},{"location":"queries/read/#get_or_create_1","text":"Works exactly the same as get_or_create function above but allows you to query or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"get_or_create"},{"location":"queries/read/#first_1","text":"Works exactly the same as first function above but allows you to query related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"first"},{"location":"queries/read/#all_1","text":"Works exactly the same as all function above but allows you to query related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"all"},{"location":"queries/select-columns/","text":"Selecting subset of columns To select only chosen columns of your model you can use following functions. fields(columns: Union[List, str, set, dict]) -> QuerySet exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet QuerysetProxy QuerysetProxy.fields(columns: Union[List, str, set, dict]) method QuerysetProxy.exclude_fields(columns: Union[List, str, set, dict]) method fields fields(columns: Union[List, str, set, dict]) -> QuerySet With fields() you can select subset of model columns to limit the data load. Note Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Given a sample data like following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL , force_rollback = True ) metadata = sqlalchemy . MetaData () class Company ( ormar . Model ): class Meta : tablename = \"companies\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) founded : int = ormar . Integer ( nullable = True ) class Car ( ormar . Model ): class Meta : tablename = \"cars\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) manufacturer = ormar . ForeignKey ( Company ) name : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) gearbox_type : str = ormar . String ( max_length = 20 , nullable = True ) gears : int = ormar . Integer ( nullable = True ) aircon_type : str = ormar . String ( max_length = 20 , nullable = True ) # build some sample data toyota = await Company . objects . create ( name = \"Toyota\" , founded = 1937 ) await Car . objects . create ( manufacturer = toyota , name = \"Corolla\" , year = 2020 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Yaris\" , year = 2019 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Supreme\" , year = 2020 , gearbox_type = 'Auto' , gears = 6 , aircon_type = 'Auto' ) You can select specified fields by passing a str, List[str], Set[str] or dict with nested definition. To include related models use notation {related_name}__{column}[__{optional_next} etc.] . 1 2 3 4 5 6 7 8 9 all_cars = await Car . objects . select_related ( 'manufacturer' ) . fields ([ 'id' , 'name' , 'manufacturer__name' ]) . all () for car in all_cars : # excluded columns will yield None assert all ( getattr ( car , x ) is None for x in [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' ]) # included column on related models will be available, pk column is always included # even if you do not include it in fields list assert car . manufacturer . name == 'Toyota' # also in the nested related models - you cannot exclude pk - it's always auto added assert car . manufacturer . founded is None fields() can be called several times, building up the columns to select. If you include related models into select_related() call but you won't specify columns for those models in fields implies a list of all fields for those nested models. 1 2 3 4 5 all_cars = await Car . objects . select_related ( 'manufacturer' ) . fields ( 'id' ) . fields ( [ 'name' ]) . all () # all fiels from company model are selected assert all_cars [ 0 ] . manufacturer . name == 'Toyota' assert all_cars [ 0 ] . manufacturer . founded == 1937 Warning Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. You cannot exclude mandatory model columns - manufacturer__name in this example. 1 2 3 await Car . objects . select_related ( 'manufacturer' ) . fields ( [ 'id' , 'name' , 'manufacturer__founded' ]) . all () # will raise pydantic ValidationError as company.name is required Tip Pk column cannot be excluded - it's always auto added even if not explicitly included. You can also pass fields to include as dictionary or set. To mark a field as included in a dictionary use it's name as key and ellipsis as value. To traverse nested models use nested dictionaries. To include fields at last level instead of nested dictionary a set can be used. To include whole nested model specify model related field name and ellipsis. Below you can see examples that are equivalent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 1. like in example above await Car . objects . select_related ( 'manufacturer' ) . fields ([ 'id' , 'name' , 'manufacturer__name' ]) . all () # 2. to mark a field as required use ellipsis await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' : ... } }) . all () # 3. to include whole nested model use ellipsis await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : ... }) . all () # 4. to specify fields at last nesting level you can also use set - equivalent to 2. above await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' } }) . all () # 5. of course set can have multiple fields await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' , 'founded' } }) . all () # 6. you can include all nested fields but it will be equivalent of 3. above which is shorter await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'id' , 'name' , 'founded' } }) . all () Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() exclude_fields exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. It's the opposite of fields() method so check documentation above to see what options are available. Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy. Note Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Below you can find few simple examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL , force_rollback = True ) metadata = sqlalchemy . MetaData () class Company ( ormar . Model ): class Meta : tablename = \"companies\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) founded : int = ormar . Integer ( nullable = True ) class Car ( ormar . Model ): class Meta : tablename = \"cars\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) manufacturer = ormar . ForeignKey ( Company ) name : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) gearbox_type : str = ormar . String ( max_length = 20 , nullable = True ) gears : int = ormar . Integer ( nullable = True ) aircon_type : str = ormar . String ( max_length = 20 , nullable = True ) # build some sample data toyota = await Company . objects . create ( name = \"Toyota\" , founded = 1937 ) await Car . objects . create ( manufacturer = toyota , name = \"Corolla\" , year = 2020 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Yaris\" , year = 2019 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Supreme\" , year = 2020 , gearbox_type = 'Auto' , gears = 6 , aircon_type = 'Auto' ) # select manufacturer but only name - to include related models use notation {model_name}__{column} all_cars = await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ( [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' , 'company__founded' ]) . all () for car in all_cars : # excluded columns will yield None assert all ( getattr ( car , x ) is None for x in [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' ]) # included column on related models will be available, pk column is always included # even if you do not include it in fields list assert car . manufacturer . name == 'Toyota' # also in the nested related models - you cannot exclude pk - it's always auto added assert car . manufacturer . founded is None # fields() can be called several times, building up the columns to select # models selected in select_related but with no columns in fields list implies all fields all_cars = await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ( 'year' ) . exclude_fields ( [ 'gear' , 'gearbox_type' ]) . all () # all fiels from company model are selected assert all_cars [ 0 ] . manufacturer . name == 'Toyota' assert all_cars [ 0 ] . manufacturer . founded == 1937 # cannot exclude mandatory model columns - company__name in this example - note usage of dict/set this time await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ([{ 'company' : { 'name' }}]) . all () # will raise pydantic ValidationError as company.name is required Warning Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Tip Pk column cannot be excluded - it's always auto added even if explicitly excluded. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. fields Works exactly the same as fields function above but allows you to select columns from related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section exclude_fields Works exactly the same as exclude_fields function above but allows you to select columns from related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"Selecting subset of columns"},{"location":"queries/select-columns/#selecting-subset-of-columns","text":"To select only chosen columns of your model you can use following functions. fields(columns: Union[List, str, set, dict]) -> QuerySet exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet QuerysetProxy QuerysetProxy.fields(columns: Union[List, str, set, dict]) method QuerysetProxy.exclude_fields(columns: Union[List, str, set, dict]) method","title":"Selecting subset of columns"},{"location":"queries/select-columns/#fields","text":"fields(columns: Union[List, str, set, dict]) -> QuerySet With fields() you can select subset of model columns to limit the data load. Note Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Given a sample data like following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL , force_rollback = True ) metadata = sqlalchemy . MetaData () class Company ( ormar . Model ): class Meta : tablename = \"companies\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) founded : int = ormar . Integer ( nullable = True ) class Car ( ormar . Model ): class Meta : tablename = \"cars\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) manufacturer = ormar . ForeignKey ( Company ) name : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) gearbox_type : str = ormar . String ( max_length = 20 , nullable = True ) gears : int = ormar . Integer ( nullable = True ) aircon_type : str = ormar . String ( max_length = 20 , nullable = True ) # build some sample data toyota = await Company . objects . create ( name = \"Toyota\" , founded = 1937 ) await Car . objects . create ( manufacturer = toyota , name = \"Corolla\" , year = 2020 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Yaris\" , year = 2019 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Supreme\" , year = 2020 , gearbox_type = 'Auto' , gears = 6 , aircon_type = 'Auto' ) You can select specified fields by passing a str, List[str], Set[str] or dict with nested definition. To include related models use notation {related_name}__{column}[__{optional_next} etc.] . 1 2 3 4 5 6 7 8 9 all_cars = await Car . objects . select_related ( 'manufacturer' ) . fields ([ 'id' , 'name' , 'manufacturer__name' ]) . all () for car in all_cars : # excluded columns will yield None assert all ( getattr ( car , x ) is None for x in [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' ]) # included column on related models will be available, pk column is always included # even if you do not include it in fields list assert car . manufacturer . name == 'Toyota' # also in the nested related models - you cannot exclude pk - it's always auto added assert car . manufacturer . founded is None fields() can be called several times, building up the columns to select. If you include related models into select_related() call but you won't specify columns for those models in fields implies a list of all fields for those nested models. 1 2 3 4 5 all_cars = await Car . objects . select_related ( 'manufacturer' ) . fields ( 'id' ) . fields ( [ 'name' ]) . all () # all fiels from company model are selected assert all_cars [ 0 ] . manufacturer . name == 'Toyota' assert all_cars [ 0 ] . manufacturer . founded == 1937 Warning Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. You cannot exclude mandatory model columns - manufacturer__name in this example. 1 2 3 await Car . objects . select_related ( 'manufacturer' ) . fields ( [ 'id' , 'name' , 'manufacturer__founded' ]) . all () # will raise pydantic ValidationError as company.name is required Tip Pk column cannot be excluded - it's always auto added even if not explicitly included. You can also pass fields to include as dictionary or set. To mark a field as included in a dictionary use it's name as key and ellipsis as value. To traverse nested models use nested dictionaries. To include fields at last level instead of nested dictionary a set can be used. To include whole nested model specify model related field name and ellipsis. Below you can see examples that are equivalent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 1. like in example above await Car . objects . select_related ( 'manufacturer' ) . fields ([ 'id' , 'name' , 'manufacturer__name' ]) . all () # 2. to mark a field as required use ellipsis await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' : ... } }) . all () # 3. to include whole nested model use ellipsis await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : ... }) . all () # 4. to specify fields at last nesting level you can also use set - equivalent to 2. above await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' } }) . all () # 5. of course set can have multiple fields await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' , 'founded' } }) . all () # 6. you can include all nested fields but it will be equivalent of 3. above which is shorter await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'id' , 'name' , 'founded' } }) . all () Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"fields"},{"location":"queries/select-columns/#exclude_fields","text":"exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. It's the opposite of fields() method so check documentation above to see what options are available. Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy. Note Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Below you can find few simple examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL , force_rollback = True ) metadata = sqlalchemy . MetaData () class Company ( ormar . Model ): class Meta : tablename = \"companies\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) founded : int = ormar . Integer ( nullable = True ) class Car ( ormar . Model ): class Meta : tablename = \"cars\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) manufacturer = ormar . ForeignKey ( Company ) name : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) gearbox_type : str = ormar . String ( max_length = 20 , nullable = True ) gears : int = ormar . Integer ( nullable = True ) aircon_type : str = ormar . String ( max_length = 20 , nullable = True ) # build some sample data toyota = await Company . objects . create ( name = \"Toyota\" , founded = 1937 ) await Car . objects . create ( manufacturer = toyota , name = \"Corolla\" , year = 2020 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Yaris\" , year = 2019 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Supreme\" , year = 2020 , gearbox_type = 'Auto' , gears = 6 , aircon_type = 'Auto' ) # select manufacturer but only name - to include related models use notation {model_name}__{column} all_cars = await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ( [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' , 'company__founded' ]) . all () for car in all_cars : # excluded columns will yield None assert all ( getattr ( car , x ) is None for x in [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' ]) # included column on related models will be available, pk column is always included # even if you do not include it in fields list assert car . manufacturer . name == 'Toyota' # also in the nested related models - you cannot exclude pk - it's always auto added assert car . manufacturer . founded is None # fields() can be called several times, building up the columns to select # models selected in select_related but with no columns in fields list implies all fields all_cars = await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ( 'year' ) . exclude_fields ( [ 'gear' , 'gearbox_type' ]) . all () # all fiels from company model are selected assert all_cars [ 0 ] . manufacturer . name == 'Toyota' assert all_cars [ 0 ] . manufacturer . founded == 1937 # cannot exclude mandatory model columns - company__name in this example - note usage of dict/set this time await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ([{ 'company' : { 'name' }}]) . all () # will raise pydantic ValidationError as company.name is required Warning Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Tip Pk column cannot be excluded - it's always auto added even if explicitly excluded. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"exclude_fields"},{"location":"queries/select-columns/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/select-columns/#fields_1","text":"Works exactly the same as fields function above but allows you to select columns from related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"fields"},{"location":"queries/select-columns/#exclude_fields_1","text":"Works exactly the same as exclude_fields function above but allows you to select columns from related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"exclude_fields"},{"location":"queries/update/","text":"Update data in database Following methods and functions allow updating existing data in the database. update(each: bool = False, **kwargs) -> int update_or_create(**kwargs) -> Model bulk_update(objects: List[Model], columns: List[str] = None) -> None Model Model.update() method Model.upsert() method Model.save_related() method QuerysetProxy QuerysetProxy.update_or_create(**kwargs) method update update(each: bool = False, **kwargs) -> int QuerySet level update is used to update multiple records with the same value at once. You either have to filter the QuerySet first or provide a each=True flag to update whole table. If you do not provide this flag or a filter a QueryDefinitionError will be raised. Return number of rows updated. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . update ( each = True , genre = 'Fiction' ) all_books = await Book . objects . filter ( genre = 'Fiction' ) . all () assert len ( all_books ) == 3 Warning Queryset needs to be filtered before updating to prevent accidental overwrite. To update whole database table each=True needs to be provided as a safety switch update_or_create update_or_create(**kwargs) -> Model Updates the model, or in case there is no match in database creates a new one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) # if not exist the instance will be persisted in db vol2 = await Book . objects . update_or_create ( title = \"Volume II\" , author = 'Anonymous' , genre = 'Fiction' ) assert await Book . objects . count () == 1 # if pk or pkname passed in kwargs (like id here) the object will be updated assert await Book . objects . update_or_create ( id = vol2 . id , genre = 'Historic' ) assert await Book . objects . count () == 1 Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement bulk_update bulk_update(objects: List[\"Model\"], columns: List[str] = None) -> None Allows to update multiple instance at once. All Models passed need to have primary key column populated. You can also select which fields to update by passing columns list as a list of string names. 1 2 3 4 5 6 7 8 9 10 11 # continuing the example from bulk_create # update objects for todo in todoes : todo . completed = False # perform update of all objects at once # objects need to have pk column set, otherwise exception is raised await ToDo . objects . bulk_update ( todoes ) completed = await ToDo . objects . filter ( completed = False ) . all () assert len ( completed ) == 3 Model methods Each model instance have a set of methods to save , update or load itself. update You can update models by updating your model attributes (fields) and calling update() method. If you try to update a model without a primary key set a ModelPersistenceError exception will be thrown. Tip Read more about update() method in models-update upsert It's a proxy to either save() or update(**kwargs) methods of a Model. If the pk is set the update() method will be called. Tip Read more about upsert() method in models-upsert save_related Method goes through all relations of the Model on which the method is called, and calls upsert() method on each model that is not saved. Tip Read more about save_related() method in models-save-related QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. update_or_create Works exactly the same as update_or_create function above but allows you to update or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"Update data in database"},{"location":"queries/update/#update-data-in-database","text":"Following methods and functions allow updating existing data in the database. update(each: bool = False, **kwargs) -> int update_or_create(**kwargs) -> Model bulk_update(objects: List[Model], columns: List[str] = None) -> None Model Model.update() method Model.upsert() method Model.save_related() method QuerysetProxy QuerysetProxy.update_or_create(**kwargs) method","title":"Update data in database"},{"location":"queries/update/#update","text":"update(each: bool = False, **kwargs) -> int QuerySet level update is used to update multiple records with the same value at once. You either have to filter the QuerySet first or provide a each=True flag to update whole table. If you do not provide this flag or a filter a QueryDefinitionError will be raised. Return number of rows updated. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . update ( each = True , genre = 'Fiction' ) all_books = await Book . objects . filter ( genre = 'Fiction' ) . all () assert len ( all_books ) == 3 Warning Queryset needs to be filtered before updating to prevent accidental overwrite. To update whole database table each=True needs to be provided as a safety switch","title":"update"},{"location":"queries/update/#update_or_create","text":"update_or_create(**kwargs) -> Model Updates the model, or in case there is no match in database creates a new one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) # if not exist the instance will be persisted in db vol2 = await Book . objects . update_or_create ( title = \"Volume II\" , author = 'Anonymous' , genre = 'Fiction' ) assert await Book . objects . count () == 1 # if pk or pkname passed in kwargs (like id here) the object will be updated assert await Book . objects . update_or_create ( id = vol2 . id , genre = 'Historic' ) assert await Book . objects . count () == 1 Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement","title":"update_or_create"},{"location":"queries/update/#bulk_update","text":"bulk_update(objects: List[\"Model\"], columns: List[str] = None) -> None Allows to update multiple instance at once. All Models passed need to have primary key column populated. You can also select which fields to update by passing columns list as a list of string names. 1 2 3 4 5 6 7 8 9 10 11 # continuing the example from bulk_create # update objects for todo in todoes : todo . completed = False # perform update of all objects at once # objects need to have pk column set, otherwise exception is raised await ToDo . objects . bulk_update ( todoes ) completed = await ToDo . objects . filter ( completed = False ) . all () assert len ( completed ) == 3","title":"bulk_update"},{"location":"queries/update/#model-methods","text":"Each model instance have a set of methods to save , update or load itself.","title":"Model methods"},{"location":"queries/update/#update_1","text":"You can update models by updating your model attributes (fields) and calling update() method. If you try to update a model without a primary key set a ModelPersistenceError exception will be thrown. Tip Read more about update() method in models-update","title":"update"},{"location":"queries/update/#upsert","text":"It's a proxy to either save() or update(**kwargs) methods of a Model. If the pk is set the update() method will be called. Tip Read more about upsert() method in models-upsert","title":"upsert"},{"location":"queries/update/#save_related","text":"Method goes through all relations of the Model on which the method is called, and calls upsert() method on each model that is not saved. Tip Read more about save_related() method in models-save-related","title":"save_related"},{"location":"queries/update/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/update/#update_or_create_1","text":"Works exactly the same as update_or_create function above but allows you to update or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"update_or_create"},{"location":"relations/","text":"Relations Currently ormar supports two types of relations: One-to-many (and many-to-one) with ForeignKey field Many-to-many with ManyToMany field Below you can find a very basic examples of definitions for each of those relations. To read more about methods, possibilities, definition etc. please read the subsequent section of the documentation. ForeignKey To define many-to-one relation use ForeignKey field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) Tip To read more about one-to-many relations visit foreign-keys section Reverse ForeignKey The definition of one-to-many relation also uses ForeignKey , and it's registered for you automatically. So in relation ato example above. 1 2 3 4 5 6 7 8 9 10 class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # there is a virtual field here like follows courses : Optional [ List [ Course ]] = ormar . ForeignKey ( Course , virtual = True ) # note that you DO NOT define it yourself, ormar does it for you. Tip To read more about many-to-one relations (i.e changing the name of generated field) visit foreign-keys section Tip Reverse ForeignKey allows you to query the related models with queryset-proxy . It allows you to use await department.courses.all() to fetch data related only to specific department etc. ManyToMany To define many-to-many relation use ManyToMany field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Category ( ormar . Model ): class Meta : tablename = \"categories\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) # note: you need to specify through model class PostCategory ( ormar . Model ): class Meta : tablename = \"posts_categories\" database = database metadata = metadata class Post ( ormar . Model ): class Meta : tablename = \"posts\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories : Optional [ Union [ Category , List [ Category ]]] = ormar . ManyToMany ( Category , through = PostCategory ) Tip To read more about many-to-many relations visit many-to-many section Tip ManyToMany allows you to query the related models with queryset-proxy . It allows you to use await post.categories.all() but also await category.posts.all() to fetch data related only to specific post, category etc. Self-reference and postponed references In order to create auto-relation or create two models that reference each other in at least two different relations (remember the reverse side is auto-registered for you), you need to use ForwardRef from typing module. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PersonRef = ForwardRef ( \"Person\" ) class Person ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) supervisor : PersonRef = ormar . ForeignKey ( PersonRef , related_name = \"employees\" ) Person . update_forward_refs () Tip To read more about self-reference and postponed relations visit postponed-annotations section","title":"Relations"},{"location":"relations/#relations","text":"Currently ormar supports two types of relations: One-to-many (and many-to-one) with ForeignKey field Many-to-many with ManyToMany field Below you can find a very basic examples of definitions for each of those relations. To read more about methods, possibilities, definition etc. please read the subsequent section of the documentation.","title":"Relations"},{"location":"relations/#foreignkey","text":"To define many-to-one relation use ForeignKey field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) Tip To read more about one-to-many relations visit foreign-keys section","title":"ForeignKey"},{"location":"relations/#reverse-foreignkey","text":"The definition of one-to-many relation also uses ForeignKey , and it's registered for you automatically. So in relation ato example above. 1 2 3 4 5 6 7 8 9 10 class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # there is a virtual field here like follows courses : Optional [ List [ Course ]] = ormar . ForeignKey ( Course , virtual = True ) # note that you DO NOT define it yourself, ormar does it for you. Tip To read more about many-to-one relations (i.e changing the name of generated field) visit foreign-keys section Tip Reverse ForeignKey allows you to query the related models with queryset-proxy . It allows you to use await department.courses.all() to fetch data related only to specific department etc.","title":"Reverse ForeignKey"},{"location":"relations/#manytomany","text":"To define many-to-many relation use ManyToMany field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Category ( ormar . Model ): class Meta : tablename = \"categories\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) # note: you need to specify through model class PostCategory ( ormar . Model ): class Meta : tablename = \"posts_categories\" database = database metadata = metadata class Post ( ormar . Model ): class Meta : tablename = \"posts\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories : Optional [ Union [ Category , List [ Category ]]] = ormar . ManyToMany ( Category , through = PostCategory ) Tip To read more about many-to-many relations visit many-to-many section Tip ManyToMany allows you to query the related models with queryset-proxy . It allows you to use await post.categories.all() but also await category.posts.all() to fetch data related only to specific post, category etc.","title":"ManyToMany"},{"location":"relations/#self-reference-and-postponed-references","text":"In order to create auto-relation or create two models that reference each other in at least two different relations (remember the reverse side is auto-registered for you), you need to use ForwardRef from typing module. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PersonRef = ForwardRef ( \"Person\" ) class Person ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) supervisor : PersonRef = ormar . ForeignKey ( PersonRef , related_name = \"employees\" ) Person . update_forward_refs () Tip To read more about self-reference and postponed relations visit postponed-annotations section","title":"Self-reference and postponed references"},{"location":"relations/foreign-key/","text":"ForeignKey ForeignKey(to, related_name=None) has required parameters to that takes target Model class. Sqlalchemy column and Type are automatically taken from target Model . Sqlalchemy column: class of a target Model primary key column Type (used for pydantic): type of a target Model Defining Models To define a relation add ForeignKey field that points to related Model . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department ) Reverse Relation ForeignKey fields are automatically registering reverse side of the relation. By default it's child (source) Model name + s, like courses in snippet below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department ) department = await Department ( name = \"Science\" ) . save () course = Course ( name = \"Math\" , completed = False , department = department ) print ( department . courses [ 0 ]) # Will produce: # Course(id=None, # name='Math', # completed=False, # department=Department(id=None, name='Science')) Reverse relation exposes API to manage related objects also from parent side. add Adding child model from parent side causes adding related model to currently loaded parent relation, as well as sets child's model foreign key value and updates the model. 1 2 3 4 5 6 7 8 9 department = await Department ( name = \"Science\" ) . save () course = Course ( name = \"Math\" , completed = False ) # note - not saved await department . courses . add ( course ) assert course . pk is not None # child model was saved # relation on child model is set and FK column saved in db assert courses . department == department # relation on parent model is also set assert department . courses [ 0 ] == course Warning If you want to add child model on related model the primary key value for parent model has to exist in database . Otherwise ormar will raise RelationshipInstanceError as it cannot set child's ForeignKey column value if parent model has no primary key value. That means that in example above the department has to be saved before you can call department.courses.add() . remove Removal of the related model one by one. In reverse relation calling remove() does not remove the child model, but instead nulls it ForeignKey value. 1 2 3 4 5 6 7 8 9 # continuing from above await department . courses . remove ( course ) assert len ( department . courses ) == 0 # course still exists and was saved in remove assert course . pk is not None assert course . department is None # to remove child from db await course . delete () But if you want to clear the relation and delete the child at the same time you can issue: 1 2 3 # this will not only clear the relation # but also delete related course from db await department . courses . remove ( course , keep_reversed = False ) clear Removal of all related models in one call. Like remove by default clear() nulls the ForeigKey column on child model (all, not matter if they are loaded or not). 1 2 # nulls department column on all courses related to this department await department . courses . clear () If you want to remove the children altogether from the database, set keep_reversed=False 1 2 # deletes from db all courses related to this department await department . courses . clear ( keep_reversed = False ) QuerysetProxy Reverse relation exposes QuerysetProxy API that allows you to query related model like you would issue a normal Query. To read which methods of QuerySet are available read below querysetproxy related_name But you can overwrite this name by providing related_name parameter like below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department , related_name = \"my_courses\" ) department = Department ( name = \"Science\" ) course = Course ( name = \"Math\" , completed = False , department = department ) print ( department . my_courses [ 0 ]) # Will produce: # Course(id=None, # name='Math', # completed=False, # department=Department(id=None, name='Science')) Tip The reverse relation on access returns list of wekref.proxy to avoid circular references. Warning When you provide multiple relations to the same model ormar can no longer auto generate the related_name for you. Therefore, in that situation you have to provide related_name for all but one (one can be default and generated) or all related fields. Relation Setup You have several ways to set-up a relationship connection. Model instance The most obvious one is to pass a related Model instance to the constructor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None ) Primary key value You can setup the relation also with just the pk column value of the related model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None ) Dictionary Next option is with a dictionary of key-values of the related model. You can build the dictionary yourself or get it from existing model with dict() method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None ) None Finally you can explicitly set it to None (default behavior if no value passed). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None ) Warning In all not None cases the primary key value for related model has to exist in database . Otherwise an IntegrityError will be raised by your database driver library.","title":"ForeignKey"},{"location":"relations/foreign-key/#foreignkey","text":"ForeignKey(to, related_name=None) has required parameters to that takes target Model class. Sqlalchemy column and Type are automatically taken from target Model . Sqlalchemy column: class of a target Model primary key column Type (used for pydantic): type of a target Model","title":"ForeignKey"},{"location":"relations/foreign-key/#defining-models","text":"To define a relation add ForeignKey field that points to related Model . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department )","title":"Defining Models"},{"location":"relations/foreign-key/#reverse-relation","text":"ForeignKey fields are automatically registering reverse side of the relation. By default it's child (source) Model name + s, like courses in snippet below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department ) department = await Department ( name = \"Science\" ) . save () course = Course ( name = \"Math\" , completed = False , department = department ) print ( department . courses [ 0 ]) # Will produce: # Course(id=None, # name='Math', # completed=False, # department=Department(id=None, name='Science')) Reverse relation exposes API to manage related objects also from parent side.","title":"Reverse Relation"},{"location":"relations/foreign-key/#add","text":"Adding child model from parent side causes adding related model to currently loaded parent relation, as well as sets child's model foreign key value and updates the model. 1 2 3 4 5 6 7 8 9 department = await Department ( name = \"Science\" ) . save () course = Course ( name = \"Math\" , completed = False ) # note - not saved await department . courses . add ( course ) assert course . pk is not None # child model was saved # relation on child model is set and FK column saved in db assert courses . department == department # relation on parent model is also set assert department . courses [ 0 ] == course Warning If you want to add child model on related model the primary key value for parent model has to exist in database . Otherwise ormar will raise RelationshipInstanceError as it cannot set child's ForeignKey column value if parent model has no primary key value. That means that in example above the department has to be saved before you can call department.courses.add() .","title":"add"},{"location":"relations/foreign-key/#remove","text":"Removal of the related model one by one. In reverse relation calling remove() does not remove the child model, but instead nulls it ForeignKey value. 1 2 3 4 5 6 7 8 9 # continuing from above await department . courses . remove ( course ) assert len ( department . courses ) == 0 # course still exists and was saved in remove assert course . pk is not None assert course . department is None # to remove child from db await course . delete () But if you want to clear the relation and delete the child at the same time you can issue: 1 2 3 # this will not only clear the relation # but also delete related course from db await department . courses . remove ( course , keep_reversed = False )","title":"remove"},{"location":"relations/foreign-key/#clear","text":"Removal of all related models in one call. Like remove by default clear() nulls the ForeigKey column on child model (all, not matter if they are loaded or not). 1 2 # nulls department column on all courses related to this department await department . courses . clear () If you want to remove the children altogether from the database, set keep_reversed=False 1 2 # deletes from db all courses related to this department await department . courses . clear ( keep_reversed = False )","title":"clear"},{"location":"relations/foreign-key/#querysetproxy","text":"Reverse relation exposes QuerysetProxy API that allows you to query related model like you would issue a normal Query. To read which methods of QuerySet are available read below querysetproxy","title":"QuerysetProxy"},{"location":"relations/foreign-key/#related_name","text":"But you can overwrite this name by providing related_name parameter like below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department , related_name = \"my_courses\" ) department = Department ( name = \"Science\" ) course = Course ( name = \"Math\" , completed = False , department = department ) print ( department . my_courses [ 0 ]) # Will produce: # Course(id=None, # name='Math', # completed=False, # department=Department(id=None, name='Science')) Tip The reverse relation on access returns list of wekref.proxy to avoid circular references. Warning When you provide multiple relations to the same model ormar can no longer auto generate the related_name for you. Therefore, in that situation you have to provide related_name for all but one (one can be default and generated) or all related fields.","title":"related_name"},{"location":"relations/foreign-key/#relation-setup","text":"You have several ways to set-up a relationship connection.","title":"Relation Setup"},{"location":"relations/foreign-key/#model-instance","text":"The most obvious one is to pass a related Model instance to the constructor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None )","title":"Model instance"},{"location":"relations/foreign-key/#primary-key-value","text":"You can setup the relation also with just the pk column value of the related model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None )","title":"Primary key value"},{"location":"relations/foreign-key/#dictionary","text":"Next option is with a dictionary of key-values of the related model. You can build the dictionary yourself or get it from existing model with dict() method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None )","title":"Dictionary"},{"location":"relations/foreign-key/#none","text":"Finally you can explicitly set it to None (default behavior if no value passed). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None ) Warning In all not None cases the primary key value for related model has to exist in database . Otherwise an IntegrityError will be raised by your database driver library.","title":"None"},{"location":"relations/many-to-many/","text":"ManyToMany ManyToMany(to, through) has required parameters to and through that takes target and relation Model classes. Sqlalchemy column and Type are automatically taken from target Model . Sqlalchemy column: class of a target Model primary key column Type (used for pydantic): type of a target Model Defining Models 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 from typing import Optional , Union , List import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Author ( ormar . Model ): class Meta : tablename = \"authors\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) first_name : str = ormar . String ( max_length = 80 ) last_name : str = ormar . String ( max_length = 80 ) class Category ( ormar . Model ): class Meta : tablename = \"categories\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) class PostCategory ( ormar . Model ): class Meta : tablename = \"posts_categories\" database = database metadata = metadata # If there are no additional columns id will be created automatically as Integer class Post ( ormar . Model ): class Meta : tablename = \"posts\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories : Optional [ Union [ Category , List [ Category ]]] = ormar . ManyToMany ( Category , through = PostCategory ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) Create sample data: 1 2 3 guido = await Author . objects . create ( first_name = \"Guido\" , last_name = \"Van Rossum\" ) post = await Post . objects . create ( title = \"Hello, M2M\" , author = guido ) news = await Category . objects . create ( name = \"News\" ) add 1 2 3 4 # Add a category to a post. await post . categories . add ( news ) # or from the other end: await news . posts . add ( post ) Warning In all not None cases the primary key value for related model has to exist in database . Otherwise an IntegrityError will be raised by your database driver library. remove Removal of the related model one by one. Removes also the relation in the database. 1 await news . posts . remove ( post ) clear Removal of all related models in one call. Removes also the relation in the database. 1 await news . posts . clear () QuerysetProxy Reverse relation exposes QuerysetProxy API that allows you to query related model like you would issue a normal Query. To read which methods of QuerySet are available read below querysetproxy related_name By default, the related_name is generated in the same way as for the ForeignKey relation (class.name.lower()+'s'), but in the same way you can overwrite this name by providing related_name parameter like below: 1 2 3 categories : Optional [ Union [ Category , List [ Category ]]] = ormar . ManyToMany ( Category , through = PostCategory , related_name = \"new_categories\" ) Warning When you provide multiple relations to the same model ormar can no longer auto generate the related_name for you. Therefore, in that situation you have to provide related_name for all but one (one can be default and generated) or all related fields.","title":"ManyToMany"},{"location":"relations/many-to-many/#manytomany","text":"ManyToMany(to, through) has required parameters to and through that takes target and relation Model classes. Sqlalchemy column and Type are automatically taken from target Model . Sqlalchemy column: class of a target Model primary key column Type (used for pydantic): type of a target Model","title":"ManyToMany"},{"location":"relations/many-to-many/#defining-models","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 from typing import Optional , Union , List import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Author ( ormar . Model ): class Meta : tablename = \"authors\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) first_name : str = ormar . String ( max_length = 80 ) last_name : str = ormar . String ( max_length = 80 ) class Category ( ormar . Model ): class Meta : tablename = \"categories\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) class PostCategory ( ormar . Model ): class Meta : tablename = \"posts_categories\" database = database metadata = metadata # If there are no additional columns id will be created automatically as Integer class Post ( ormar . Model ): class Meta : tablename = \"posts\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories : Optional [ Union [ Category , List [ Category ]]] = ormar . ManyToMany ( Category , through = PostCategory ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) Create sample data: 1 2 3 guido = await Author . objects . create ( first_name = \"Guido\" , last_name = \"Van Rossum\" ) post = await Post . objects . create ( title = \"Hello, M2M\" , author = guido ) news = await Category . objects . create ( name = \"News\" )","title":"Defining Models"},{"location":"relations/many-to-many/#add","text":"1 2 3 4 # Add a category to a post. await post . categories . add ( news ) # or from the other end: await news . posts . add ( post ) Warning In all not None cases the primary key value for related model has to exist in database . Otherwise an IntegrityError will be raised by your database driver library.","title":"add"},{"location":"relations/many-to-many/#remove","text":"Removal of the related model one by one. Removes also the relation in the database. 1 await news . posts . remove ( post )","title":"remove"},{"location":"relations/many-to-many/#clear","text":"Removal of all related models in one call. Removes also the relation in the database. 1 await news . posts . clear ()","title":"clear"},{"location":"relations/many-to-many/#querysetproxy","text":"Reverse relation exposes QuerysetProxy API that allows you to query related model like you would issue a normal Query. To read which methods of QuerySet are available read below querysetproxy","title":"QuerysetProxy"},{"location":"relations/many-to-many/#related_name","text":"By default, the related_name is generated in the same way as for the ForeignKey relation (class.name.lower()+'s'), but in the same way you can overwrite this name by providing related_name parameter like below: 1 2 3 categories : Optional [ Union [ Category , List [ Category ]]] = ormar . ManyToMany ( Category , through = PostCategory , related_name = \"new_categories\" ) Warning When you provide multiple relations to the same model ormar can no longer auto generate the related_name for you. Therefore, in that situation you have to provide related_name for all but one (one can be default and generated) or all related fields.","title":"related_name"},{"location":"relations/postponed-annotations/","text":"Postponed annotations Self-referencing Models When you want to reference the same model during declaration to create a relation you need to declare the referenced model as a ForwardRef , as during the declaration the class is not yet ready and python by default won't let you reference it. Although you might be tempted to use future annotations or simply quote the name with \"\" it won't work as ormar is designed to work with explicitly declared ForwardRef . First, you need to import the required ref from typing. 1 from typing import ForwardRef But note that before python 3.7 it used to be internal, so for python <= 3.6 you need 1 from typing import _ForwardRef as ForwardRef or since pydantic is required by ormar it can handle this switch for you. In that case you can simply import ForwardRef from pydantic regardless of your python version. 1 from pydantic.typing import ForwardRef Now we need a sample model and a reference to the same model, which will be used to creat a self referencing relation. 1 2 3 4 5 6 7 8 9 10 11 12 13 # create the forwardref to model Person PersonRef = ForwardRef ( \"Person\" ) class Person ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # use the forwardref as to parameter supervisor : PersonRef = ormar . ForeignKey ( PersonRef , related_name = \"employees\" ) That's so simple. But before you can use the model you need to manually update the references so that they lead to the actual models. Warning If you try to use the model without updated references, ModelError exception will be raised. So in our example above any call like following will cause exception 1 2 3 4 5 6 # creation of model - exception await Person . objects . create ( name = \"Test\" ) # initialization of model - exception Person2 ( name = \"Test\" ) # usage of model's QuerySet - exception await Person2 . objects . get () To update the references call the update_forward_refs method on each model with forward references, only after all related models were declared. So in order to make our previous example work we need just one extra line. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PersonRef = ForwardRef ( \"Person\" ) class Person ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) supervisor : PersonRef = ormar . ForeignKey ( PersonRef , related_name = \"employees\" ) Person . update_forward_refs () Of course the same can be done with ManyToMany relations in exactly same way, both for to and through parameters. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # declare the reference ChildRef = ForwardRef ( \"Child\" ) class ChildFriend ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db class Child ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # use it in relation friends = ormar . ManyToMany ( ChildRef , through = ChildFriend , related_name = \"also_friends\" ) Child . update_forward_refs () Cross model relations The same mechanism and logic as for self-reference model can be used to link multiple different models between each other. Of course ormar links both sides of relation for you, creating a reverse relation with specified (or default) related_name . But if you need two (or more) relations between any two models, that for whatever reason should be stored on both sides (so one relation is declared on one model, and other on the second model), you need to use ForwardRef to achieve that. Look at the following simple example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # teacher is not yet defined TeacherRef = ForwardRef ( \"Teacher\" ) class Student ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # so we use reference instead of actual model primary_teacher : TeacherRef = ormar . ForeignKey ( TeacherRef , related_name = \"own_students\" ) class StudentTeacher ( ormar . Model ): class Meta ( ModelMeta ): tablename = 'students_x_teachers' metadata = metadata database = db class Teacher ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # we need students for other relation hence the order students = ormar . ManyToMany ( Student , through = StudentTeacher , related_name = \"teachers\" ) # now the Teacher model is already defined we can update references Student . update_forward_refs () Warning Remember that related_name needs to be unique across related models regardless of how many relations are defined.","title":"Postponed annotations"},{"location":"relations/postponed-annotations/#postponed-annotations","text":"","title":"Postponed annotations"},{"location":"relations/postponed-annotations/#self-referencing-models","text":"When you want to reference the same model during declaration to create a relation you need to declare the referenced model as a ForwardRef , as during the declaration the class is not yet ready and python by default won't let you reference it. Although you might be tempted to use future annotations or simply quote the name with \"\" it won't work as ormar is designed to work with explicitly declared ForwardRef . First, you need to import the required ref from typing. 1 from typing import ForwardRef But note that before python 3.7 it used to be internal, so for python <= 3.6 you need 1 from typing import _ForwardRef as ForwardRef or since pydantic is required by ormar it can handle this switch for you. In that case you can simply import ForwardRef from pydantic regardless of your python version. 1 from pydantic.typing import ForwardRef Now we need a sample model and a reference to the same model, which will be used to creat a self referencing relation. 1 2 3 4 5 6 7 8 9 10 11 12 13 # create the forwardref to model Person PersonRef = ForwardRef ( \"Person\" ) class Person ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # use the forwardref as to parameter supervisor : PersonRef = ormar . ForeignKey ( PersonRef , related_name = \"employees\" ) That's so simple. But before you can use the model you need to manually update the references so that they lead to the actual models. Warning If you try to use the model without updated references, ModelError exception will be raised. So in our example above any call like following will cause exception 1 2 3 4 5 6 # creation of model - exception await Person . objects . create ( name = \"Test\" ) # initialization of model - exception Person2 ( name = \"Test\" ) # usage of model's QuerySet - exception await Person2 . objects . get () To update the references call the update_forward_refs method on each model with forward references, only after all related models were declared. So in order to make our previous example work we need just one extra line. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PersonRef = ForwardRef ( \"Person\" ) class Person ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) supervisor : PersonRef = ormar . ForeignKey ( PersonRef , related_name = \"employees\" ) Person . update_forward_refs () Of course the same can be done with ManyToMany relations in exactly same way, both for to and through parameters. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # declare the reference ChildRef = ForwardRef ( \"Child\" ) class ChildFriend ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db class Child ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # use it in relation friends = ormar . ManyToMany ( ChildRef , through = ChildFriend , related_name = \"also_friends\" ) Child . update_forward_refs ()","title":"Self-referencing Models"},{"location":"relations/postponed-annotations/#cross-model-relations","text":"The same mechanism and logic as for self-reference model can be used to link multiple different models between each other. Of course ormar links both sides of relation for you, creating a reverse relation with specified (or default) related_name . But if you need two (or more) relations between any two models, that for whatever reason should be stored on both sides (so one relation is declared on one model, and other on the second model), you need to use ForwardRef to achieve that. Look at the following simple example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # teacher is not yet defined TeacherRef = ForwardRef ( \"Teacher\" ) class Student ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # so we use reference instead of actual model primary_teacher : TeacherRef = ormar . ForeignKey ( TeacherRef , related_name = \"own_students\" ) class StudentTeacher ( ormar . Model ): class Meta ( ModelMeta ): tablename = 'students_x_teachers' metadata = metadata database = db class Teacher ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # we need students for other relation hence the order students = ormar . ManyToMany ( Student , through = StudentTeacher , related_name = \"teachers\" ) # now the Teacher model is already defined we can update references Student . update_forward_refs () Warning Remember that related_name needs to be unique across related models regardless of how many relations are defined.","title":"Cross model relations"},{"location":"relations/queryset-proxy/","text":"QuerySetProxy When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. Note By default exposed QuerySet is already filtered to return only Models related to parent Model . So if you issue post.categories.all() you will get all categories related to that post, not all in table. Note Note that when accessing QuerySet API methods through QuerysetProxy you don't need to use objects attribute like in normal queries. So note that it's post.categories.all() and not post.categories.objects.all() . To learn more about available QuerySet methods visit queries Warning Querying related models from ManyToMany cleans list of related models loaded on parent model: Example: post.categories.first() will set post.categories to list of 1 related model -> the one returned by first() Example 2: if post has 4 categories so len(post.categories) == 4 calling post.categories.limit(2).all() -> will load only 2 children and now assert len(post.categories) == 2 This happens for all QuerysetProxy methods returning data: get , all and first and in get_or_create if model already exists. Note that value returned by create or created in get_or_create and update_or_create if model does not exist will be added to relation list (not clearing it). Read data from database get get(**kwargs): -> Model To grab just one of related models filtered by name you can use get(**kwargs) method. 1 2 3 4 5 6 7 8 9 # grab one category assert news == await post . categories . get ( name = \"News\" ) # note that method returns the category so you can grab this value # but it also modifies list of related models in place # so regardless of what was previously loaded on parent model # now it has only one value -> just loaded with get() call assert len ( post . categories ) == 1 assert post . categories [ 0 ] == news Tip Read more in queries documentation get get_or_create get_or_create(**kwargs) -> Model Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. Tip Read more in queries documentation get_or_create all all(**kwargs) -> List[Optional[\"Model\"]] To get a list of related models use all() method. Note that you can filter the queryset, select related, exclude fields etc. like in normal query. 1 2 3 4 5 6 7 # with all Queryset methods - filtering, selecting columns, counting etc. await news . posts . filter ( title__contains = \"M2M\" ) . all () await Category . objects . filter ( posts__author = guido ) . get () # columns models of many to many relation can be prefetched news_posts = await news . posts . select_related ( \"author\" ) . all () assert news_posts [ 0 ] . author == guido Tip Read more in queries documentation all Insert/ update data into database create create(**kwargs): -> Model Create related Model directly from parent Model . The link table is automatically populated, as well as relation ids in the database. 1 2 3 4 # Creating columns object from instance: await post . categories . create ( name = \"Tips\" ) assert len ( await post . categories . all ()) == 2 # newly created instance already have relation persisted in the database Tip Read more in queries documentation create get_or_create get_or_create(**kwargs) -> Model Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. Tip Read more in queries documentation get_or_create update_or_create update_or_create(**kwargs) -> Model Updates the model, or in case there is no match in database creates a new one. Tip Read more in queries documentation update_or_create Filtering and sorting filter filter(**kwargs) -> QuerySet Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. Tip Read more in queries documentation filter exclude exclude(**kwargs) -> QuerySet Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. Tip Read more in queries documentation exclude order_by order_by(columns:Union[List, str]) -> QuerySet With order_by() you can order the results from database based on your choice of fields. Tip Read more in queries documentation order_by Joins and subqueries select_related select_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during the same query. With select_related always only one query is run against the database, meaning that one (sometimes complicated) join is generated and later nested models are processed in python. Tip Read more in queries documentation select_related prefetch_related prefetch_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database, meaning that you will have multiple queries executed one after another. Tip Read more in queries documentation prefetch_related Pagination and rows number paginate paginate(page: int, page_size: int = 20) -> QuerySet Combines the offset and limit methods based on page number and size. Tip Read more in queries documentation paginate limit limit(limit_count: int) -> QuerySet You can limit the results to desired number of parent models. Tip Read more in queries documentation limit offset offset(offset: int) -> QuerySet You can offset the results by desired number of main models. Tip Read more in queries documentation offset Selecting subset of columns fields fields(columns: Union[List, str, set, dict]) -> QuerySet With fields() you can select subset of model columns to limit the data load. Tip Read more in queries documentation fields exclude_fields exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. Tip Read more in queries documentation exclude_fields Aggregated functions count count() -> int Returns number of rows matching the given criteria (i.e. applied with filter and exclude) Tip Read more in queries documentation count exists exists() -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude) Tip Read more in queries documentation exists","title":"QuerySetProxy"},{"location":"relations/queryset-proxy/#querysetproxy","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. Note By default exposed QuerySet is already filtered to return only Models related to parent Model . So if you issue post.categories.all() you will get all categories related to that post, not all in table. Note Note that when accessing QuerySet API methods through QuerysetProxy you don't need to use objects attribute like in normal queries. So note that it's post.categories.all() and not post.categories.objects.all() . To learn more about available QuerySet methods visit queries Warning Querying related models from ManyToMany cleans list of related models loaded on parent model: Example: post.categories.first() will set post.categories to list of 1 related model -> the one returned by first() Example 2: if post has 4 categories so len(post.categories) == 4 calling post.categories.limit(2).all() -> will load only 2 children and now assert len(post.categories) == 2 This happens for all QuerysetProxy methods returning data: get , all and first and in get_or_create if model already exists. Note that value returned by create or created in get_or_create and update_or_create if model does not exist will be added to relation list (not clearing it).","title":"QuerySetProxy"},{"location":"relations/queryset-proxy/#read-data-from-database","text":"","title":"Read data from database"},{"location":"relations/queryset-proxy/#get","text":"get(**kwargs): -> Model To grab just one of related models filtered by name you can use get(**kwargs) method. 1 2 3 4 5 6 7 8 9 # grab one category assert news == await post . categories . get ( name = \"News\" ) # note that method returns the category so you can grab this value # but it also modifies list of related models in place # so regardless of what was previously loaded on parent model # now it has only one value -> just loaded with get() call assert len ( post . categories ) == 1 assert post . categories [ 0 ] == news Tip Read more in queries documentation get","title":"get"},{"location":"relations/queryset-proxy/#get_or_create","text":"get_or_create(**kwargs) -> Model Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. Tip Read more in queries documentation get_or_create","title":"get_or_create"},{"location":"relations/queryset-proxy/#all","text":"all(**kwargs) -> List[Optional[\"Model\"]] To get a list of related models use all() method. Note that you can filter the queryset, select related, exclude fields etc. like in normal query. 1 2 3 4 5 6 7 # with all Queryset methods - filtering, selecting columns, counting etc. await news . posts . filter ( title__contains = \"M2M\" ) . all () await Category . objects . filter ( posts__author = guido ) . get () # columns models of many to many relation can be prefetched news_posts = await news . posts . select_related ( \"author\" ) . all () assert news_posts [ 0 ] . author == guido Tip Read more in queries documentation all","title":"all"},{"location":"relations/queryset-proxy/#insert-update-data-into-database","text":"","title":"Insert/ update data into database"},{"location":"relations/queryset-proxy/#create","text":"create(**kwargs): -> Model Create related Model directly from parent Model . The link table is automatically populated, as well as relation ids in the database. 1 2 3 4 # Creating columns object from instance: await post . categories . create ( name = \"Tips\" ) assert len ( await post . categories . all ()) == 2 # newly created instance already have relation persisted in the database Tip Read more in queries documentation create","title":"create"},{"location":"relations/queryset-proxy/#get_or_create_1","text":"get_or_create(**kwargs) -> Model Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. Tip Read more in queries documentation get_or_create","title":"get_or_create"},{"location":"relations/queryset-proxy/#update_or_create","text":"update_or_create(**kwargs) -> Model Updates the model, or in case there is no match in database creates a new one. Tip Read more in queries documentation update_or_create","title":"update_or_create"},{"location":"relations/queryset-proxy/#filtering-and-sorting","text":"","title":"Filtering and sorting"},{"location":"relations/queryset-proxy/#filter","text":"filter(**kwargs) -> QuerySet Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. Tip Read more in queries documentation filter","title":"filter"},{"location":"relations/queryset-proxy/#exclude","text":"exclude(**kwargs) -> QuerySet Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. Tip Read more in queries documentation exclude","title":"exclude"},{"location":"relations/queryset-proxy/#order_by","text":"order_by(columns:Union[List, str]) -> QuerySet With order_by() you can order the results from database based on your choice of fields. Tip Read more in queries documentation order_by","title":"order_by"},{"location":"relations/queryset-proxy/#joins-and-subqueries","text":"","title":"Joins and subqueries"},{"location":"relations/queryset-proxy/#select_related","text":"select_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during the same query. With select_related always only one query is run against the database, meaning that one (sometimes complicated) join is generated and later nested models are processed in python. Tip Read more in queries documentation select_related","title":"select_related"},{"location":"relations/queryset-proxy/#prefetch_related","text":"prefetch_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database, meaning that you will have multiple queries executed one after another. Tip Read more in queries documentation prefetch_related","title":"prefetch_related"},{"location":"relations/queryset-proxy/#pagination-and-rows-number","text":"","title":"Pagination and rows number"},{"location":"relations/queryset-proxy/#paginate","text":"paginate(page: int, page_size: int = 20) -> QuerySet Combines the offset and limit methods based on page number and size. Tip Read more in queries documentation paginate","title":"paginate"},{"location":"relations/queryset-proxy/#limit","text":"limit(limit_count: int) -> QuerySet You can limit the results to desired number of parent models. Tip Read more in queries documentation limit","title":"limit"},{"location":"relations/queryset-proxy/#offset","text":"offset(offset: int) -> QuerySet You can offset the results by desired number of main models. Tip Read more in queries documentation offset","title":"offset"},{"location":"relations/queryset-proxy/#selecting-subset-of-columns","text":"","title":"Selecting subset of columns"},{"location":"relations/queryset-proxy/#fields","text":"fields(columns: Union[List, str, set, dict]) -> QuerySet With fields() you can select subset of model columns to limit the data load. Tip Read more in queries documentation fields","title":"fields"},{"location":"relations/queryset-proxy/#exclude_fields","text":"exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. Tip Read more in queries documentation exclude_fields","title":"exclude_fields"},{"location":"relations/queryset-proxy/#aggregated-functions","text":"","title":"Aggregated functions"},{"location":"relations/queryset-proxy/#count","text":"count() -> int Returns number of rows matching the given criteria (i.e. applied with filter and exclude) Tip Read more in queries documentation count","title":"count"},{"location":"relations/queryset-proxy/#exists","text":"exists() -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude) Tip Read more in queries documentation exists","title":"exists"}]}